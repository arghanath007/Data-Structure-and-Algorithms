# TOC

## Motivation

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dfb4fce-5b66-4a58-8260-3591eb6708bc)

## Syllabus

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/67e960e4-abc6-4c11-bb0f-615be22d1258)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbc0f3a7-9e89-4a70-a93f-4f3a4806dd78)

* Link -> https://unacademy.com/course/complete-course-on-theory-of-computation/ON3TCUN5?_branch_referrer=H4sIAAAAAAAAA8soKSkottLXL81LTE5MSc2t1EssKNDLyczL1jepdM%2F1SQ0t83FOAgAdZnNEJgAAAA%3D%3D

## Practice Class

1) -> https://unacademy.com/class/toc-practice-class-1/XCUW1FGE
2) -> https://unacademy.com/class/toc-practice-class-2/G37UT7VH

## introduction-to-theory-of-computation (1) [3rd Sept 2023]

* TOC is nothing but mathematical representation/study of computing machine and it's capabilities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/746564f6-4f2a-4faf-8788-fd12ef5418e7)

* First mathematical model is ready and then the model is sent to algorithms(Close to programming language).
* Model -> Algorithm -> Coding
* Language -> Collection of string.
* String -> It is nothing but collection of characters.
* aabb -> It is a string. There is no meaning of it in the english language.
* Formal language -> It is also collection of strings only but meaning of the string is not important but format of the string is important.
* aabb -> Two a's followed by two b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d264ad18-54fd-4584-8b97-753a1dfecfd8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95df5916-4e93-4a3f-bba1-633a45df3eb3)

* In this subject, meaning is not important but the **format is important**.
* a ^ 2 -> Two a's
* b ^ 2 -> Two b's
* a ^ 10 * b ^ 10 -> 10 a's followed by 10 b's

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70630489-07c3-428e-9063-319ed54022b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3038f041-4f0f-4a30-bc87-26b34939f30b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ad4880b-7b17-415e-9399-cbf4fe3413a0)

* Meaning is not there but format is there.
* In machine language, format is important.
* In human language, meaning is important.
* **W** is one string.
* '*' -> Combination.
* **W** is one of the strings which is a **combination(*)** of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ed863f7-7467-4a28-81a7-aecc983743a9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d729926b-bc67-43ed-8c97-e2989121a3b6)

* **W** is combination of a's and b's.
* Reverse of **W** is **W ^ R**.
* **L** -> Palindrome.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/194dd818-3441-452a-941a-fa0228474b81)

* Order is **important**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a04a3851-a540-4997-bf0f-b79583963354)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/94f1873d-1e31-4a0a-8631-48f4a83470e3)

* Formal Language -> Set of palindromes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0dd66a2d-9b8b-454e-a8f7-29e916a711d3)

* One of the formal languages where there are infinite no. of strings.
* 'n' number of a's followed by n-number of b's.
* **W** -> We can take any combinations of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78ec184-fc4b-4038-b49b-da28a258be32)

* a's should come first and then b's should come
* Infinite language as no boundaries.
* How many a's and how many b's, no relation
* 'm'-no. of a's followed by 'n'-no. of b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9bfc043b-6c9e-404c-a2fd-61c398263adb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f16d7f6-18db-4914-baa9-46fdf565277e)

* Like these many formal languages

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13edd8d6-8fb3-4671-a66d-1872c15e5ce9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab7487ee-b304-4498-a7e7-feeca0b7e4d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d710f226-4e31-41d4-87f7-c8b1c088347f)

* L = {WW} -> String Copy.
* Exact matching.
* Whatever we see **first** that same thing should be there in the **second** as well.
* No. of actual parameters = No. of formal parameters.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8429b54a-3cc8-4cf7-b7d6-571f414afca4)

* Examples.
* There are **four types** of formal languages:- [According to Chomsky]

1) Type3(T3) formal language
2) Type2(T2) formal language
3) Type1(T1) formal language
4) Type0(T0) formal language

* **Type0** is the superset among all of them.
* **Type3** is the subset among all of them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ddddb1b-8268-411b-a4fb-125fec4e992e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cac07f41-807e-4138-97f4-7ddf905c0b56)

* R3 -> Smaller -> Regular Language
* T0 -> Bigger.
* Our computer program maximum can be **Type0(T0)**. No chance of more than that. It is the limitation of the computer.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e290a64c-c906-46bf-9a17-5823dd96b7b4)

* To accept smaller language(T3), smaller machine is enough.
* The smaller machine is called as **Finite Automata(Machine)**.
* Automata means **machine**.
* Finite Automata means finite machine
* Finite Automata also called as **Finite State Machine(FSM)**
* Which one is the smaller formal language?

> **T3**.
* Other name of **T3** is **regular language**.
* **Regular language** is accepted by a machine called as the **Finite Automata(Machine)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaa5d6ab-6780-47d2-949b-56dfdaaf04eb)

* Other name of **T2** is **context free language(CFL)**.
* The machines that accept **context free language(CFL)** are called as **Push Down Automata(PDA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b863c99-6c93-4138-889b-278605bbd17d)

* Other name of **T1** is **context sensitive language(CFL)**.
* The machines that accept **context sensitive language(CFL)** are called as **Linear bounded Automata(LBA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f72166d-552e-446f-ab98-4e6803a9d5ac)

* All computer programs are **T0**.
* Other name of **T0** is **Recursive Enumerable languages(REL)**.
* The machines that accept **Recursive Enumerable languages(REL)** are called as **Turing Machine(TM)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74f6bda0-a63c-4e57-80fc-bf6efbb8eca4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0fbb9888-93fe-41b1-a868-856e35bd07fd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aca784a8-83ee-4308-8361-7936a9b363b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74569991-dd48-4dfb-a964-ca0ffc0722c0)

* Turing Machine is equal to computer.
* Regular language accepted by a machine called as **Finite Automata**.
* Formal languages and Automata theory(FLAT).
* Computing machine and it's capabalities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eedbb788-cc01-4c55-be70-0723778c85bc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e06c5c53-99f5-49d3-9854-ceb2fd3bd142)

* In general,
* T3 is the **subset(C)** of **T2**.
* T_i+1 is the **subset(C)** of **T_i**.
* Type3 means Type0 also.
* By default, every/all formal languages are **Type0**.
* Every machine is a subset of **Turing machine**.
* **Circle** indicates **state**.
* Two states are **S1 and S2**.
* State -> State is nothing but the thing which can remember something. [Remembering Capability]
* State is nothing  but **Remembering Capability**
* State is changing and remembering capability is also changing.
* Nothing knows/known -> Starting State.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c116a8e0-169a-4599-854d-46dc717c4388)

* Remembering capability is **increasing** so our state is **increasing**.
* Empty State -> S1 [Initial days]
* 'a' -> Mama's name
* **S2** means **a** completed
* **S1** means nothing completed.
* Same State
* If something new happened, then we may go to **other state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a9b1f25-f11a-4e7a-a802-dad45eca1ad5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9c6eb1e-f007-4530-908a-d902603117a8)

* Double Circuit(Double circle) means **final state**.
* After accepting **a**, the automata is in **final state**.
* After completing **aa**, the automata is in **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e620dab2-4763-4708-9bf8-317f3b53d776)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0251b251-09b4-447e-bebe-b8332c900f27)

* The **automata** will accept the **above language**.
* In the automata, there are **two(2) states**.
* That's why it is called as **Finite state machine(FSM)**, it it called as **finite automata**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83aa4eae-7daa-4346-8e74-e66ff8dfc28f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee57ac3c-a5e8-4697-aa4b-38bdddf13887)

* The finite automata is accepting **L1** formal language.
* Finite automata is accepting some formal language means the formal language is a **regular language**.
* Finite automata will accept **regular language** only.
* This formal language(L1) is a regular language.
* For the formal language(L1), finite automata(FA) is available so the formal language(L1) is a regular language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a868e695-5c0c-4e69-9f63-9e95b02c6abf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30b15c92-1ff7-4a5f-a0ae-9daf46c931b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e5e8914-a32c-42d2-899e-f45773136625)

## difference-between-nfa-dfa(2) [4th Sept 2023]

* Why these many Automata's?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fcb26a7-2fe7-4711-9027-9597e109140a)

* Between a's and b's there is a **relation**.
* How many a's will come, those many b's should come.
* What is the minimal string?

> 'ab'.

* If the minimal string is 'ab', then the length of the minimal string is **2**.
* Minimal string is 'ab' of length **2** then **start automata** is of **three states**.
* States -> Minimal string length  + 1 -> 2 + 1 -> 3
* With **three states** start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87e54840-82ee-4c97-a229-ddfd6bb6d5af)

* **Every circle** indicate **state**.
* **Double circle** indicate **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39fc7de4-d639-44e4-b23e-0bb06f9bbb38)

* Starting state is **S1**.
* Final state is **S3**.
* Initial or initially arrow to whom, that's the **starting state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/670988fb-7cdf-442e-96e1-a5435105df25)

* After reading **ab** from starting state we can go to **final state*** then **ab** is accepted.
* Minimal string **ab** is accepted.
* With the **three states**, start the story.
* When can we say that a machine is a correct one?

> One valid think cannot be rejected. One invalid think cannot be accepted.

* All valids are accepted.
* One invalid cannot be accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbbfc3b9-7604-4f74-8cec-e19ff01a6a2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1671c305-6f61-4e82-a182-d82e207ccbb2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96f44ef5-f907-44f2-964b-cb24dbc59d0e)

* The automata we have constructed is **wrong**. As it is accepting **invalids** as well.
* To this language, finite automata not possible.
* a's and b's are always equal in the language.
* **Loops** means it may come and it may not come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/001e5520-1f4c-471f-bf13-9344323f3191)

* This is called as finite automata or finite state machine.
* Finite state machine has failed to accept the **above language**.
* As **Finite state machine has failed**, we are going to the **next automata**.
* The **next automata** is **PDA(Push Down Automata)**.
* **Push and Pop** operations come in **stack** data structure.
* FA(finite automata) fails to accept above language, so we are going to **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d2e0bf7-3087-4a0e-adee-c6aa3dbd3a71)

* In the above diagram, we are not keeping any relation between **a's and b's**, a's are coming any no. of times, b's are also coming any no. of times. This is a **problem**.
* a's loop can be repeated **infinite** no. of times. So, b's loop also repeat **infinite** no. of times.
* If a's loop is repeating 10 times then b's loop should also repeat 10 times.
* But unfortunately there is **no relation**.
* **a** repeating whatever way it want, **b** also repeating whatever way it want.
* **a** repeating 10 time and **b** repeating **1 lakh** time.
* We didn't keep any **condition**.
* **PDA** is nothing but **finite automata(FA)** only including **one(1) stack**.
* In **PDA**, **stack** also there.
* Just add one more stack to **finite automata(FA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e07ad5c-b803-4d8f-a6cf-f91093c0b433)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c019b9a2-3470-460a-90c8-86933ed72fb1)

* **#(Hash)** indicates(marker) -> **Stack empty** -> Nothing there in the stack.
* Top of the stack, **#** means that the stack is **empty** now.
* How do we know string is over?

> There is a **marker**, which is the **dollar($)**.

* **Dollar($)** indicates -> **String is over**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ad6328d-a1c3-4eca-86d7-d73be4fd549c)

* Every **a** is pushed into the stack. As **three a's**, so **three push** operations.
* When **b** is coming, then start **pop operation**.
* It is because we have to count the **no. of a's and no. of b's**. [**IMPORTANT**]
* We have to count that **no. of a's** =(equals) **no. of b's**.
* For every **b**, pop **'a'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10e352ad-8dcf-4f03-a262-f3f7937e0d04)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32a543f7-7e73-413c-91d9-bf2593b16e70)

* Next symbol coming in the input is **$**, which means **string is over**.
* **$** means **String is over** and **String is over**  means **b's** are over.
* Now, at the top of the stack, we have **#** which means **stack is empty**.
* **Stack is empty** means **a's** are over.
* When we got to know that **b's are over** and **a's also over**, it indicates that **no. of a's** are **equal(=)** to the **no. of b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/520afa32-74fd-4ed3-9c45-fb24664bacd0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/798db7be-749c-402e-9bc2-703334a8e62f)

* Yes.
* No. of a's == No. of b's.
* Now, **String is accepted**.
* **$** -> String is over -> b's are over.   [**IMPORTANT**]
* **#** -> Stack empty -> a's are over.      [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd9cb26e-69a1-45d7-95e1-740b395a6bff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1cc2ecb-57af-4940-ad39-e945cd71794b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4d47c15-2c54-452b-be1b-cc81a69fbbbf)

* aaab$
* Top of the stack should be **Hash** but unfortunately still **a** are there.
* So a's are **more**.
* It is **invalid**.
* In **PDA**, when is the string accepted?

> At the end of the story, **stack** should be **empty**.

* If **stack empty** then only **string is accepted**.
* String is over($) but still stack is not empty.
* So **string rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/430aeeab-34aa-47fb-8690-34b92d5007ba)

* **Stack** is taking care about **how many a's came** and afterwards b's will come.
* In **finite automata**, we do not have any track of **how many a's came**. We don't have **stack**.
* If we want to compare a's and b's then until b's comes, we should store a's somewhere(stack).
* We have to keep track of a's, **how many a's came**. We have to store somewhere.
* **Finite automata** don't have **stack**.
* Comparison minimally requires **two people**.
* So, until **b's come**, we cannot do **comparison**.
* Until **b's come**, **a's** have to wait.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb809f5a-e046-4c07-9af7-356d7e99f189)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/100cbb97-7c52-4b42-b3a7-7e10d6307b46)

* a's more
* At the end stack should be empty then only **accepted**, otherwise **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5817a5b-a5db-4811-8eba-ae214923fb5c)

* In the **stack**.
* Stack not empty, that's why **rejected**.
* My language, a's = b's.
* Finite automata fails to recognize those languages where comparison is **involved**.
* When comparison is involved, finite automata fails we need **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d209403-2293-4232-9223-4f1d91e109e0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e0a9bd3-7033-447a-8f2e-0bd06584e74a)

* Every valid thing should be **accepted**.
* No invalid thing should be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d6952b7-fd0b-4de0-b51b-5a90a7b3946b)

* In these language, we have to compare, a's = b's = c's.
* Two comparisons are involved over here.
* When **a** is coming, push in both the stacks(S1 and S2).
* When **b** is coming, pop only in **S1** stack. For every **b**, pop 'a'.
* When **c** is coming, pop only in **S2** stack. For every **c**, pop 'a'.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d8ed4e8-9fc0-422e-9015-b556749ff33f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a46014a2-1ec2-42ab-b211-c05b16a99f91)

* When we saw the first **c**, **b's** is over which means that **a's** also over.
* It indicates that **a's = b's**.
* Whenever b's over, then a's also over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51779c8c-63bb-43e8-a973-0aab990d57e1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f188c39-40b8-48a8-8dc4-68142e7dd42f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a35e6b65-ab6c-4cfa-b02f-998c3950ac8f)

* **$** means **c's** is over.
* **c's** is over means that **a's** also over.
* It indicates that **a's = c's**.
* We also proved that **a's = b's**.
* So, indirectly we have proved that **b's = c's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/687f43e4-5e8c-4ec4-bda7-9683cf42186a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22aa49bc-c917-4981-a0f3-9cc2e75a03b3)

* When two comparisons are there, this is the story. 
* Now, using **one stack**.
* Because of two comparisons, we have done **two stacks**.
* With **one stack**, can we do this?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aeb89b79-7352-4ef7-a02f-79970392d6db)

* Suggestion
* **one a** for 'b' and **one a** for 'c'.
* For every b, pop 'a'.
* For every c, pop 'a'.
* Finally stack is empty.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad0584d5-d179-4f4a-a362-f3d7175f9cb2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c32c956d-98af-4ae4-9d77-c354d44a1760)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3dc6664-c88e-4a38-a22f-9b0d7554400a)

* No invalid ones should be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c7ba6be5-5cf8-43a3-80dd-57fa28ace195)

* Another suggestion.
* Nonsense going on.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2301e938-3b6c-4145-bd84-7643fe8066cf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66e21007-a55e-4278-b6a1-8b23315dadb0)

* More than **one comparison**, **PDA** fails.
* One stack, we cannot do.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da0f6785-ae38-4a62-a4c4-6e499a3d1d31)

* When comparison required -> Finite automata fails -> PDA says, it can.
* Only one comparison -> PDA.
* More than one comparison -> PDA fails -> With one stack we cannot do.
* Here, two comparisons needed, so **PDA** fails because it(PDA) can handle max. of 1-comparison.
* For these reason, we are going to **Turing machine(TM)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e564cb54-c1a8-4aa3-a122-1db11ae3b9d8)

* **Turing machine(TM)** -> For the existing PDA, add one more stack, so total of **two stacks** now.
* PDA already contains one stack.
* **Turing machine(TM)** -> Finite automata(FA) + 2-stacks.
* PDA -> Finite automata(FA) + 1-stack

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3796003c-ab94-48c2-9ec0-8615f6464f14)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d322e07-5d8b-4c6a-99cd-7f3e5cbc8235)

* **LBA** is theoritically present. Practically not there.
* LBA only for name sake.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc59591f-d492-4882-b7c8-53442a216756)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7124302c-013a-49cb-9812-05e8566ba61d)

* Exam -> 4 Automatas
* Outside of Exam -> 3 Automatas(FA, PDA, TM) [Since **LBA** is only theoritical]
* More than one comparison -> Turing Machine.
* Turing Machine means **two stacks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b37b661-a47c-447e-9306-1b9d461903e3)

* When 'b' coming, pop 'a' and push 'b' into the other(seecond) stack.
* For every 'b', pop 'a'.
* When **b's** are over, stack is empty, so **a's = b's**.
* For every 'b', pop from first stack and push in the second stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ade51065-ccf1-4809-9d2b-7d7fc4650600)

* For every 'c', pop 'b' and push 'c'.
* When **c's** is over, stack is empty, so **b's = c's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b33836a-6a03-4800-bda2-20ff07459900)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7da2ebc-18bf-48dd-8956-be2d9f99eef3)

* Again one stack is empty.
* For every 'd', pop 'c' and push 'd'.
* When **d's** is over, stack is empty, so **c's = d's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/346b2ab6-41ce-4853-8366-fe4ac2a41b99)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ccdd282-6465-4798-8cfd-3835f2744aa2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fea6d77f-d20d-43f8-8440-7b623420f6b0)

* Using **Turing machine**, we can do anything.
* With **two stack**, we can do anything.
* Computer is nothing but **finite automata with/plus 2-stacks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0e87046-62ed-493c-8990-da126ccd7c89)

* At the end of the string, stack is empty then **string is accepted**.
* First all a's should come, then all b's should come and so on.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0fa9647-a062-4ec5-92cc-75b6627cba5b)

* Inside the computer many programs.
* For every logic, there is **turing machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ece7a79-f14c-4758-b654-6276d0bedd8e)

* FA + 1-stack -> PDA
* PDA + 1-stack -> Turing machine
* Power of **turing machine**, **equals to** the power of the **computer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/78e219bf-6e27-4c03-9cd5-3de93f2fed55)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/537598ee-4d21-4bc2-8c8d-451b54b18ee2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c838ade4-7c98-437f-9e39-7c01652ad863)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d67a728-62ff-4ae7-97d2-ad0de3181d5b)

* Alphabet -> It is **finite** non-empty set of symbols.
* Any language where the **alpha bit size** is **infinite**, no way.
* Language -> Atleast one letter/symbol required.
* **Alpha bit** is changing from machine to machine.
* Machine changes -> Language changes -> Automatically Alpha bit changes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38d01a94-a4ad-4636-93a6-29032696c6f9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42ca96a1-a19d-4af3-9fe5-a461b475f5de)

## dfa-construction-i(3) [4th Sept 2023]

* Alphabet(sigma) -> Finite non-empty set of symbols.
* String -> Collection of symbols over the given alphabet.
* abbc -> It is not a string because 'c' is not there in the **alphabet**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b220616d-7f78-468d-9f08-b2473effa4b6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9034b3e3-2128-4673-8acc-1f7d66cf6043)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e9279c21-2025-44da-9f55-fcf05a52da1f)

* One length strings, two length strings, three length strings possible.
* Epsilon(E) -> It is a string, whose length is zero(0). It is a zero(0) length string.
* That's why it is called as **empty string/Null string**.
* When we write **one symbol**, atleast **one length required**.
* Total TOC going on with **Epsilon(E)** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f41742b-3bba-4b31-9a24-752bb463dba5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7c588ed5-ad13-43d0-8071-4d60e19816d2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/649a9482-23f4-44e1-a20e-a4c623d08c36)

* Sigma = {a,b,c}, what is the minimal string possible over this alphabet?

> **Epsilon(E)**

* It is the **special person**.
* Epsilon(E) Length -> Zero(0).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71976527-d320-44dc-80fd-ed7ed8a23e3b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81209bf4-f776-4666-90e2-18533d6ff4e4)

* When we **concatinate** anyone with **Epsilon(E)**, we get the length of the **anyone string**.
* At the end of the day, we are concatinating **two string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b53152f9-c24c-4cf9-af13-2dc9c7b2a12e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75cf7ef1-e6e9-4117-9729-c81cfdc4a026)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cf671a2-cf64-4735-b220-a0a219178bc7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25af01b1-d4b6-4ca5-82ed-9e237e2ef8c5)

* String length -> Modulo operator.

### Power of a alphabet

* Sigma -> {a,b}
* Sigma ^ 1 -> Over the alphabets(a,b), what are the **1-length strings** possible.
* Sigma ^ 2 -> Over the alphabets(a,b), what are the **2-length strings** possible -> **Inside the sigma, we have to go **twice or two** times**.
* When we go inside **sigma**, take anything.
* Sigma ^ 3 -> Over the alphabets(a,b), what are the **3-length strings** possible -> **Inside the sigma, we have to go **thrice or three** time**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01d1eb92-a16b-49d4-9e10-3f86b1318927)

* Sigma ^ 100 -> **Inside the sigma, we have to go 100 times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4fd496a-49b9-45d7-8253-f739941980e4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a4b259a-dda7-4c81-8c1c-9f1b534f3931)

* Sigma ^ 0 -> **Inside the sigma, we have to go '0' times or don't go inside**. We don't get anything. We will get **Epsilon** only.
* Sigma ^ 5 -> **Inside the sigma, we have to go '5' times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1d7e6e4-dabe-4e7f-a727-941713b02d87)

* Sigma ^ * (sigma to the power of star) -> It will give every possible string over the given alphabet.
* It is also called as **complete language**.
* In set theory it is called as **universal set**.
* Set of all strings over the given alphabet including **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3be222d4-0df5-4c26-8b6d-768a56539439)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0876eab9-3744-4ceb-a03a-4c499ffde246)

* N -> Set of natural numbers.
* It is **Countably Infinite(CI)**.
* Something we can list out, it is **Countably Infinite(CI)**.
* {1,2,3,4} -> **Countably Finite(CF)**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f67a8c95-1f0e-4ad2-ad76-56ec5f9ace92)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06ed0ce6-601f-4b52-b5c1-aac33283ccf2)

* Uncountable.
* Set of real numbers.

* Sigma ^ * -> Means everything including Epsilon.
* '*' -> Kleen closure
* Sigma ^ + (sigma to the power of plus(+)) -> Only Epsilon missing.
* '+' -> Positive Closure.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e913695-f30b-476d-9259-da52e1073d79)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9aa8c5b9-c181-4100-9f83-cbc489990cc7)

### Language

* Language -> Collection of strings over the given alphabet is known as **language**.
* In the language, infinite no. of strings are here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c014480-ebbf-428d-bace-816eedb49f7d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f5c3658-e6a9-4cb3-9a36-1f402c2d8d1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81a06104-6b08-440a-8338-84cb6d87ab64)

* Example
* In general, **language(L)** is **subset or equal to (sigma ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77c6b719-d3a2-4d8a-8e16-059dde51fc84)

* More than **(sigma ^ * )** is not possible. Not possible, no concept there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5aeb8821-55ff-424d-b99f-291d5281a267)

* From everything take a **subset**.
* We can take **infinite as well as finite** subsets.
* Don't go beyong **(sigma ^ * )**.
* Empty set is subset to every set.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc5b66ec-5f52-4e82-9ea2-7f77102f497f)

* **L5 and L6** are **language** because they both are **subset** of **(sigma ^ * )**.
* In **L5 language**, the language is **not empty** but the string accepting is **empty** string.
* In **L5 language**, **one string** is there whose length is **zero(0)**.
* In **L6 language**, the language itself **empty**. No one is there. One string is also not accepting.
* We can take **everything** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3bd6146e-9e74-4267-96b2-b6a932de527c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f4cb14e-20fa-45bc-9bb6-da5509b670ed)

* Countable Language

1) Countably finite -> Set of all Indians.
2) Countably infinite -> Set of all natural numbers, Set of all computer programs, Set of all Turing Machine.

* Uncountable language -> Set of all real numbers

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d3c1226-de64-478f-9f5f-e9968da02418)

* Computer program is nothing but Turing Machine.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2ef958c-7015-4696-ae62-2ac9d39066cc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/231894ff-907d-4305-a4c4-48d189bc792b)

## doubt-clearing-session(4) [4th Sept 2023]

## Finite Automata and Regular Languages [**IMPORTANT**]

* Finite Automata:- [Types]

1) Without output

* DFA
* NFA

2) With Output

* Moore Machine
* Mealy Machine

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92ee9b63-70f2-4810-8100-99149e2ab340)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/957efb2d-3d57-48b1-a560-534a429db5c3)

* Finite automata without output means if we give **string**, it will say **string** accepted or rejected.
* This is finite automata as a **language accepter or rejecter**.
* Finite automata accepting the language or not.
* This is finite automata as a **language recognizer**.

* Finite automata with output, it will give **output**.
* If we give two binary numbers, it will give **sum** as the outut.
* This is finite automata as a **output generator**.
* Incrementation, **2** becomes **3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/740510ea-2e11-4e56-988b-96bcc5a6c2e1)

* When can we say that a language is regular?

> For that particular language, if we can construct a finite automata.

* If we can do that then the **language** is a **regular language**.
* **W** can be anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b0cd5df-c266-4cf7-9755-4cb3dc18e14b)

* In the **a ^ n**, except the **first 'a'** and in **b ^ n**, excet the **last b**, remaining definitely will be taken care off.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/680a2515-9030-48e4-a591-83f655ce9474)

* If **finite automata** is possible then the **language is regular**.
* **Finite automata** as a language recognizer
* **Finite automata** as a **output generator**.

### Finite Automata without output.

* Finite Automata without output -> DFA and NFA.
* By default **NFA**.
* Deterministic means very less people know clearly.
* Until and unless mentioned about **DFA**, we will not go for **DFA**.
* Finite Automata(M) is a **machine**.
* It(FA) is also having some story.
* Every machine is having some story.
* Inside **FA**, some states are there.
* **'Q'** -> Finite and non-empty Set of states.
* Every machine accepts some language. When we say it is accepting some language, every language is in need of some alphabets.
* Every machine has some purpose.
* **Sigma** -> Alphabet, used for input purpose. **Input alphabet**.
* Until and unless the total diagram is available, we cannot tell what is the **language**.
* Total machine should be available.
* Until and unless we see the total machine, we cannot say what it will do.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/872375db-1009-4d60-92b2-6d056265931a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ba12bfb-7c9c-4b31-851e-2fdbc31bfe18)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c0e92d4-0085-4f0d-8809-c6ce1e31ef86)

* Until and unless we see the total machine, we cannot say what it is going to do.
* If we **combine**, then that is **our sigma**. That is our **input alphabet**.
* Union of all language we know, that is **our sigma**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a19f253-50d3-4514-8a7d-92e5ffed8c3b)

* Sigma = {a}
* It means that the language contain one letter which is **a**.
* All combinations of **a** are allowed, which are the **strings**.
* Alphabet is indirectly deciding what should be there in the **language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7683ab9-34cb-4a7a-9cdd-290ab2489f1a)

* Finite automata given -> States are given and Input alphabet also given.
* **Sigma(Input alphabet)** for ATM is **0 to 9**.
* Every machine having some **Sigma(Input alphabet)**.
* Every maching having some **language**. Every maching will accept some **language**, in that language what symbols are allowed that is called **input alphabet**.
* Output maybe something else.
* In the **output** some symbols are allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/91c00137-dd6f-4630-a53e-f23cd79b50e2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d343a3dc-5d9c-486e-978e-7ad04b854f23)

* We cannot write **output** here as we are designing **FA without output**.
* When we are designing **FA with output** then the **output alphabet** will also come.
* **Without output** -> Language recognizer.
* It will finally say **string accepted or rejected**.
* At the end of the input string if we are in the **final state** then **string is accepted**.
* At the end of the input string if we are in the **non-final state** then **string is rejected**.
* **F** -> Set of final states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0e1d5c8-518d-48db-8d75-b9fb80481f01)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77d19ce8-aa65-4f99-b462-39ac53e303c2)

* Finite set's **subset** is **finite** only.
* **F** is the **subset or equal to 'Q'**.
* From one machine to another machine, some changes are there.
* In some **automatas**, **two states** maybe final.
* In some **automatas**, **every state** is final state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/664b1e62-ddf3-4233-a7a8-bfa7631a24b9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/913e2d27-7c25-4a6e-b580-f6a26940f90d)

* Finite automata **without final state or no final state**, it will accept **phi**.
* Language of that automata is empty language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f5b91fb-f97a-4951-b910-801f1a7c657a)

* Alphabet maybe many, but no final state.
* Delta -> Transition Function.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5519788-6b2c-436a-b902-ad1016cbcb81)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80d6f265-1843-4ab0-826e-597c4da1095a)

* Transition Function -> We are going from one state to another.
* We can write the function or draw the diagram.
* They are same.
* **q0** -> Only one start State or initial state. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f4824ee-b129-4cc5-bf76-2819b9be7afd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed54e804-3443-408d-bfb3-f667ed9fb8ae)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55f92203-2500-4ddb-9f49-b939284019ca)

* [**IMPORTANT**]
* All these 5 things are there.

1) Set of states
2) Input alphabet
3) Set of final states 
4) Transition function
5) Start state

* If finite automata is given then these **5 things(above)** are given.
* These finite automatas are without output.
* These finite automatas are for **language recognizer** purpose.
* Lastly **yes or no**, did we reach **final state** or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f041157f-a77c-49ec-9cd6-2604e6bc3677)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c89ed602-fbf2-4610-b14d-ec6942bd4333)

* This is why finite automata is called as **5-Tuple machine**.
* This is for **NFA and DFA** both.

 ![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd540da7-6414-45c9-ab62-b3866af1925a)

* Initial arrow indicate **starting state**.
* Double circle indicate **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8be2b638-8a89-4b2f-94c0-7a32b9bedc8f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31ff63fa-f68c-432b-b81e-c531d424e8d8)

* Q = {S1, S2}
* Sigma = {a, b}
* F = {S2}
* q0 = S1
* Transition Function

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/783e2874-6298-4393-98fd-a8158c670f15)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/156f1976-f2bc-43df-9a6b-501a9d23aa5d)

* By looking at the table, we can say that we have **two states** in the automata.
* '*' -> Final State
* '->' -> Initial state.
* Automata can be represented in the **transition diagram** or in the form of **transition table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e922ac68-522f-40ec-92f4-ec33b787d2c8)

* Representation of FA:-

 1) Transition diagram
 2) Transition table

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aee2be0d-ae02-45ad-a876-f9d619549e2f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39920f66-3131-4b6f-956a-9752adf8dfdf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18c5b1ec-e24e-4139-8a93-96e3b65f2b6a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59078eeb-0ee8-4e97-9538-481b3e832c67)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/537abe13-ec00-46d5-9c17-bfecf6b00f08)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88980c7e-96b9-4ad0-b1ab-401755398e68)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e3aee15-c0be-4bcf-b049-b62b50bf0b3a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b55e0741-d944-43ff-8de1-eb3995933385)

* Two diagrams
* First diagram, from each and every state for every input symbol, we are exactly going **one state**. Not more nor less.
* This is **DFA(Deterministic Finite Automata)**.
* Exactly having one single behaviour. Deterministic behaviour

* In the **second diagram**, **S1** on **input 'a'** is not going anywhere. **S2** on **input 'a'** is going many places(S1 and S2).
* This is **NFA(Non-deterministic Finite Automata)**.
* Different plans are going on. Confusing family.
* No Clarity.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bba8df00-ad48-4609-8946-1a32255d1762)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62d3ac48-c39b-4b0e-a5b9-c751fe0e9f62)

* [**IMPORTANT**]
* DFA -> In the case of **DFA** from each and every state and for every input symbol, exactly **one transition**. Not more nor less.

* All **algorithms** are **deterministic algorithms**.
* Each and every state -> Rows are covered.
* Each and every input symbol -> Columns are covered. 

* NFA -> In the case of **NFA** from each and every state and for every input symbol, we have zero transition, one transition or more than one(1) no. of transitions(zero or more than one(1) no. of transitions).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c907d56c-c507-4db3-b4c4-11ae1f6bbdf6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05bb5fc9-7ca0-4836-8323-6a431c58c7fb)

* **NFA** having many possibilities.
* **NFA** is more flexible or a lot of flexibility.
* **DFA** construction is **difficult**. Everywhere **1** only.

* While construction **NFA**, luckily everywhere **1** possibility is there. This is also **NFA** and it is a **special NFA**, called as **DFA**.
* A special type of **NFA** is called as **DFA** where, everywhere **1** possibility only.

* Every **NFA** is **DFA** -> **NO**.
* Every **DFA** is **NFA** -> **YES**.
* **Superset** is **NFA**.
* **Subset** is **DFA**.
* **DFA** having **less possibilities**.
* **NFA** having **more possibilities**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63988f0b-4982-4a12-9e08-ccc6db053fde)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a82e2550-5b97-4458-986d-2c7ed5c3d7d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07914c9a-823f-4f90-899d-276465aa13d3)

* Every DFA is NFA but every NFA need not be DFA
* **DFA** is a **subset** of **NFA**. [Will be confusing]

## dfa-construction-ii (5) [5th Sept 2023]

* Construct minimal DFA that accepts all strings of a's and b's where in every string, where the starting letter should be **a**.

1) First the language first.

* Minimal String to be accepted -> aa
* Sigma -> {a, b} -> a or b
* Can also be written as, (a + b) -> a or b.
* Both are **same**.
* Anything -> (a + b) ^ * -> (a, b) ^ *.
* Whole Star('*') -> We can go inside any no. of times. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a626bcc-4101-4585-8e0f-9485cb20d1ae)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d034028f-b7f1-45f9-ae67-2a06189e926b)

* 'a' followed by **anything**.
* (a, b) ^ * -> (a + b) ^ * -> (a OR b) ^ *.
* They are **same**.
* These **automata** will accept all strings of **a's and b's**.
* Sigma -> {a, b}
* All strings -> Sigma ^ * -> {a, b} ^ *.
* Starting letter is **a**.
* **a** followed by **anything** is ok.
* **(a * (sigma ^ * )) -> (a * (a, b) ^ * )** 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5ad985a-bda2-4ebd-9963-b662245e5704)

* a * b -> ab -> We cannot write this as (a, b). It is **one people only** -> Concatenation -> 'a' followed by 'b' -> Two strings became one string only.
* Followed By -> Dot(.) -> Concatenation.
* a + b -> a or b -> It is **two people**, either 'a' or 'b' -> **OR or union** operation -> 'a' or 'b'.

* If we want to make **two strings** as **one string** then we will use **Concatenation**.
* If we want to make **two strings** as **two strings** only then we will use **Union**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc0fa6e7-6244-4853-a108-e765f020e7c2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f67e1b30-c54b-4748-89e8-dceb90e1db20)

* 'a' followed by anything -> a.(sigma ^ *) -> a.(a+b) ^ * -> a(a+b) ^ *.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa1a29c1-8a1e-48c7-8484-b8ec237d07d9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6136af1-ec50-4be3-88bb-cfd8ac5eb180)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f458211c-37c3-4538-84f8-a115b9d4dd27)

* As whole star(*) is not there, by default power is **1**.
* We can go inside **once only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b4c87c7-854e-4cf8-8392-43ac06cc3a8f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed970a5b-e528-495b-ae48-6d7ad020409c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82295f28-bf5b-438e-a817-ca8bf8181bbf)

* Three operators:-

1) Plus('+') -> Union
2) Dot('.') -> Concatenation
3) Star('*') -> Kleene closure.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65e90ab3-adc4-46b5-bb26-7ae22f4efd8a)

* Minimal String -> **a**.
* Minimal Length -> **1**.
* Without minimal string, don't try to create a **DFA**.
* If the **Minimal Length** is **1** then with **1 + 1 -> 2** states, start constructing the **DFA(Automata)**.
* On the **transitional line** also keep the **minimal string** symbol.
* Make the **last state** as **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c4b8dce-3d04-4d0e-9b88-3edb3e6e085e)

* Starting from **S0** by reading **a**, it will go to **final state(S1)**. **a** is **accepted**.
* The purpose of **states** is that every **state** will **remember something**.
* (a + b) ^ * -> Minimal is **epsilon**.
* At the end of the string, where we are that matters.
* At the end of the string, are we in **final state**? 

> It is **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8db192d4-da42-47e3-8ebe-002ab6acebff)

* If **loop** is not there, then we cannot **accept infinite things**.
* (a + b) ^ * -> It generates **infinite** people.
* If we don't keep the **loop** then we cannot accomodate the **infinite** people.
* We have taken **2 states**, as it is a **finite automata**. We cannot take **more states**.
* The **language** given is **infinite language**. The only condition is that the **starting** should be with **a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e335f4f-f062-4e57-b248-94b50b2cff93)

* In **((a + b) ^ * )**, we can take **epsilon**. Overall we cannot take **epsilon**.
* Overall no change of **epsilon** as already **a** came.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8cd2174c-b91e-444f-8594-27a9af1ca2a1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9141e3a8-5df4-46b6-bd85-2be44bc7b7a1)

* aabab -> String accepted.
* We came to **S1** it means that we started with **a** only.
* If string not started with **a**, we cannot come to **S1**.
* We have to start automata from **starting state** only.
* We cannot start from wherever we want.
* Valid thing, starts with **a** only.
* We started from **S0** and after looking at **'a' input** we changed the **states** to **S1**.
* If we want to remember **something new** then only **change the states**. [**IMPORTANT**]
* Every state having some meaning.
* **S0** on **input 'a'** -> **S1**.
* **S1** on **input 'a'** -> **S1**.
* **S1** on **input 'b'** -> **S1**.
* Sigma -> {a, b}
* States -> S0 and S1.
* States are **two** and inputs are **two**.
* **DFA** means, if we want or not, we have to complete eveything.
* In the **language**, starting with **b**, nothing will come.
* Deterministic -> We have to saw for everything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f9f3992-0848-4226-a7d2-da5338d486b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d0e6c69-7eb4-457d-9109-cbbe66a49000)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcb8dae3-90f1-4c5e-ab31-82d72fa89d82)

* Required things are completed, stop the diagram.
* This is **NFA**.
* Computer programs are **DFA**.
* We have to say everything.
* According to the **language**, **starting 'b'** is not possible.
* If someone starts with **b** then **no change of final state**.
* If we come to **S2** then no change of going to final state(S1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8435f11-709e-4b6c-8a71-d3b811b3a08f)

* This is not **DFA**.
* **a and b** we are not covering in **S2**.
* After staring with **b**, anything will come, we cannot go to final state(S1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/577c187c-c6fa-4355-bb27-06a1e8f72cc2)

* This is **DFA**.
* Deterministic algorithms.
* **S2** will say that string already started with **b**.
* In the diagram, we have **three states**.
* Final states -> 1 [S1]
* Non-final states -> 2 [S0 and S2]
* If at the end of the string, if we are in the **non-final states** then **string** is **rejected**. 
* If at the end of the string, if we are in **final state** then **string** is **accepted**. 

* From **S0** anyway to go to **final state**?

> If we are at **S0** then we have **some hope** of going to **final state**.

* From **S2** anyway to go to **final state**?

> If we are at **S2** then we have **no hope** of going to **final state**.

* So, **S2** is called as **dead state**. 
* **Dead State** -> Non-accepting state and no hope as well.

> **S0 and S2** are both patients in one of the hospitals, after testing is over, the doctor said that there is **some hope** for **S0** patient. **S2** is dead already. **S2** already gone.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/667c0f6b-d223-4942-8676-3035ea537929)

* **S2** is there because of **DFA**.
* We have to include everything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17bea880-24ea-469a-b49b-cd727720f461)

* **Dead state** is one of the states.
* If anyone comes to **Dead state**, they cannot move any further. No way.
* Behaviours matter.
* Names doesn't matter.

* From **S2** state, we cannot reach the **final state(S1)**. So **S2** state is a **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c9e381f-24d2-40af-a663-903cb555b4cc)

* If we remove the **loop** then the automata will not be **DFA**, it will be **NFA**.
* Because of **DFA**, we have to keep the **loop**.
* If a string is starting with **b**, then there is **no change** of reaching the **final state**.
* **S2** means already stated with **b**.
* After starting with **b**, anything happens we do not care.
* Total states -> 3
* Minimal DFA contains **3 states**.
* Dead state means **no acceptance**.
* **S2's** behaviour is **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fa51cbb2-60f0-4df4-8cf9-729d6f7344cb)

* Minimal Finite Automata -> NFA -> 2 states
* Minimal DFA -> 3 states

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac43c76b-49d8-4501-916e-594b225f7643)

* [**IMPORTANT**]

* CMDFA -> Construct Minimal DFA
* L = {Set of all string over a and b}
* Sigma ^ * -> (a,b) ^ * -> (a + b) ^ *
* Minimal String -> Epsilon.
* Epsilon length -> 0.
* With **0 + 1 -> 1** states, start the **automata**.
* With **1 state** that itself is **starting and final** state.
* Actually by reading some symbol we go to the **final state**.
* Without reading anything, we are going to the **final state**.
* It means that **epsilon**, we read.

* **NOTE** -> Start state itself is the final state then by default **epsilon** is accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ad23f4e-2571-49f0-84d4-743539a34485)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff64aac2-f284-40d1-b8ea-5f0ecc4c209a)

* Nothing special.
* Here, no condition, everything OK.
* Everyone allowed.
* It is **DFA**.
* If it is **DFA**, then indirectly it means that it is **NFA** also.
* Everywhere exactly **one transition**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a23f5f0b-8f12-4876-9a31-1d189104db77)

* If **conditions** are **more** then **states** are **more**.


* CMDFA -> Construct Minimal DFA
* L = {Set of all string over a,b excluding epsilon}
* Sigma ^ + -> (a,b) ^ + -> (a + b) ^ +.
* Except **epsilon**, everything will come.
* Minimal String -> 1 length
* With **1 + 1 -> 2** states, start the automata.

* Whenever there is **some hope** then that state is not a **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/230f1150-9679-4e2b-aad6-ca08f667c8cc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb7cdbcd-d2ed-4781-aefa-c0f201ec8efb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6516a8f7-701a-4e29-ab9b-ecfd51619b9f)

* If we come to **S5** state, then we are **dead**. We have no change of going to the **final state(S3)**. 
* Other than those **three(a, ab, ba)**, if anything else comes, **reject** all of them.
* In total we have **5 states**.
* It is a **finite** language.
* After some point of time, all of the strings are over.
* Whenever it is a **finite** language, after some point of time, all strings are over.
* Even though all are over because of **DFA**, we have to cover some unnecessary things.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e2a6444a-97ce-47a9-adbd-2b56f660eb42)

* If we construct a **DFA** for a **finite language** then compulsory **dead state** required because other strings, we have to reject.
* Only three strings accept remaining reject. The red color indicate remaining. The remaining is **infinite**. There is a **loop** also.
* Whenever we say **infinite**, **loop** required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cf430051-d66f-4501-b814-5cb9781a83b2)

* DFA  for finite language -> Dead State mandatory.
* Only three strings, we have to accept. After three string are over because of **DFA** other strings we have to take care. We have to **reject** them.
* The language is saying **only three strings**, not more not less. There is no atleast nor atmost.
* Most of the time **final state** is **one(1)**. Sometimes maybe many, sometimes maybe all.

## dfa-construction-iii (6) [6th Sept 2023]

* L = {Set of all strings of a's and b's where everything end with b}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abe8d44e-27c2-49e1-b03c-0999bf136025)

* Starting **anything** is OK but followed by **b** at the end.
* **((a + b) ^ * ) * b** -> **Regular Expression**.
* **anything** followed by **b**, **concatenation(dot)** will come.
* If we don't write anything, by default **dot** there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82fd6df7-9e52-4026-aa73-77777ad4e760)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de977d1b-218c-454c-81e2-04429e996eef)

* For any language if we construct a finite automata, then that language is a **regular language**.
* Every **regular language** should have **regular expression** also.
* When we say **finite automata** is there, then **regular expression** is also there.
* Minimal String is **b**. No **epsilon** here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/15aac143-b716-4341-9186-157d5e138967)

* Start with **a**.
* **S1 and S3** both will **reject** as they are both **non-final** states.
* **S3** will reject permanently
* **S1** will reject temporarly.
* Finite language means it will accept only a few strings.
* For a Finite language we have to take care about **infinite** also as it is in **DFA**.
* We have to take care of **everything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ffa689ed-57f9-4577-a821-c7d037d838a6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c32c138e-83f0-4cb7-b2ea-dce116a480d7)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f2ee6b0-5541-499f-b123-a323cfa62328)

* **S2** indicates already started with **a**.
* When we are **confirmed**, change the state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44c3ec69-8609-436e-ba7c-41eb947b510c)

* Ending condition -> Ending with **b**.
* Minimal string -> **b**
* Minimal length -> 1
* With the **1 + 1 -> 2** states, start the automata.
* We are in **S1** and the string has not ended.
* Afterways when string ends with **b**, we will go to **final state(s2)**.
* **Loop** means the symbols may come or may not come.
* Mandatory thing, then only change the state.
* Before **b** anything can come.
* We want to write **a,b** in the loop, but we have written only **a**.
* We cannot write **2 b's**. It will be a dilemma machine because **two** different behaviour.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6425beba-cb34-4284-9588-5d04199557e8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1327dd6a-7c54-41bf-8268-c944f1f67336)

* Minimal string accepted -> From starting state to go to the final state, what are the strings we are reading without taking care of the loops. 
* On **S1**, we are going to **S2** by reading **b**.
* We are at **S2** means that string already ended with **b**.
* Ending with **one 'b' or 1 lakh b's** doesn't make. Same thing. Keep a **loop** in **S2**.
* First minimal string of the **automata** is **b**.
* In **minimal strings**, we don't care about the **loops**, no loops.
* The **loops** we have to take **one time**, the **minimal string** is **abb**.
* In **S2**, ending with **b** guranteed.
* We can keep changing **ending**.
* If **a** came at the ending then wait at the **non-final state(S1)**. Afterwards **b** will come, then go to **final state(S2)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a15a7f4-fa84-49e5-b35d-5f0dd3f7edec)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77b99f57-d683-4b8e-a0f8-44228d8fbd2a)

* **Starting** we cannot change.
* **Ending** we can change.
* If we get a string ending with **a** then finally we are at the **non-final state(S1)** and the string is **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d0a189f-b25e-4f47-b463-0320a30d8fec)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce4be864-992b-4cc8-b8d7-f9e05bb0889e)

* Ends with **a** we will go to **non-final state(S1)**. We cannot say this is the ending. Ending will keep on changing.
* In **ending with something** condition, there is **no dead state**. [**IMPORTANT**]
* In **starting with something** condition, there is **dead state**.  [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d178e1e-842f-4d94-9015-2a53fdd5d588)

* On the string **ba**, we will be in the non-final state **S1**. So **rejected**.
* There is hope of going to **final state**.
* **Ending** will keep on chaning.
* **Starting** cannot change.
* Who will go to **dead state**?

> When there is **no hope**.

* **Ending** condition, don't go to **dead state**.
* **Starting** condition, go to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ca37d7f-e852-4629-82ef-23962bceb7c8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8702f42-61ed-486d-ba0e-9e0d93fdd31c)

* We have **2 states**.

* L = {Set of all strings contain 'ba' as substring}
* **ba** should be there somewhere in the string.
* Minimal string -> ba.
* Minimal Length -> 2
* With the **2 + 1 -> 3** states, start the **automata**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e0fd8775-8e6c-4ee3-94fc-4bf05081db32)

* ((a + b) ^ *) * (ba) * ((a + b) ^ *)
* For any language, **regular expression** is possible then **DFA and NFA** are possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2aace801-dbd0-42d3-b3f1-69a5ba5005a3)

* Yes.
* To prove some **language** is a **regular language**, we can write **NFA or DFA** or maybe we can write **regular expression**.
* Out of all the **three**, whichever we can **prove** is possible then others are also possible.
* Just **prove one(1)** out of the **three**.
* **Regular expression** indirectly saying so many things. It is saying that the language is a **regular language**. **Regular expression** there means **DFA and NFA** also there.
* One thing we find out, remaining things also there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0073998-0d4f-469a-8ad6-964e3ed055ef)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a5eca91a-8a91-40d2-9cf9-a02947e04659)

* Every state we have to take care.
* **S3** said that already **ba** came.
* After **ba** anything is **OK**.
* **S1** said that after me, **ba** will come.
* In **S2**, already **b** came and after me, **a** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/153ef7df-82d2-494a-b0ac-487c7fdf5483)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a4ff8a8-15a3-44f5-b126-63c21f63096b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/362f4fc8-0d7b-4e03-b529-0ddea35ad8a5)

* Please respect every state.
* **Minimal DFA** is **unique**.
* **DFA and NFA** are **not unique**.
* Minimum **3** states required.
* Starting or ending no condition. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d0c7bbc3-bc21-4d8c-9173-2e1bff2b33a1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/348adf4c-2aff-4d99-a1d8-85b3868f1dee)

* Ask every state. What are you?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/490b5240-ef45-4c62-8e3f-ec0db4fca8aa)

* 3 states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3efb61d-c08f-4c38-95e0-f032d97a3b14)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4d39baa-b56f-45ad-b55c-6efbf46270d8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59667c07-73ad-43a8-aab1-6b5e823e5895)

* Minimal DFA construction -> Dead State needed or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3bd3db52-5bf8-476c-babb-3fcad01c7e4b)

* L = {All string of a's and b's where every string starts with 'a' and end with 'b'}
* Minimal String -> ab.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a63dd89-acdc-4ed3-9c11-5cd44200ff83)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dc6e4d2-5e29-4e07-aa0e-f324f070f2ae)

* **a * ((a + b) ^ * ) * b.
* Minimal String -> ab.
* Minimal length -> 2.

* **S2** saying that already starting with **a** done, ending with **b** will come afterwards.
* **S2** gurantees starting with **a**.
* **S1** saying that after me, string will start with **a** and will end with **b** and it will reach the **final state**.
* Starting with **b**, go to **S4** state which is the **dead state**.
* If starting with **b** then no need of checking the ending.
* No hope is there.
* **S3** saying that string already started with **a** and ending with **b** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/04a01e08-5258-4538-a9d1-ba19f3ae7332)

* If unformunately **a** came at the end then **ending problem** but already started with **a** confirmed. Ending only problem, so go to **S2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6cb2c03-0e18-4440-abbd-87e6af51ef9b)

* **S1** saying that if nothing started then come to **S1** but we already started with **a**, that's why we are going to **S2** if we get **a** at the end.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f338111-008c-4c22-99c0-c6bcfd74b358)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d9109e6-5528-462c-a989-d9e10e57365d)

* Starting symbol we cannot change.
* We are in **S3** means that string started already. Not only started but **starting with 'a' and ending with 'b'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12983716-df8a-4933-9b52-549ecee14892)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/916fdb84-7ae0-45a9-9f92-0ca0c6ae6e16)

* Ending problem and starting no problem.
* We don't have starting problem.
* At the end, don't go to **dead state**.
* We should go to **non-final** state.

 ## dfa-construction-iv (7) [6th Sept 2023]

* L = {All strings of a's and b's where each string length is exactly 3}

* Minimal length -> 3
* **3 + 1 -> 4** states to start the **automata**.
* (a + b) ^ 3 -> We have to go inside exactly three times. It gives exactly three length string.
* Everywhere **2 choices, '3' times**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d2cd671-c71b-48b9-aee7-d693cb1d0cf3)

* No.
* Star(*) means **many times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a8d25c7-5b67-4de1-8e94-f9818b84b20f)

* More than '3' length string coming, no way of going to the **final state**.
* No hope is there.
* Going to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74783245-69fc-4528-9070-547f257be681)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f7fc248-162f-45c3-af40-f63c396772d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9881426-f4c5-4f27-a950-14a4eafd239b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d777d6dd-1a61-489a-999b-6880ce017678)

* [**IMPORTANT**]

* L = {Atleast 3-length string}
* 3,4,5,6,7, .......
* ((a + b) ^ 3) -> Exactly 3 length string.
* ((a + b) ^ 3) * (Epsilon) ^ * -> ((a + b) ^ 3) * ((a + b) ^ *) -> After exactly 3 length string over, anything can come.
* ((a + b) ^ *) * ((a + b) ^ 3) -> Anything followed by **three length string**.
* The string should be **atleast of length = 3**, doesn't matter if it is in the front or at the back.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b20cda85-5461-428a-8e5d-c7440adbd5c0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9995027-65ac-4d84-bfbc-ffa154759336)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcd194b0-ebb8-4773-a032-502318cf6860)

* We can write more than 3 in the before or after as well.
* Anyside  we can take.
* ((a + b) ^ *)  * ((a + b) ^ 3) * ((a + b) ^ *)
* Minimal DFA is **unique**. [**IMPORTANT**]
* There is **no minimal unique regular expression**.
* **Minimal NFA** is not **unique**.
* Minimal length -> 3
* **3 + 1 -> 4** states are need for the automata.
* It will accept all three length.
* We are in **S4** means that the **3-length string** is over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a4b43ac-0ff2-4a2b-a1a3-d6f8744dbcd0)

* This is **NFA**.
* More than **3-length** is also ok.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84f2ab11-5b8e-48e0-a758-9d13ebf00666)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5492f20-c2bc-4ea6-8a20-ace2e9f12dcc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b8a0aa3a-5359-44ac-b61f-2dee462b2233)

* All of the **three regular expressions*** are going the **same thing** only.
* In any expression, if these symbols(*, dot(.), +) are there combined, individually, then the expression is called as **regular expression**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a842efe-68e6-40c0-be54-76c2fd1b8bc1)

* There is **no unique regular expression**.
* All three are **regular expression**.
* Minimal **DFA** is unique.
* Minimal **NFA and regular expression(RE)** is not unique.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cb9e109e-c4c7-4459-bc5a-0122b207b394)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f75fa02e-218d-437c-8ef8-e4917182f2b4)

* **Note**:-
* Minimal DFA atleast 3-length -> 3 + 1 -> 4 states -> No dead state required
* Minimal DFA atleast 100-length -> 100 + 1 -> 101 states -> No dead state required
* Minimal DFA atleast n-length -> n + 1 -> (n+1) states -> No dead state required

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/170291ca-40cd-4494-9dd7-4758ef11b91b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f3866ae-5dff-4484-9463-07903b97f41e)

* If asked in **MSQ** and all of the **three expressions** are given then all of the **three** are **correct**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0edfe886-e125-4af2-915f-952b677b13d8)

* [**IMPORTANT**]
* **NFA** is possible for **regular language**.
* **Regular language** means **NFA, minimal DFA, DFA and regular expression** there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d25b46a-c676-463b-bf0a-c4a3e4e5b167)

* L = {Set of all strings of a's and b's where each string length is almost 3}
* It is a **finite language**
* As it is a **finite language**, so the **Dead state** is compulsory.
* Minimal length -> 0
* Minimal string -> Epsilon
* Initial state = Final State -> Epsilon accepted condition.
* **0 + 1 -> 1** state needed to start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31730ce2-792b-4a74-bf3b-634e50fca002)

* Zero(0) length string is **accepted**. Epsilon accepted.
* If we keep **self-loop** then **1-lakh a's** are also accepted, which we don't want.
* So no **self-loop** allowed. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d760185-a79e-437d-aa53-3f115597999b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36716dbf-cf0e-4a6d-a2bd-ec7ceeeff6ca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f90acbd7-4290-43db-905e-6a2bf421c1bc)

* As we have **0,1,2 and 3** string length as **accepted** that's why all of the states are **final states** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36d8560b-f69f-49da-8776-7999a3f45327)

* There is **dead state**.
* More than **3-length string** is **rejected**.
* Minimal DFA -> Atmost 3-length -> 3 + 1 = 4 states -> 4 + 1 = 5 states ['1' is a dead state] 
* Minimal DFA -> Atmost 100-length -> 100 + 1 = 101 states -> 101 + 1 = 102 states ['1' is a dead state] 
*  NFA -> Atmost 3-length -> 3 + 1 = 4 states [No dead state in NFA] 
*  NFA -> Atmost 100-length -> 100 + 1 = 101 states [No dead state in NFA] 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/025d96fa-db8e-41b3-8f28-9af75305c82b)

* Every **dead state** is not only **non-final state** but also **permanently non-final state**. **Yes**.
* But every **non-final state** is not **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/610f7e2d-fee7-41ee-ac14-4d191e2bafe4)

* Non-final state -> **D** state -> Dead State.
* Max. characters allowed are 3 characters or strings of length = 3.
* This problem having maximum **3** places.
* In every place we can keep **a or b or epsilon**.
* We can go inside **exactly 3-times**.
* Everytime we can select whatever we like.
* **zero(0) length we add three times, we get zero(0) length only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8b0610e0-d81a-433c-b54e-1b5b8cdbf658)

* Two length will come
* One length will come
* Three length come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ede19d6-6210-4540-878a-3bcd353ba993)

* Three times only allowed. More than **3** not allowed.
* If we do **(sigma ^ * )**, the answer will be **1 lakh**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b622f786-57e3-4f76-b876-a6d9dc5df188)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cd84c46-94db-4617-a623-4e66f6a4d39f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55d83f99-9bfb-4ff1-a6c8-65c055c7480a)

* **Whole cube** doesn't mean that all are **three length**. **NO**.
* This is the reason.
* We don't know what's inside. 
* **Whole cube** -> Go inside **three** time.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a06d36f9-000b-4e69-98e9-45cafba11b72)

* Yes.
* Inside can be **anything**.
* What is there inside, please check.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7820aa91-0405-484e-96db-12f9b41ea4ff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f106f1a-5716-448a-b0a5-9f98a566c74a)

* [**IMPORTANT**]

## dobut-clearing-session (8) [6th Sept 2023]

* Prefix -> Set of all leading symbols -> Starting onwards we have to read -> Leading symbols should come -> Starting is compulsory.
* L = {Accepting all prefix of string abababab..... }

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53597f98-fc6f-4f10-8a13-9983420fa1d1)

* First prefix is **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/deb7b513-850f-4dcc-91e5-d7b1dae12b34)

* How many proper **prefix** are there?

> **Exclusing itself/himself**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c91325a4-01a0-4dcd-8e88-6d5ad6e59927)

* For an **n** length string, the no. of **prefix** are **(n + 1)**.
* For an **n** length string, the no. of **proper prefix** are **n** only.
* Minimal length prefix is **zero(0)** which is **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17a455e9-a6b0-4909-8eb3-8e85efa64e40)

* Minimal string -> epsilon
* Minimal length -> 0
* **0 + 1 -> 1** state, start the automata.
* All valids should be **accepted**.
* All invalids should be **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/308dba47-a612-4816-8122-f2944b9c718c)

* NFA.
* Accepting all **valids**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2a4dd004-d94c-4e51-9e2d-308f76843a12)

* Minimization of DFA [Later]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bdb0ae32-d1c3-4c85-9c72-b6223899d75b)

* We are doing **minimization of DFA** on **1** to get the **minimal DFA** which is **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25c7fb80-f6b0-41e3-8565-5602a2f97d92)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01397f24-e5db-4421-b132-92ebf4a9facc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/64bfb61c-ea40-4b1d-9295-8367f9c4fbdf)

* Now this is **DFA**.
* Starting with **b**, there is **no prefix**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1b7c3f9-95a7-4c00-b4d0-08d5ff85dee5)

* They don't go **outside**.
* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e60eb2ae-618f-4960-8ddc-6ea7c0c87cc9)

* Use the already **dead state**. No need of another one.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4db0122f-0e18-45c2-ba4d-911add02ab9a)

* No string is starting with **b**.
* Side by Side **a** is not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8094207-61d2-4d96-8e0f-36290e650d83)

* The string is not going to me our string, **now also and in the future also** then it is in **dead state**.
* **DFA** is not unique, **minimal DFA** is **unique**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbbb09f8-a78f-4e82-bbfa-fa69cdca6998)

* When **no hope** then go to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7a76ade-0a6a-4974-8469-884196297feb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/141082fe-2c95-4f63-b360-7c5401cb0753)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e6beb78a-ce18-4794-9a6e-7c21d5a57933)

* L = {All strings of a's and b's where length of each string is divisible by 5}
* 0/5 = 0.
* **Zero(0)** is divisible by **5**, **YES**.
* We don't care what's inside the strings, whether they are a's or b's.
* We only care about the **length of the string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf7b9d4d-081d-4e91-af1f-bd9c65304128)

* AP series.
* Common Difference -> 5 [Loop/cycle]
* With a **5** length there is a loop/cycle also.
* If anything will create an **AP series**, it is compulsory that **finite automata** is **available**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2af94a43-a7b9-4a04-8619-9b7ef97ad29f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2554389b-6144-4a30-90c5-e05069a01a92)

* With a **5** length there is a cycle.
* Every **5**, we have to come back. That's the **common difference**.
* Every **5**, we will **accept**.
* In **minimal DFA** where every string length is divisible by **n** contains **n-state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4354b36b-7021-4c63-a168-2b97e1cfaa0a)

* Language is **regular** or not.
* We will just check if **AP series** is coming or not.
* If **AP series** is coming then **finite automata** is possible.
* **common difference** means **cycle** is possible with that **common difference**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b951b5de-2563-4078-b7af-433bf8ed2734)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36c4cb46-3488-42d4-add5-e76a68cdf762)

* AP series possible
* Common difference -> 1.
* One length cycle is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/971f767a-8195-4ba4-aa13-c6a91157debf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e3e1a49-7621-447b-8027-2d2963f6f556)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b257437c-4d92-4c22-941e-c1525049fb27)

* AP series coming or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe1ce1a7-097d-4705-95e1-060c1445148c)

* If we make **S0** as **final state** then **0, 5, 10, 15...** length strings are **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6a51486-5724-4980-b4b6-0fee49b0f3ca)

* Make all of the **non-final** state from before as **final states** now and the **final state** from before as **non-final** state.
* Whatever we were **rejecting** before, now we are **accepting** them.
* This is the **minimal DFA** for **accepting** all of the strings who length is **not divisible '5'**.
* This is the **complement** of the previous one.
* This is **L'**, 'L' complement.
* **L'** -> {Set of all strings of a's and b's where each string length 'not' divisible by 5}.

* If any problem, **not** is there then we will **remove 'not'**. Construct for **without 'not'** first. After that, do a **complement** which is make the **final states** as **non-final states** and the **non-final states** as **final states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0ff867f-52a5-4028-90cd-9471c7812f7b)

* [**IMPORTANT**]
* Don't try to create **'not' first**.
* First create **without 'not'**.
* **Epsilon** is not accepted here.
* **5 a's** are not accepted
* **3 a's** are **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f23458b2-d52f-43e2-9c68-f6854ae3181e)

* L-complementation(L').

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e6b8013-97c6-460e-ba4f-3aa38429b09b)

* L
* A' -> Other than **A** -> From universal set(U) remove **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e1704ca-f2b8-4b51-b4f9-22e1cb045110)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23b320ff-fb4c-4a54-adbe-dcd6aed3472c)

* If two people are **complement** to each other then **L intersection L' = Phi** and **L U L' = (Epsilon ^ * )**.
* Union should be everything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7876b813-83e2-4970-ada7-7e2deb2fd15e)

* L and L' are complement to each other.
* Try without **not**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/810193f8-086c-42bc-bdd1-347f83cb8804)

* If **L** is a **regular language** then **L'** is also a **regular language** because for **L'**, **DFA** is also possible.
* If it is **NFA** and we want **complementation** by interchanging **final and non-final** states, **NFA** will not given **any gurantee**.
* For some questions, there is **no answer**.
* In **DFA**, **complementation** works.
* If we have **NFA** and we want the **complement** then first we have to convert the **NFA** into **DFA** and then do **complementation** on that **DFA**.
* Don't do **NFA complementation** directly.
* **DFA complementation** is **guranteed** and always **possible**.
* **NFA complementation** is **no gurantee**.
* **NFA** means multiple things.
* Finale(F)
* Non-finale(NF).
* It will work in **both directions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/debbb8e1-3333-4226-bffd-257fb63d4bd7)

* On **S1** with **input 'a'** there are **two** different behaviours.
* **a** possible in both the cases/places(L and L')
* Both are accepting **a**, that is **not possible**.
* In **complementation**, how something is **common**.
* In **complementation**, intersection should be **phi**.
* **NFA complementation** is **no gurantee**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56e7a7ae-5ccd-4d9e-92c3-dddc680cf918)

* **DFA complementation** is **guranteed** and always **possible**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22b7074e-e66c-43f6-aa51-f165d4d86377)

* Do **conversion** first and then do **complement**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e17d649-3b3c-48f7-9ae9-c5b95dc85ae1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a7626d7-67dd-4a42-8753-9c9105e97332)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3dc598f7-b8c1-48ef-8610-14a2e0f27f9e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1e603bb-e92f-4b4f-8292-66f0058c6047)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21b32f18-bd13-47c2-ac7f-5fec82081e1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0be37e61-d727-4f05-8fac-2e0ce1e28898)

* Because of **NFA** we cannot give any gurantee.
* We have to do **manually**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3b06d7c-841c-48c9-b5dc-1a34d7125b0f)

* Now, interchange
* Final -> Non-final
* Non-final -> Final
* What is **L1**, if it is **DFA**?

>  (Sigma ^ *) - L.

* As we have **NFA**, there is **no gurantee**.
* We have to check **manually**.
* We got **(sigma ^ * )**.
* Everything **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee950985-a49f-4692-aa04-c46b36dbd067)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e815a47-da9a-4217-98b3-2a70e48af796)

* What is **L1**?
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/278f82f1-27b2-40ea-babb-1b8e9a25f5ae)

* **DFA** is direct.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38498d17-aede-4f88-b78f-7974f43acaeb)

* When we say **language** take the **accepted** things.
* When **language**, check what are **accepted** things.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37ab1efe-18f6-49eb-bfa0-0c1f4a93dee8)

* When **DFA** is there then the **language** is a **regular language**.
* **DFA** there means there is a **AP series**.
* All are **related**.
* From **DFA** we can get **minimal DFA**.
* From **NFA** we can converted to **DFA**.

## dfa-construction-v (9) [7th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ec88083-6b17-456c-bebe-b18528a250b6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83010aa8-b621-4e48-b15b-635049e22dc2)

* Epsilon is accepted, only a's are accepted, only b's are accepted, a's followed by b's are accepted.
* Minimal string -> Epsilon
* Minimal length -> 0
* **(0 + 1 -> 1)** states are needed to start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc46156e-5c37-45ac-9cb2-bf71599dc39e)

* Epsilon is accepted, only a's coming, only b's coming, a's followed by b's are coming, b's followed by a's are also coming which we don't want.
* So we need a **new state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/869732af-40c2-4a64-9e1b-5598148edf8c)

* **S2** means we have already seen **b**.
* After **b** if we see **a**, then **no hope** of going back to **final state**. We are going to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2035e7fd-3637-4e8c-8be4-f8e6060769de)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a109d058-4599-43b3-9f04-6cb7c3fb9368)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2eda6a7f-ba83-48d0-a663-1f9612b53c27)

* **DFA** with **more than '1' final state** has **more power** compared to the **DFA** with only **'1' final sate** because the **DFA** with **more than '1' final state** is **accepting more people**.

* For a particular langugae, we have a **DFA** with **more than '1' final state**, can we convert it into an equivalent **DFA** with **exactly '1' final state**? 

> Sometimes maybe possible, not everytime.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6bd398be-36d1-4fa7-903e-cae832ccafee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89572cf1-b41d-4991-8cef-ffe793cea801)

* After b's, we don't see a's.
* It is a trap.
* (a ^ *) * (b ^ *)
* (a ^ *) -> Min. a's allowed is **zero(0)**.
* (b ^ *) -> Min. b's allowed is **zero(0)**.
* Star(*) -> It means that inside we can repeat any no. of times. To whom we kept **Star( * )**, we can repeat them any no. of times.
* (a ^ m) * (b ^ n) -> Concatenation.
* **m** no. of **a**, *followed by*, **n** no. of **b** -> **Followed by** means -> Concatenation

* **m** no. of **a** OR **n** no. of **b** -> **Plus(+)**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/86d1f041-b709-4ff0-8c7c-b1c0206c1186)

* Minimum one **a** needed, min, one **b** needed and min. one **c** needed.
* (a ^ +) -> Inside **minimum** we have to take **one time**. **Epsilon** is not there.
* (b ^ +) -> Inside **minimum** we have to take **one time**. **Epsilon** is not there.
* (c ^ +) -> Inside **minimum** we have to take **one time**. **Epsilon** is not there.
* Minimal string -> abc
* Minimal string length -> 3
* **3 + 1 -> 4** states needed to start the **automata**.
* **S4** means we have already seen **a, b and c**.
* After **c** any no. of **c's** are allowed.
* After first **c** we don't see any **a's or b's**.
* **S3** indicate first **b** over.
* **S2** indicate first **a** over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/02583265-e50d-4f57-8823-331491b44259)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb670cfd-5757-4f83-a4c8-59d33e267758)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecb699b2-1658-4840-9ecf-a13532910476)

* At **S1**, **hope** is there.
* [**IMPORTANT**]
* **Dead state** property -> It is one of the non-final state from which we cannot reach **final state**.
* **Non-final state** -> It is a state from where there is some hope of reaching the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4f6fe0b-724e-4fc5-bcf1-659d522bdc90)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/658ab590-293e-4618-bd90-6719db35a432)

* Regular Expression -> (a ^ *) * (b ^ *) * (c ^ *).
* Minimal String -> Epsilon
* Minimal string length -> 0.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0edd643f-9ae1-454f-98b8-4817d0e82b2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb1e18a0-916b-407b-8829-1d831381665b)

* Only a's, only b's, only c's, a's followed by b's, b's followed by c's, a's followed by c's, a's followed by b's followed by c's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/304b0907-9880-4024-b55d-74c72181c8e4)

* [**IMPORTANT**]
* According to language every **valid string** is covered -> NFA -> Every **valid thing** should be **YES**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dedd875-152a-42e3-8827-5f4aad227af6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/888d947e-1f4c-4e2b-b95f-532a2ab07bb3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ba665973-b211-4c87-ad37-12fef94c126d)

* After **C's** we don't want to see **a's and b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/214b02a7-9246-49b5-ac3e-66e7a0aeed41)

* **S2** means **single a** came
* **S3** means **single a and single b** came.
* **a's** are generating alone in the **loop**.
* **b's** are also generating alone in the **loop**.
* **Inbalance** came.
* **All valids** are accepting and **invalids** are also accepting.
* It is like **(a ^ m) * (b ^ n)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/818cde68-894a-401a-9aa4-9584cdafbdef)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/870f9e6f-c251-4979-b2ee-e894ed1fa2aa)

* It is not **NFA** as well.
* NFA -> It means that only **valids** should be **accepted**. **One invalid** cannot be **accept/accepted**.
* **Comparison** is there so **finite automata(FA)** not possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbbe44ad-35b0-4415-9242-1144e81a26c3)

* **NFA** there means **DFA** also there.
* We got to know **DFA** not possible, we will say **NFA** not possible as well.
* For every **NFA**, **DFA** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1622afc-8685-4e6b-929c-a03b8f02f034)

* If we remove **dead state** then this is **NFA**.
* It is only accepting **valids** and not accepting any **invalids** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2dcd4e5e-7ebd-4808-8709-4468f37fc90f)

* If we remove **dead state** then this is **NFA**.
* Every **valid** thing, it is **accepting**. **One invalid** also not accepting.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfeac0c1-d231-4ab6-a471-ef1d087cb588)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f00044c-9e27-4c01-aa79-2583e60af947)

* If **comparison** is there then **NFA** not possible.
* One invalid also cannot accept.
* This is **NFA**.
* This is **not NFA** for the given language.
* It is accepting more. It is accepting **invalid**.
* At the end of the day, it should satisfy **language**.
* **Invalid** cannot accept.
* **DFA** -> Every invalid should be **reject/rejected**.
* Why constructing **NFA**, every value should be **accepted** and **one invalid** cannot be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1f534df-2540-4bed-a920-0163e4997630)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5b09448-4eb9-4e7a-92c6-c2a15646138b)

* **NFA** -> All values should be **accepted**, **one invalid** also cannot accept. [**IMPORTANT**]
* **DFA** -> All values should be **accepted**, **all invalids** should be **rejected**. [**IMPORTANT**]
* Either **NFA** not **DFA** will **accept invalid**. **None or No one** will **accept invalid**.
* In Both(NFA and DFA) of them, **invalid** are **not allowed**.
* No machine will accept **invalid**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56782923-6f3c-4ff2-9a42-c301764c9178)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b93a833d-ba2b-44fa-b1fa-a1e1f81dbd5f)

* Comparison is there, **finite automata(FA)** fails.
* Both, **NFA and DFA** will accept **only valid**.
* No machine, neither **NFA or DFA** will **accept one invalid** also.
* Every machine will **accept valid** only. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff009035-31ad-4f33-b8fc-8304b1014e97)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c6fe4a7d-06b2-4e58-b23c-035e274bf86c)

* So, the given language is **non-regular**.
* **NFA** will talk about only **valid** thing.
* Both **NFA and DFA** having **same** power as they are accepting the same language only.
* Whatever **NFA** can do, **DFA** also can do.
* **NFA** is easier because in **NFA** we do no care about the **invalid** thing. One **invalid** we cannot accept in **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e1964c7-aacc-4445-96fa-efd21825575b)

* It is because **invalid things** are also **accepting**.
* Every valid thing **accepted** but **invalid** things also **accepted** that's why it **failed**.
* **No comparisons** in the earlier **examples**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa4a13a5-1281-4ee4-a1f7-e0369c85bb66)

* In **DFA**, every **invalid** thing goes to **rejected** physically. We will write also. We **show** in the diagram.
* In **NFA**, we do not show the **invalids** in the diagram because **by default** the **invalids** will go to **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92b221bd-676a-4b61-910f-86a9c413f726)

* No comparison.
* So, **NFA and DFA** are possible.
* So, it is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d26b2a5e-eb67-4821-8ad5-c90f3a6a2a92)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9caaa586-0274-45b5-a806-6b9e8976ac0d)

* Now, **comparison** is there.
* So, **finite automata** is not possible.
* It is a **non-regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaaffdee-397c-45f4-ad2b-12a37d58d9c1)

* Without **comparison**, we cannot say that **'m' not equals to 'n'**.
* Without **comparison**, we cannot say that both are **not equal**.
* So, **comparison** is there.
* So, **finite automata** is not possible.
* It is a **non-regular language**.
* Without comparing, we cannot say that they are **not equal**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80f59d8e-be90-43a3-b27e-8b47b1f61980)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea4ef90b-105a-4e96-a2f4-7737232abe82)

* For **equal**, we have to do **comparison**.
* For **not equal** also, we have to do **comparison**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4d6c5c2-938d-4f36-83b3-0638b6602fb8)

* Again, **comparison** is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30a27082-3787-4978-afbc-2c85da60caf4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53241fec-4d8b-4d8c-a3ac-c0da8c077972)

* Again, **comparison** is there.
* Similar/same to the **above problem**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7616262-6bf0-49dd-a7e6-864e56a7dcf3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d895d8b9-3ab7-4ca6-a8ec-f2555532f9e3)

* **comparison** is not there.
* So, **finite automata** is possible.
* So, it is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cac6efad-96a6-4671-af1a-744b8ad7dd0b)

* **(m + n = 10)** it is a **finite** language.
* If we add, no. of **a's** and no. of **b's**, it doesn't go more than **10**. It is **exactly '10'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ddee4b9-0ed3-4d8f-b15b-24fc7fff80df)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d8e803d-89c0-4d51-8da3-6bafde8aaab4)

* Every state will remember something.
* Finite things we can remember.
* Even though **comparisons** are there, **finite** things we can remember.
* Finite automata saying that it has finite capability of remembering as it has **finite** states.
* In the above language, there are only **11 strings** available.
* So, it is a **finite language**.
* Every **finite language** is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32d6940a-5579-4325-b092-c0d6df06ee8e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c021bf28-0a4d-46a8-8868-631c8fcc2cb0)

* [**IMPORTANT**]
* **Finite language** is a **regular language** because **finite automata** can handle any **finite language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08928fba-2f9b-4baf-ba16-99263c13c2e9)

* NFA.
* m = a
* n = b

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9281d1b-2bf2-40a1-93b0-a780598b4c35)

* NFA.
* For **DFA** just do the **dead states** for the **rejected** ones.
* **Finite automata and stack**, both can **remember**.
* **Finite automata** can remember **finite things only** as it has **finite** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/769bd7c9-dc0d-4603-b37d-d99592eae8e5)

* (m + n = 5) -> It is **finite**.
* **Not finite** -> Where numbers are not visible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/acd3644c-1b2e-41b5-bc23-8b7f5c6d49ce)

* Infinite possibilities are there.
* Looks like **finite** but it is **infinite**.
* Many  possibilities are there.
* **Comparison** is there. That's the **problem**.
* If **Comparison** is not there, then we don't care if it is **finite or infinite**.
* If we want to say some language is a **regular language** then **finite automata** should be **available**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a293cd3f-70fb-4e59-bfa6-6a9c1314326d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57c62721-9eec-4980-ad8d-37fa599de635)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/617e26a8-5a9a-441c-8c80-3446e7f2b23a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/672e7b30-cb51-434d-bf91-1c8d5449d27a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/45cf2020-3ec6-40bf-988f-3342871c0f2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1fae7f1-da13-4c21-8d70-474026946217)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb9d6dee-7e45-4b3e-b28a-6c30bdc960b3)

* **Comparison** is there but it is a **finite language**.
* So it is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2666ef5b-8575-4cbd-a3c5-99035119bc5c)

* **Finite automata** can do **finite comparisons**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6def9f98-bf3f-48a1-ba5a-e27e8db99945)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4d9d71e-635a-4bfa-bb36-864c7d595366)

* Every state can **remember and compare** something. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab05f81c-7785-43c7-92c7-4c0d8dca1769)

* It is remembering **more things** but remembering **finite things**.
* Many **comparisons** are there and still **finite automata** is **possible** because the language is a **finite language**. [**IMPORTANT**]

* **Infinite language** and **comparison** is also there, **finite automata** cannot handle.
* So it is **not possible**.
* With the help of **finite states**, we cannot do **infinite comparisons**, it is **not possible**.
* So all are **non-regular** languages.
* **Infinite language** and **comparison** is also there, so **infinite comparisons** we have to do, which is not possible with **finite automata** as there are **finite states** only. So, **not possible**.

* **Infinite language** but **no comparisons**, **finite language** can do this. [**IMPORTANT**]

### Algorithm [**IMPORTANT**]

* Language(L) is **regular** language or not.
* FA -> Finite Automata.
* RL -> Regular Language.
* NRL -> Not Regular Language.

* **Comparison** will come in the picture when we have **more than one(1) alphabet**.
* When **comparison** is there then there is no concept of **AP or GP** series.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9206fe5c-2db0-4e31-b589-b49ecef9853f)

* [**IMPORTANT**]

1) 'L' is **finite** -> FA -> RL
2) 'L' is **infinite**:-

  * Single Alphabet:-
       * Check for **AP series** -> FA -> RL
       * If not **AP series** -> FA not possible -> NRL.
  * More than **one(1)** alphabet:-

     a) Comparison there -> FA not possible -> NRL
     b) No comparison there -> FA -> RL.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97055bf0-a597-4505-af62-9d64cc8ea2fb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f3bfbb6-6be8-4100-bb23-9c4fde645587)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76069993-44d5-483a-b79b-a7f3dc4347b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e30c3008-a682-4143-ab49-6a22ddc4140e)

* [**IMPORTANT**]
* Practice it.
* Use **common sense(CS)**.
* GP series and Finite language -> Regular language
* Comparison but Finite language -> Regular language
* Some language is **regular language** then **finite automata** should be **possible** otherwise the **language** is not a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7bfb4914-ddcf-478f-af67-f04af42edcad)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6ccc2cc-620a-44f8-a95a-3fb014f90b4a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a25e4d6f-d57d-439f-9462-b3a3bc00ec3a)

## dfa-construction-vi (10) [7th Sept 2023]

* L = {Set of all strings of a's and b's where in every string 3rd symbol from left hand side(LHS) is 'a'}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dddfb63-7fe7-4807-b1d3-bbd302a55ebd)

* Minimal string length -> 3
* **3 + 1 -> 4** states needed to start the automata.
* 3rd symbol should be **a**.
* 1st and 2nd symbol maybe **a or b**.
* In **S4** means that **3rd symbol** is already over. Afterwards anything can come, no problem.
* If 3rd symbol is **b** then there is **no hope** of reaching the **final state**.
* Because in the future we cannot change the **3rd symbol**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcad1345-1b6c-4611-84f1-c945475ab931)

* Condition is from **starting** only.
* Left hand side means **starting** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea135670-f86e-4330-9a4c-521121be6051)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62030706-ac44-4326-8de6-d137a8bdfdec)

* DFA.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1365ce4-0888-44c4-9740-2c9b642b636e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/412836e3-4511-445c-a711-583e2f51db59)

* 3rd from **LHS** is **a** -> 3 + 1= 4 states -> 4 + 1 = 5 states -> '1' is a **dead state**.
* 100th from **LHS** is **a** -> 100 + 1= 101 states -> 101 + 1 = 102 states -> '1' is a **dead state**.
* nth from **LHS** is **a** -> (n + 1) states -> (n + 1) + 1 = (n + 2) states -> '1' is a **dead state**.
* Sigma = {a,b}
* Regular Expression -> (sigma ^ 2) * a * (sigma ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ab37c5e-1cce-46b8-90b0-8b46935bf15e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9814f400-32e5-48c3-9bf2-5e9790bac961)

* L = {Set of all strings of a's and b's where in every string 2ns symbol from right hand side(RHS) is 'a'}
* Sigma = {a,b}
* Regular Expression -> (sigma ^ *) * a * (sigma ^ 1)
* Minimal String -> aa, ab
* Minimal length string -> 2
* In the **two length** also either **aa** or **ab** should come.
* Ending symbol should be either **aa** or **ab**.
* **2 + 1 -> 3** states are needed to start the automata.
* Start from **S3** state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a473e214-9f1c-4675-913a-d59bfe381570)

* From **final state(S3)** count. First symbol can be **anything** and second symbol is **a**.
* Here, **ending** matters.
* In **S3** means that we are getting **aa**, which is **ending with 'a'**.
* In **S4** means that we are getting **ab**, which is **ending with 'b'**.
* In **S2** means that **ending with 'a'** is over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09dd4c9e-9bae-4572-8306-de4d8e76e927)

* The condition is from **ending**, so **no dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc36b738-c0cd-4516-b693-eb49c39c041c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32e79ff1-6339-4adb-af71-426efd6e1075)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09a314ac-295a-4e0b-8eb9-a148a5b493b5)

* [**IMPORTANT**]
* L = {3rd symbol from RHS is 'a'}
* Last 3-symbols target.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57f079df-ce13-4e05-9ad2-da982ed98260)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1a3cd69-db32-4ea9-befe-9d43630fa4ef)

* From ending, we have to take care of all **two length strings**.
* For **two length strings**, from **ending** possible combinations are **four(4)**. **4 states** take.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b403357b-c51f-482b-8bf0-f6d5c594af1d)

* We want **aa or ab** but **ba** came, that is not my **goal**. **Ending** should be either **aa** or **ab**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dd65795-3224-40f7-912b-8d2e2a28e910)

* Hope is there.
* **Second symbol from RHS** -> Ending **two symbols** matter, so there are **four(4)** possibilities. So **four** states are there.
* **Third symbol from RHS** -> Ending **three symbols** matter, so there are **eight(8)** possibilities. So **eight** states are there.
* Drawing diagram is difficult but **no. of states** counting is **easy**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/27e0183f-e49c-4966-8873-3643bd009a72)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/caacf41a-186c-439a-acb3-bae04d183557)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2331e504-fe38-4cfc-96c2-9078f5acd1bf)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d8a1f0b-016a-49c5-acf3-5bfd8ac7a133)

* Who is **useless** make him the **starting** state.
* Who is **usefull** make them the **final** states.
* Second symbol from **RHS** is **a**.
* from **RHS** means from **final state**. [**IMPORTANT**]
* From **final state**, **First symbol** is **a or b**, **second symbol** should be **a**. 3rd or 4th symbol is **anything**.
* **anything** means we can write **self loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cdf2e48-ea57-4eaf-874a-e2afea6a6fa2)

* NFA.
* As it is **NFA**, one invalid also we cannot **accept**.
* By default they are **rejected**.
* Valid things are **aa or ab** as the **last two symbols**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c90aa66-fd69-48ce-b060-c5ff98819497)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/016dd8e6-a14f-45cd-9e14-a012b4adb4a3)

* Minimal length -> 3
* Minimal length string -> abb, aaa, aba, aab
* **3 + 1 -> 4** states needed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3289ba68-8fa9-410c-a4ee-392ae027f88f)

* NFA.
* While constructing **NFA**, **every valid thing** we have to **accept**.
* One invalid should not be accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0f9702fb-e2aa-40a7-9bb1-322e76a610e3)

* [**IMPORTANT**]
* Every valid -> **YES**
* Every invalid -> **NO**

* From RHS, 2 symbol is 'a' for **DFA** -> 2 ^ 2 -> 4 states.
* From RHS, 2 symbol is 'a' for **NFA** -> 2 + 1 -> 3 states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e72bf4a-2f40-4c93-98fa-cadfc4138bb8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2eb45e51-8c42-4900-b603-d1cc1525cb4d)

* Starting is **S1**
* Final is **S3**.

## NFA to DFA conversion

* **S1S2** is **one state** name in **DFA**.
* Take the **Starting state** and apply the symbol **a and b**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a8deae1-473e-40ad-8b45-c2c14b3d1f54)

* After completion of **a and b** in **S1**, we got a **new state** which is **S1S2**. So, go to the **new state**.
* Don't see the **NFA** states**.
* After completion of **a and b** in **S1**, if any **new states** came then take.
* If **no new states** came then **S1S2** also didn't came.
* Stop there only.
* If any **new state** then only proceed.
* If **no new states** then stop it.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3be6c69e-555e-457b-bef3-da4df1e0877a)

* While doing the **transitions** see the **NFA**.
* From **NFA** only, **DFA** is coming.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a3a9ac6-4a6e-4a06-9508-10f188434823)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/593ebb6b-21fd-4e2d-8005-b5a17224344d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2f08351-1eba-45fc-80a7-e23afbb100ac)

* If any new states came, then only continue.
* Two new states came.
* **S3** on 'a' is **nothing** which means **leave it**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11819480-5246-42e2-b4e2-1d27f10a981d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f04ffbb4-e113-46b2-a7fe-126919f7c3c4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc3c2699-976a-4965-a7a6-fd411d1ec340)

* DFA
* In the original **NFA**, who is the **final state**?

> **S3**.

* In the equivalent **DFA**, wherever we see **S3** in the states, make them **final states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/baa07fa3-f0d5-442f-9248-140ad047aebb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a49f3032-be77-4bed-90cf-44d1d7f055c7)

* Final State added.
* No new states, that's why stopped.
* 3 states are there in the given **NFA**.
* For the **3 states**, **8** subsets are possible. That is **subset construction method**. So, **8 states** are required.
* We managed in **4 states**.
* This is better than **subset construction method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/45e55208-d954-4c22-987a-af806e1852ed)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a429a99f-360a-4c3d-b9bb-ecd0f761905f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0599446-73e8-4b19-8fd0-91689096d9cc)

* Exactly

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a08f31c2-1620-4909-8aa8-e33defa0f6d8)

* **NFA TO DFA** convertion:- [**IMPORTANT**]

1) Take NFA start state.
2) Apply all symbols from **sigma** one by one.
3) For every **new state** came continue **second step or step-2**.
4) While applying transitions see **NFA** everytime.  [**IMPORTANT**]
5) **NFA final state** wherever present in **DFA** make them as **final state**.
6) If **no new state** then **stop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3edc5e34-f678-44d9-985b-e57681a456d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b5555ff-0931-4e14-8669-731b4b3c42be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c722e7b7-7aef-4c8b-a367-f6c85d67eddc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65904662-5a56-4e63-a3bb-1bf52c13dd28)

* Convert the **NFA** into **DFA**
* HW. [Tomorrow class]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18bbbbdb-f403-4fac-979a-58e179a6cd4b)

* 3rd symbol from **left hand side(LHS)** is **a**
* Constructing **NFA**.
* Minimal length -> 3
* Minimal string -> aaa, bba, aba, baa
* **First symbol** is anything
* **Second symbol** is anything
* **Third symbol** is **a**
* **Fourth and fifth symbol** are anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/526af6f5-e98e-4aa4-ba24-a2b14e0c5909)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56869811-d21a-4e70-8188-0bc4b93d955f)

* **NFA**
* Trap not required in **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23eb4d86-8eab-4918-8647-abfdfd93cf89)

* 3rd symbol from left -> 3 + 1 -> 4 states
* nth symbol from left -> n + 1 -> (n + 1) states

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a321cb7-331a-4591-b0ad-e5b8737b42f2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da77980e-a091-402f-832b-c918a1767634)

* The **conversion** is from **NFA** to **DFA** and not **minimal DFA**.
* If we are lucky we will get **minimal DFA** in the **conversion**.
* No gurantee.
* If not **minimal DFA** then there is a **minimization algo** also there.
* We can apply **minimization algo** to check if the **DFA** is **minimal or not**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de3a2f0e-2f65-44b4-8a6a-1b922e68b337)

* DFA.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ee96c75-f6c0-4512-926f-b019493b8462)

* NFA

## NFA to DFA conversion

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/009bd868-f7e1-46cb-9458-e6d9a6ab36ee)

* In **NFA** going to multiple states are allowed.
* In **DFA** going to multiple states is not allowed.
* **S2** on **b** is not going anywhere, **nothing**.
* In case of **NFA**, not going anywhere is **allowed**.
* In case of **DFA**, **we have to go**. If at all not going anywhere then go to **dead state**. No other way.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d59302e-067f-483a-89c0-43463cf61e44)

* If **nothing** there then only **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b5bbb1d-7fdf-43f0-8810-fefc86e1b6df)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b49b0b94-da37-4ad4-8f02-5ef81d36b988)

* Wherever **S2** make **final state** in **DFA** because **S2** is the **final state** in **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05bae09b-571b-43c0-88ea-29294a434b69)

* [**IMPORTANT**]
* NFA's set of states(Q) = {S1, S2}.
* If **Q** contains **2 states** then **2 ^ Q -> 2 ^ 2 = 4** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/691f1fb8-2fff-4286-8f90-8a9762a7a7fc)

* For the given **NFA** when we are constructing **DFA**, in the **worst case** all of the **subsets** can come.
* This is the **worst case** that can happen.
* If **NFA** contain **2 states** then the **equivalent DFA** contain **2 ^ 2 -> 4** states.
* This is the **maximum** thing that can happen.
* In the **Worst case**, all of the **subsets** came in **DFA** construction. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3f90e176-fb50-4340-b47b-db3607e0677f)

* If **NFA** contains **n-states** then equivalent **DFA** contains **2 ^ n** states. This is the **maximum**. More than this is **not possible**. [**IMPORTAN**]
* Sometimes **less** also may come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57cdc401-6595-40a0-97b4-8245caf0eb29)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08880fd2-3819-4d5a-b54a-9084c6955f6f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c5ac59c-35cf-4a96-b243-2244ba73e06e)

* Best case. [Not required]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c441b5d-040a-451c-bbaa-b069e72fe927)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9815dbae-7609-498a-9dea-c1fb42f9fc2a)

## dfa-construction-vii (11) [8th Sept 2023]

### HW

* In **NFA to DFA** conversion, **DFA** is gurantee. It is not guranteed that **minimal DFA** will come.
* NFA contains **4 states** so **max no. of states** in **equivalent DFA** will be **2 ^ 4 = 16** states, in the **worst case**.
* **Worst case**, all **subsets** will come.
* If we are **lucky** then only **one state** will come.
* If **NFA** contains **n** states then the **equivalent DFA** contains, **min. of one(1) state** and **max. of (2 ^ n) states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6dae6231-eac2-41b0-b57a-5a578e7419eb)

* 1 <= (DFA states) <= 2 ^ n.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b70e02ea-b539-46c7-b4d5-fb3de5b4c139)

* If we are lucky, we will get **8 states** which we got in the **minimal DFA**.
* If we are unlucky then we will get **2 ^ 4 = 16 states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f0e179a-4d4f-4371-b520-ce151b750bca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c79cf767-edf3-45ee-bede-cf7373d00c63)

* NFA to DFA construction.
* We got **4 final states**.
* **Conversion algorithms** are for understanding.
* Not for GATE exam.
* Because we are anyways not getting guranteed **minimal DFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/61b5c434-5fba-4931-b416-3a2da44c4df0)

* We luckly got **minimal DFA**.
* We apply **minimization algo** on a **DFA** with **n** states and the **equivalent DFA** has **less than or equal to 'n'** states.
* **Equivalent DFA** <= **n**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/510792fe-d6cd-4f40-8f2d-90de64289a5f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3179acc-5ce0-4f65-ad00-6f925d9c22de)

* L = {Set of all strings of a's and b's where in every string no. of a's divisible by 4}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92ef3514-2406-44da-b94f-593f3535a48e)

* We care about **only a's**.
* We don't care about the length of the string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2cf41793-0790-4e24-bd64-798baf723dc0)

* If it was the **length of the string divisible by '4'**.
* Then it would have been an **AP series**.
* Common differenece -> 4
* With **4** one cycle is also possible.
* There is a **4-length** cycle.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac6f808a-b20a-4e5e-af07-4dbd52f9642f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c824c207-cb8d-4bbd-9900-97e4b0527885)

* No. of a's should be divisible by **4**.
* Our goal is **only a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8290b4df-5060-4d28-b1d4-d416f2c22a0e)

* **b's** is not our problem.
* They may come or may not come.
* **Changing state** means compulsory **b** should come.
* **Loops** means it may or may not come. It is no gurantee.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f937e80d-d016-4899-b596-e82eb7e38490)

* **b's** may come or may not come.
* They may come at any time.
* Just count **a's only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/27cbdea6-227a-4c85-a72c-8665836ddd12)

* When we divide a number by **4** then we will get **0,1,2 and 3** as the **remainders**.
* For **every remainder** there is **one state**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ddf39da-dbba-4389-bbed-e297d6339e92)

* Whichever matters, give that in the **transition line**.
* When **only a's** matter, do like this.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a48d5fa-40b2-4210-87c6-4384fc2a5dc9)

* When **length** matters, do like this.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b13a6146-205b-4ee1-96be-286a602fd4b1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d00f91f4-adfb-4869-aa6d-bc8ff4f55d33)

* L = { All strings of a's and b's where in every string no. of a's are divisible by 2 and no. of b's divisible by 2}
* Try solving **individually**.
* **AND** operator.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fca73671-6100-4204-90f5-639ad733ab25)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f7bfd47-d019-4f69-b830-7adcf959c1da)

* In **P1** our goal is **no. of a's** and not **b's**. That's why **self loop** for **b's**.
* As **divisible by 2**, so we get **0 and 1** as the **remainders**, so only **two states** are required for the **two remainders**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75066ce9-5525-4db6-8d74-70435a1d9494)

* In **P1** our goal is **no. of b's** and not **a's**. That's why **self loop** for **a's**.
* As **divisible by 3**, so we get **0, 1 and 2** as the **remainders**, so only **three states** are required for the **three remainders**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/888e92d8-1138-48f3-aef7-1d57454d3d18)

* Satisfying **P1** diagram means that at the end of the string, we have to come to **S1**.
* Satisfying **P2** diagram means that at the end of the string, we have to come to **S3**.
* Two sets are there, one set has **two elements** and the other set has **three elements**. If we do **cartesian product**, we will get **2 * 3 -> 6** elements.
* Just do **cartesian product** of states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9a66c69b-2f81-4bae-af0d-5c55320a0ba5)

* Where both **initial states** from the **previous diagrams(P1 and P2)** are there make that the **initial state** of the final diagram.
* S13 -> S1 * S3
* S1 on 'a' -> S2
* S3 on 'a' S3
* S13 -> S2 * S3 -> S23.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/007eee50-7bb5-48bc-a061-be702b6cc2ad)

* Yes. **Common initial State**.
* Using the **existing states** and creating **new states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1fcb1c50-84d8-47f3-84e7-3dcc86cdaf74)

* Satisfying both the **final states** from the previous diagrams(P1 and P2) and they are coming **together/both** in a state in the combined diagram is the **final state** of the **new diagram**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7feebfd8-fcb9-4e0b-a28c-7c2c581f86de)

* AND -> S13 -> S1 and S3
* OR -> S13 -> Either satisfying first one or satisfying the second one -> Either one is **final state** then that state is a **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e378386-1bc8-4f8e-97c3-8a9c95aa98a8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/48930288-bdbb-4acc-8aa2-9694cd91029a)

* For **OR** operator.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/deb229cc-c890-4a45-9374-3e0c4f95ffb4)

* **Minus(-)** means that **first one** should **satisfy** but not the **second one**.
* **First final state** should be there but not the **second final state**.
* Satisfy here means **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a60149ba-2a7a-4d13-9cc3-5849abdc1cde)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b89b7392-1c5e-4d7d-8237-bcd9228a5ecf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8992c77e-feb1-49b3-895f-813d12c624dd)

* Final States combinations [**IMPORTANT**]
* If it is **AND** operator then make **S13** as the **final state**.
* If it is **OR** operator then make **S13, S14, S15, S23** as the **final state**.
* If it is **minus(-)** operator then make **S14, S15** as the **final states**.
* The **operators** are present in the question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c030d4ea-380f-47c8-a846-9007faac5f6c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fdec66f2-63d7-43c9-aacb-5f9f63aee99c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ff7c1b3-df46-40ff-87b8-513a1d77bb08)

* **a's and b's** can come at any place.
* Anyone can start
* We have to check how many **a's and b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb145211-0002-45bb-9ecd-325eacf82238)

* L = {All strings of a's and b's where every string contains no. of a's divisible by 4 and no. of b's divisible by 2}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c919b192-12ef-4f62-ba9f-2ad2c2c80e39)

* Conditions are **different**.
* No. of states for a's is **4**
* No. of states for b's is **2**.
* By doing **cartesian product** of the two we got **2 * 4 = 8** states.
* We cannot do any **minimization**.
* **Different** conditions means we cannot do **minimization**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaf8a388-c343-4a29-af83-e6c636ea268a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40f087e4-01f3-4721-b5ac-988c5e4ff79e)

* Simply find **individually** and multiply. [**IMPORTANT**]
* **Same** for all of the **three operators**. Only the **final states** are **different/change**, rest everything is **same**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e94e1be1-990b-477c-95df-fe903a13771f)

* **P1** is on **a's**.
* **P2** is on **b's**.
* Whatever states we get by doing **Cartesian product** that is the **no. of states**, we cannot do any **minimization**.
* As **P1** is on **a's** and **P2** is on **b's**, we cannot do any **minimization** also. This is the **only way**.
* Condition are on **different people**, we cannot do any **minimization**.

* If the condition are on **same people** or the conditions are **same** then we can do **minimization** or **minimization** is possible. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be762d05-055c-46c8-8a05-170a6ece320d)

* L = {Set of all string of a's and b's where no. of a's divisible by 4 **or** no. of a's divisible by 2}
* **4 * 2 -> 8** states is **correct** but it may not be **minimum**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2930da1-4305-4b53-84ca-9e1b86162469)

* It is **AP series** and **common difference** is **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfeda8f2-8ee4-4cac-bfa5-1625bb0942ca)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84dd6bed-41ff-486c-93e0-2695cacdbf98)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a6666de-b77d-43ae-9a24-e58c96ab49d4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b8990bb6-28c9-4ed3-9316-dd14a18c14a8)

* It is an **AP series** with **common difference** of **4**.
* If the operator was **AND** operator.
* Worst case answer is **8**
* The best answer is **4**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/47f917f2-df4a-4873-b915-adb782b29285)

* We are unable to find out any series.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a50beed6-fb6d-4ccf-abf0-772b614342b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9997cf84-009a-4d95-8d26-dae10fec7531)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87899fd8-2c2a-436b-a72f-cfa37a9f6f02)

* How do we know it is the worst case?

> Continue the series until the **max. no. of states** and after that if we are unable to find out the **common difference** then **max. no. of states**, **6** here is the **answer**.

* By default answer is **6**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0166fb39-c8d5-4d66-96c3-6bc2b82bfedc)

* **Same** thing repeating that why we have kept a **loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1ceb0052-6499-40aa-9abe-0d6f8d14c43e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/200183d4-f087-4c3e-9052-ec8ea3aa1665)

* We don't care about **b's** that's why we keeping **self-loop** of **b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0849bf40-44f0-425e-8faf-05d1f7d98042)

* We couldn't find any **series/patterns** in the numbers, that's why we have to use the **max. no. of states** possible that is **21** states.
* OR operator.
* **3 * 7 -> 21** states is the **max. no. of states** possible. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5db4f6f3-708e-4808-aab6-991d8ee33184)

* AP series came.
* Common difference is **21**.
* We tried to **decrease** the no. of states from **21** but we are unable to.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11f4de15-1cb2-4495-b88e-edec475c89c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/20308f76-85f8-49cc-acbb-a1506ea9f5e1)

* So states are **21** only.
* **AND, OR** or any operator, it doesn't matter. Everytime **multiply** then **conditions** on the **different symbol**.
* If **conditions** are **different** then blindly **multiply**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75ffa6f7-b404-4b7d-b5d5-af371cfaf25b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3ee235c-a309-46f9-871d-ff9e0d618b0e)

* [**IMPORTANT**]
* If the **symbols(a's)** are **same** then there is a **difference** between the results of the **operators**.
* AND -> 4 states
* OR -> 2 states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df8446f3-a26c-4471-98cb-3b7e09e8aab7)

* We are getting **same no. of states** which is **6** for both **AND, OR** operators even though the **symbols(a's)** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/211812cd-eb16-4a9c-a14a-e063da0f417e)

* [**IMPORTANT**]

* How to solve bigger problems?

1) Solve individually first
2) Blindly multiply which is the **upper bound**.
3) **Upper bound** is the only answer when we have **different symbols**. **Operators** do not matter.
4) Game will start with **same symbol**. **Operators** matter now.

* Product automata will give **boundary** which is the **upper bound**.

## doubt-clearing-session (12) [8th Sept 2023]

* L = {Set of all strings of 0's and 1's where each string contain atmost one pair of '11' or atmost one pair of '00'}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2319b886-0174-4455-9c18-e85579b04f45)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0989bc65-e930-445c-a7e0-f0b38e84c097)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/832cfd0b-ae5f-4c9d-90e2-d859b2426974)

* Yes, because of **OR** operator.
* In **OR**, either one is ok, both are also ok. Both are **not satisfied** then **OR** is not ok.
* In **Exclusive OR**, either one is satisfied then ok but **both** is not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/921ce2f1-fa30-4422-82ce-dabff5ff33f4)

* 1100 -> Each pair of 11 or 00 are there. OK. Both are there.
* 000 -> Two pairs of '00' are there. So not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50937f74-bc93-465e-92a9-5ed6738da0ec)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec604122-f1ea-4f02-829f-8774fcca73d0)

* AND -> Both are allowed.
* **OR** is giving some ambiguity.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1dcfedc-c830-44dc-8987-cee0b0d08e95)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13d36ef5-f31e-437e-8e3a-260790946f46)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29a7087d-c29a-41bc-be32-a90302c1503a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f2c2ff9-50f2-4b82-a17e-145294df22df)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f8db5ef6-8879-48fb-ad99-b2bc69262c41)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/059039c2-c23f-4a09-89a2-50f728c636ce)

* Not only we have to remember **00 or 11**, we have to remember **0011**.
* **AND** operator -> Both should satisfy.
* Consecutive or Non-consecutive. Doesn't matter. It will work for **both**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d584fdd-c8a1-4c0e-a95f-3ab2df0b1464)

* In this diagram, we were only remembering **00 or 11** only.
* Let's remember **0011 or 1100**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/651711db-b117-497b-9167-0a8afec71cae)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99729181-9b64-4e8f-bae6-0b20165c4d4e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bff5207d-a14a-4b39-8004-66563ce7226b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08ef6f15-f903-4421-bf52-2df9ada2a20b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99a4363b-a058-4102-b7c0-099201fe15f0)

* We have **10** states.
* What is the above DFA doing? [Example questions]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b306cc5e-8724-44cf-9b41-0cb07770f389)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1db9a5fd-4a1b-43de-8079-651700d0844b)

* Another Type of question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f7f2629-740a-4bae-9a49-6e78b904f1bb)

* How many DFA's possible with 2-states(X and y) where 'x' is initial state over the alphabet {0,1}?

> All possible **DFA** we have to take care.

* We have **4 choses** for the **final state**, **x and y** both are final, **x** is final, **y** is final, **no one** is final.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e0f3700c-93a8-4f2e-ae43-0503ee894636)

* Is **No one** is final possible?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7728ff86-b389-4d34-9f0e-6a6f2c34987c)

* This is a finite automata.
* As there is **no final state**, so nothing to **accept** or **no one** is **accepted**.
* L = Phi
* L = {} -> Empty Language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1607b68b-434e-46bd-beec-ae0d2a44fc83)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/156ae588-7fc0-4d2e-ad11-e57a9046a357)

* Only **epsilon** is **accepted**.
* Everyone going outside, no one coming back to **final state**.
* The language accepted by the automata is **not empty** but the string is **empty**.
* The language accepting **empty string** but the language is not empty.
* Language not empty but accepted string is **epsilon** which is a **empty string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ebfc634-faaf-4e37-8a50-e95f3a4b8edf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b91f3fc7-e9ca-4944-bbb7-0160ef5252ca)

* DFA -> We can only go to **x or y**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d197e2ad-9bec-4812-b36e-be75f2321ff0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7250ced8-b875-4f08-bdf7-c04fd3b78656)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/67ee12a0-9315-4f85-acda-c9c7517e5093)

* In total **64** DFAs.
* In all of the **64** DFAs, who is **initial**?

> **No discussion** of **initial** came because we have **only one choice(x)**.

* If only one choice, what discussion will come.
* **Initial state** is **fixed** so only **one choice**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c301e40-be68-4ff9-a080-cfdeb92e4de1)

* Everywhere **2 choices**.
* Without considering **final states**, we have **2 ^ 4 = 16** DFAs.
* **X** on **0,1** we have **4 choices**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bdf9211f-aca0-4dee-bfad-389675ee3a3b)

* **Y** on **0,1** we have **4 choices**.
* **X and Y** on **0,1** we have **4 * 4 = 16 choices**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cca5418f-003b-4f9b-a5b6-8c095318f26d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e4d5bae-10ed-4a6c-ae93-cbe12792396f)

* In all of them **x** is the **initial state**.
* **X** on **0,1** we have **4 ways**.
* **Y** on **0,1** we have **4 ways**.
* **X and Y** on **0,1** we have **4 * 4 = 16 possibilities**.
* One work is done **m-ways** and another work is done **n-ways**, both can be done at a time in **m * n** ways. [**IMPORTANT**]
* **X** on **0,1** we have **4 ways**. **Y** on **0,1** we have **4 ways**. Both(X and Y) can be done at a time in **4 * 4 -> 16** ways.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0bcdf4a1-e3a9-41cb-91a7-dfecadc8f262)

* **X** is changing but **Y** is not changing.
* **Y** on **0,1** we have **4 ways**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ebd544d5-926f-4470-9f14-2461bbf2d00b)

* Everyone is a **DFA**.
* We have **16** diagrams logically.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65a6a9f3-e0b0-45b3-870f-7ac4c79ec5a8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6ed4018-b8e4-42c1-8019-8b0e1c82b73e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e8e2a92-c330-4814-a0a1-dce8e75b3db1)

* We want **DFAs** only.
* In all of the **DFAs**, **x** is the **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3843db23-b812-4769-8e75-b1298737e464)

* We have **16 DFAs**.
* Take all of the **16 DFAs** and in all of the **DFAs**, make all of the states as **final**.
* **Zero(0)** states as **final state** will accept **empty languages**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1305d47-a10c-48f2-a08b-d2e3dba52bd3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1bfdf80-bc98-421a-b822-4f129f8bbb9d)

* If **initial state** is not mentioned.
* **X** maybe **intial** so **64 DFA** and **Y** maybe **intial** so **64 DFA**. So in **total**, **64 + 64 = 128** DFAs.
* We cannot take **two states** as **initial**.
* If **no state** as **initial state** then we will not know from where to start.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ffb8bde-3a80-4512-a08f-427a9cb5b3c6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8cb1888c-c374-47cc-bea2-0ff82a89f882)

* Without considering **final states**, we have **2 ^ 4 = 16** DFAs.
* By considering **final states**, we have **2 ^ 4 * 2 ^ 2 -> 2 ^ 6 -> 64** DFAs.
* Go like this, if we want **answers**.

* In the question, if it was added that, **and only one state is final** then:-
* We want only **32** DFAs.
* We only want one state as **final**, either **x** or **y**.

* In the question, if it was added that, **and every state has final** then:-
* We want only **16** DFAs.
* We only want where both the states are final.

* In the question, if it was added that, **and no final state** then:-
* We want only **16** DFAs.
* We only want where zero(0) states are final.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/100f1b5b-263b-4602-876f-12e176dc4fea)

* In the question, if it was added that, **and atleast one final** then:-
* We want only **16 + 32 -> 48** DFAs.
* We only want where **2 states** are final and we want where **either one of the states** are final.
* Atleast one final state -> Atleast one state ok and both are also ok -> One final state is ok, two final states is also ok.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9e7fa1b-6f83-4455-9f00-696a3280b5bd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4a73c20-84fe-443e-aafc-9be84172f95c)

* In the question, if it was added that, **and atmost one final** then:-
* We want only **16 + 32 -> 48** DFAs.
* We only want where **zero(0) states or either of the states** as final.
* Either one state or zero state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a461b54b-4434-4b79-b82f-347fde229847)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93e387aa-73bc-4f43-90d9-1c5dd3817916)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fde4ca2-4a9f-49e2-a27e-dd8202a309e7)

* **X** is **initial**.
* In every diagram **X** is **initial**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5e47634-dd22-4ae9-bc48-3ee27f2fd974)

* How **64** came?

> **X** on **0,1** we have **4 ways**.

> **Y** on **0,1** we have **4 ways**.

* So, **4 * 4 -> 16 ways**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2850c2b8-a91a-4209-8d9a-74d64e8498ec)

* Totally we have **64 DFAs**.


![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/547340a4-5269-4a9c-af6e-6bc1fa7869b0)

* How many possible DFA's are there with 3-states x,y and z where 'x' is initial and sigma = {0, 1}
* From **final** state we got **8** possibilities. From **000 to 111**.
* **000** -> No one is final
* **111** -> All are final.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3caea32-8bf4-4de7-99a5-5a82a8f12868)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f134b849-8de7-4a93-af68-1700f2269c4d)

* [**IMPORTANT**]
* We have **5832** DFAs.
* **DFAs** without final is **3 ^ 6**.
* **DFAs** with all final is **3 ^ 6**.
* **DFAs** with one state as final is **3 * (3 ^ 6) -> 3 * 7**.

## regular-expression-i (13) [9th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38ed71a8-bc74-4101-82a9-9623ccb65af6)

* How many DFA's possible with 2-states(x,y) where **x** is starting state, sigma= {0,1}.
* Total DFAs is **64**.
* No final state is **16**
* All final state is **16**.
* Any final state is **16 + 32 -> 48**. Which is **Atleast one final state**.
* **Atmost one final state** -> **16 + 32 -> 48** -> Maximum one final state.
* Exactly one final is **32**. Maybe **x** or maybe **y**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3382b195-a479-4526-b8ff-c6f1465ef940)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f066d7a-131c-4ff6-8c32-345b32d4231c)

* How many DFA's possible with 2-states(x,y) where **x** is starting state, sigma= {0,1} and accepts empty language.
* On **X**, **0,1** we have **4 ways**.
* Both can go to *X**, both to **Y**, **0** to **X** and **1** to **Y** and **0** to **Y** and **1** to **X**.
* On **Y**, **0,1** we have **4 ways**.
* For **X and Y**, we have **4 * 4 -> 16** ways.
* Totally we have **16** DFAs without thinking about **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2de8402e-2f03-46b6-b7a0-107b16708ec2)

* **16 DFAs** without final state.
* As **no final state**, they will accept only **phi**. They will **accept** nothing.
* **16 DFAs** without final state and they are accepting **empty languages**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f214599e-f53f-47b7-b996-ec591093ba12)

* **Y** is **final**.
* **Y** is ready to accept anything but we have to start from **start state(X)**.
* **X** is saying, I don't go outside.
* Like this, we will have **4 more** DFAs.
* Even though **final state** still it will accept **empty language** if we cannot reach **final state** because from the **initial state**, we cannot reach the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70faaf83-61b3-4384-b6de-db45995b9997)

* **4 DFAs** with **Y** as the **final state**, accepting **empty language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4b50706-902b-4cfa-aa7f-1afbdcf805b5)

* We don't want to accept anything.
* When we make **X** as **final** then it cannot accept empty language. It is accepting **epsilon** which we don't want. We want to accept empty language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74a0af88-fd10-4b35-857d-9006d8bde7d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/738c44dc-394e-46f0-872e-9f23ed7c49d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1424b06-f5eb-471a-988c-01be2b5b950c)

* **4 diagrams**.
* **Final state** is there but from **starting state** we cannot reach **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e314b526-9d04-485b-ba79-8589ce8078a1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cf012ae-4ccf-4816-b0f4-d410228295b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb1d70c6-71a0-4d13-afad-3103ef8bde53)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d4f547a-af1a-4100-9800-750e1de33e9c)

* We have **16 DFAs** when **X and Y** both are **final**.
* There is **no chance** of accepting an **empty language**.
* We will get **epsilon** atleast**.
* In these **16 DFAs** we are addressing every person and we are **accepting** every person as well.
* **X** and **Y** both are **final**. We go anywhere that is **final** only.
* They are accepting **everything**.
* They are **(sigma ^ * )**.
* They are called as **universal or complete language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f554b595-c95d-40e0-b204-4da24e08e779)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c888f82-f3c3-45f1-8a06-1885ac58ef6f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8ae40b9-72ac-4d73-8844-e35c630e10c9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1115375d-ba64-47e2-94e3-6680e3a77eb7)

* Every string is **YES** only.
* In the given **DFA(above)**, if every state is **final state** then it will **accept** everything?

> **It is correct**.

* As there is **no non-final** states, so everything is **YES**. There is no **NOs**. [**IMPORTANT**]
* **(sigma ^ * )** means **all strings** -> Universal or complete language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/382523aa-00ec-4c5f-8383-9e6544572d56)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7382d50-df96-4a7e-b1bf-1523b2c2b3ac)

* In the given **DFA**, if every state is **final state** then it will **accept** (sigma ^ * )?

> **Correct**.

* In the given **NFA**, if every state is **final state** then it will **accept** everything?

> **We cannot say**. We cannot give any gurantee. For somethings there is **no response**. For some strings there is **no response** in the machine.

* It is **maybe**.
* If **maybe** not there then choose **no** as one time fail is **fail only**.
* Every **DFA** is **NFA**.
* Accepting everything is **DFA**.
* **NFA** where everything is **final**, sometimes it will **accept** everything. **YES**. When the **NFA** is a **DFA**.
* There exists an **NFA** where **every state** is **final** and **accepting everything**, **right or wrong**?

> **True**.

* There exists an **NFA**.
* Question is not saying **every NFA**. It is saying **one NFA**.
* If **every NFA** then it is **False**.

* Every **NFA** where **all states** are **final** and **accepting everything**, **right or wrong**?

> We cannot given gurantee. **False**.

* There exists one NFA -> **True**.

* There are some **NFAs** where **every state** is **final** but not **accepting everything**, **right or wrong**?

> **True**.

* There are some **NFAs** where **every state** is **final** and **accepting everything**, **right or wrong**?

> **True**.

* The **NFA** maybe **DFA** who knows.
* A special type of **NFA** is called as **DFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/00232048-2b33-430c-948a-1cfaeedbdd60)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4738cdc6-1990-47d0-a4c1-dac477dcde74)

* They are accepting everything. No way.
* They are saying **YES** to everything.

* We have **16** more DFAs where the **X** is the **final state.
* As **X** is already the **initial state** and we are making **X** as the **final state**.
* So we will not get **empty languages** as we are accepting **epsilon** as the min. string here.
* We cannot get any diagram where among the 16 DFAs they accept **empty language**. They **min accept epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9a1efc4-10ab-42e9-a0b3-e73d3c909e61)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5ae3dff-6a4e-4c04-90e5-f31f819314ea)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c03e021-faf6-4978-9b3b-171f5195d9ec)

* **16 DFAs** where **Y** as the **final state**, **Y** will accept something. Block at **X** itself.
* **16 DFAs** where **Y** as the **final state**, we want to **accept empty language**. **X** will not come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/085e1c95-48b0-413b-9f59-4f2bcd6ffb17)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc15faad-860e-4fe3-bb9e-e36554ab4f0e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ba97f64-fc73-42b5-b8f0-4d49b67f3520)

* So we have **16 + 4 -> 20 states**, where **empty languages** are **accepted**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c9a5ef8-23c3-4b51-b74d-4d1bbdfdb720)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b7ff0dd1-2769-4919-aafc-5e1dade8fd65)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10a5724a-ffcc-4dca-be71-fb696f0b90ef)

* How many DFA's possible with 2-states(X, Y) where **X** is initial, sigma = {0, 1} and accepts everything(sigma ^ * )?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82a515a7-39d0-4c6a-8651-cff1fe0274a2)

* In the **16 DFAs** where **Y** is the **final state** means that **X** is not the **final state**, so **epsilon** is got. We can't accept everything.
* So the **16 DFAs** where **Y** is the **final state** are **gone**.
* For the **16 DFAs** where there is **no final states**, they are **not accepting anything anyways**. So they are **gone** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0cb5e75e-4424-4cec-9124-d6db5b97aa12)

* **16 DFAs** are there where **X** is the **final state**. So **min. epsilon** is **accepted**.
* **X** contains **4 choices** and **Y** contains **4 choices** as well.
* So, **4 * 4 -> 16 choices**.
* **X** is **initial as well as final** state.
* We want to accept **everything**.
* So, we will put **self loop** on **X** and **X** will not go **outside**.
* If **X** goes **outside** then something is **rejected**.
* Actually on **X**, **0,1** we have **4 ways**
* Now, **one way** only as **X** is not going **outside**.
* Now on **X**, **0,1** we have **1 way**
* Now on **Y**, **0,1** we have **4 ways**
* So, **1 * 4 -> 4** more ways.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5243ccb6-963b-45d5-a576-e625936df688)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0885110-ed95-4a10-8aec-30900c904aa9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d63b05ec-192d-45b1-8bbe-32f636f085de)

* From the **16 DAFs** where **X** is the **final state**, we have **4 more DFAs** which **accept everything**.
* **X** is **initial as well as final** state also, so **epsilon** but we want to **accept everything**.
* So on **X** only keep the **self loop**.
* **X** only we can select **himself(X)**. **X** don't go **outside**.
* So **16 + 4 -> 20** DFAs.
* The no. of DFAs where **everything** is **accepted** is **20** DFAs.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98a24b5e-6f04-470f-abfb-fb2a63fb6d8f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80c3b5c4-aa82-470b-b511-dc3afad22457)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a1d5fa9-30bc-4846-9a54-45c8a5999ce0)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5131cc4c-886a-4a20-bbef-e88933ee8009)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a23e35c8-9b4a-43f5-a2f6-d50f97927958)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/46b5861a-012f-49fd-9255-eb9919414fe5)

* **20 DFAs** are there we are **accepting nothing** or accepting **empty languages**.
* **Complement** these **20 DFAs** by interchanging the **final to non-final state** and the **non-final to final state** and we will get **DFAs** which will **accept everything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/adf5fb3a-914f-4989-af76-64ddb94f6e11)

* Yes ofcourse that's the reason.
* **Complementation** of **nothing** is **everything**.
* (sigma ^ *) - phi -> (sigma ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/447abbad-9556-4465-9099-5a858a0ca5ee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6684c852-b011-4846-92b1-0a10167d0d98)

* Give Regular expression(RE)
* L = {All strings of a's and b's where starting and ending symbols same}
* Two possibilities are there.
* One is **a** at the starting and ending.
* One is **b** at the starting and ending.
* (a + b) ^ * -> Everything is possible. It may come or may not come.
* Whatever we say should come from either **first regular expression** or from **second regular expression**.
* Because of the above reason, we are using **plus(+) operator**.
* **Plur or OR operator** means we are going to take **either one**.
* (a + b) means **two people** are there either **a** or **b**.
* (a . b) means **one person**. We cannot take **either one**. It is **one string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2008e295-16b5-44e3-a77d-a7034efe8b0c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad3d6bf1-1537-4b44-8f07-1fed0b3e6f1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/33e432ba-6399-4a2c-a378-a279eb8b28a7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63404014-7997-493e-938e-535abc3ff999)

* Dot, OR operator [**IMPORTANT**]
* **a or b** or **b or a**. Both are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c04f0ea9-3148-4cec-bba2-811198632290)

* It is **first one or second one**.
* Some string will come from the **first one** and some strings will come from the **second one**.
* There are **two models**.
* Take either **first or second**. Don't take **common**.
* We cannot take **both**. That's the meaning of **OR** operator.
* We cannot get **1 lakh a's and 1 lakh b's**.
* We can get only **1 lakh a's**.
* We can get only **1 lakh b's**.
* **OR** operator -> Either first or second, we cannot take **both**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6edac5f3-49c3-4ad8-b1c6-55dc63f6179d)

* **Concatenation** means **compulsory**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff91895c-200c-42fa-81ad-2ee36e30134b)

* The strings should come from the **first or the second or the third or fourth of fifth** regular expression.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3072cee5-d17f-4c20-b8c4-87d9b97a8cf9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/52027c45-e574-445f-8dab-6546a7ab00ee)

* **Epsilon** is included because when we have only **Epsilon** then the **starting and ending** symbol are **same**.
* Regular expression having these operators -> Star(*) or kleen closure, Plus(+) or Union, Dot(.) or concatenation [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a1b21fb-fcdd-4a9b-8bd5-d71ea71c42d3)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/703e66bf-b82d-47b8-acd4-7a727db64a7b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fcdd3a9-4a59-4cf7-89f9-8d2030481399)

* Given RE, L = {Set of all strings of a's and b's where each string contain 'abb' as substring}
* Minimal String -> abb
* **abb** can be anywhere in the string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e38f94e8-1b41-402a-b978-3221cec366f5)

* Starts with **abb** and also no string starts with **b**.
* They are not mentioned in the question.
* So wrong regular expression.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44e5b178-fa52-494f-a1ec-b608268fa872)

* We are saying that **ending with 'abb'**.
* Huge blunder.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f08a0c43-912c-4016-8b02-12fadf6703e6)

* According to the language, **abb** should come as **substring**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e691210f-4670-44d5-9002-7ee63ca7b3a4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19d39add-635e-47d3-ac44-d2a511572749)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5be71d2-cda9-4e43-bf1e-f804f023b8c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eddc38d8-20b0-4b8a-8e26-86be93b6c9b6)

* We want **abb**.
* **abb** should be there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f9b72f4-7bea-4898-82db-6789ed493d76)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc4e0ec6-9840-48a0-b60d-537292cd8a6a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3a2b9ba-ea64-4f64-b805-06817cbce9d2)

* Possible options to the questions.
* Option **2** is **correct**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39ae39cf-95e5-4bfb-b2ad-159cbab90867)

* Give Regular expression(GRE)
* L = {Set of all min. 3-length strings over 0,1}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be187d94-9ff1-47c1-8c58-50e274788ecf)

* Here we want **min. 3-length string**.
* After **3-length** anything can come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f77fc1e4-4a05-4db6-8bac-2dd9a4d72377)

* All of the **three** are **correct** but **first two** are **better** answers.
* In the **Last one**, we are wasting **star(*)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e2531fd-580b-4b01-9d71-08608e9059c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4df5e34-da95-4e10-9413-627f6af8a006)

* Non-sense MSQ(Multiple Select Question).
* In this, **starting symbol doesn't matter** and **ending symbol** doesn't matter.
* Only **length** matters. Exactly.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b967105c-f183-4781-bb1b-b8e47c35da13)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4dbdf93-447d-48a0-b303-8e60e5c385ac)

* All are **correct**.
* We have to select **all** of them.
* **One** we cannot say.

## regular-expression-ii(14) [9th Sept 2023]

* Atmost 3-length string

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e84deca-2475-4123-97a9-e5c59d9aec40)

* Atmost 3 means **max is 3**.
* Atmost 3-length string means we can have **0, 1, 2 and 3** length string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbcddab8-c787-4099-9bd7-d079f040133f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b7ab952-a5d3-4360-8361-31a9c414f283)

* Minimal regular expression(RE) is **not unuqie**.
* Minimal DFA is **unique**.
* regular expression(RE) will talk about **valid** things only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88cf9785-0012-4a96-ba8e-ef5558b5cb34)

* Exactly 3-length string
* (0 + 1) ^ 3 -> We are going inside exactly 3-times.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd0d8a7b-93a8-415d-a97c-be25198b83fd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f3480e3-01dd-498f-99f3-99c9b7a63035)

* L = {Set of all even length strings over the alphaber {0,1}}.
* **Epsilon** is **zero(0)** length.
* (0 + 1) ^ 2 -> Two length string is coming.
* ((0 + 1) ^ 2) * -> Everytime, **two length** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d12ae6d5-d161-41a9-89ce-5ac5fdd96b3b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa8ee8d5-458a-4313-a7a6-eb67eb189069)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9ff0143-b3d7-4935-a51f-158a7c75bc7d)

* Odd length
* Even length + 1 -> Odd length
* ((((0 + 1) ^ 2) * ) * (0 + 1))

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b501d563-48b5-409a-892b-bb6c12ba1e3e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a28befdd-a289-4e56-892a-f2a8a698b948)

* [**IMPORTANT**]

L = {Give a regular expression of all a's and b's where the length of every string is **divisible by 5**}.
* Length of the string is divisible by 5.
* ((a + b) ^ 5) *

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/14034eee-c2fe-4bf7-bc15-d70c1f3c50b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ccf9d7a3-f47b-4594-89c6-f64835850c9f)

* Even means that the number is **divisible by 2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d5eb8e8-f730-495b-a4f5-6a52e63a6321) 

* L = {Set of all string of 0's and 1's where in every string 2-consequtive 1's are not allowed}.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/948093d3-191a-424f-9089-3d366442c792)

* Because of whole star(*), we can go inside **any no. of times**.
* ((0 + 10) ^ *) * (1 + E).
* E -> Epsilon.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e89172b5-ecb6-4de3-aea2-bb6f7e6c18b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/639219be-c163-4999-af77-34768302caa9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cdf51bc2-5fd5-4d16-9b0c-6747932d03dc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff28ce25-3e20-4117-a5d7-9115c446e4f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1f5e7b6-91cc-48ac-9a7c-c0bcc7982393)

* [**IMPORTANT**]
* L = {Set of all strings of all 0's and 1's where in every string consequtive 0's and 1's are not allowed}.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf3fb83a-d519-4e64-9c67-e433712ac913)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b6103ac-dd55-4179-b62a-f02173ae6822)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30f31b68-faa1-41d2-8490-8b3920393bcd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f16986fe-ac64-4bcf-8551-cb75bc8e1528)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de0fb0e6-8a42-44da-9889-d706a2984e64)

* [(0 + E) * (10) * (1 + E).
* [**IMPORTANT**]

* L = {All strings of 0's and 1's where in every string 2-consequtive 1's are not allowed and starting with '1'}.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18dac704-f06f-4fae-8af1-6aa6e7ec81b2)

* Minimal String -> 1,10, 100000, 10001
* Minimal length -> 1

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4029d21-c03b-41f4-b61c-51f44c7805f5)

* (10) ^ * -> It means that 0's and 1's side by side are not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce0264cc-73e0-4a3c-9a4e-2707eda8b1f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71fd8b95-2fb8-40b2-a1b9-d804a26d09af)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b42dba98-ac56-47e4-af65-c8776ce33a36)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee781aea-864e-488a-9dd5-83857ca23f8e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff216d0a-a7b4-4d5c-a66a-6a77def99e4c)

* Everything possible.
* Try covering the **majority** then try adding the **minorities** that are **left out**.
* [**IMPORTANT**]

* Epsilon ^ * -> Epsilon possible.
* Because of **star(*)** we can go inside any no. of times.
* Phi ^ * -> Epsilon.
* We may not go inside also then **Epsilon** comes.
* If we go inside **one time** then **phi** will come.
* Phi + Epsilon -> Epsilon only [Nothing + One thing -> One thing]
* Phi -> Nothing
* Epsilon -> One thing.
* We don't go inside that's why **epsilon** came.
* (a + Epsilon) -> They are **two different** people. Either **a** or **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50fe1681-29e3-4d0a-9a57-2869e2adba39)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5cd6aa59-2fd3-4a27-8319-3c6075080a3b)

* [**IMPORTANT**]
* Zero(0) multiplied by anything is Zero(0) only.
* Epsilon -> Zero(0) length string or empty string [Zero(0) is length].
* Phi -> Empty language [Zero(0) strings there, not length is zero(0). **Zero(0)** is the no. of strings].
* As **phi** is a **language**, we cannot say it's length.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/952d3e1e-253c-433d-91f2-2d8eb06140ab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1af17f7e-1173-414d-9fed-54a6f69cabbe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df9522dc-2099-483c-addd-d5e2e33b1417)

* [**IMPORTANT**]
* (Phi ^ * ) -> because of **star(*)**, we can go inside any no. of times. Inside, don't go also then **epsilon** will come.
* (Phi ^ + ) -> because of **plus(+)**, we have to go inside.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/208d2426-238a-4ad0-96a0-a05abcf91195)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f619ecc9-8199-4df4-9088-49c657393edd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e4dfa6f-32d1-48dd-b4fa-d4379f3cea0e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32f147b1-f71a-4452-8b3c-2aac7d08f9e4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7226210-90c7-4e77-9619-13f933f85de2)

* [**IMPORTANT**]
* Phi + Epsilon -> Epsilon
* Length of **epsilon** is **0**. No. of string is **1**.
* L = {Epsilon}
* Cardanality of 'L' or |L| = 1 ['L' contains no. of strings]
* Length of **epsilon** or |epsilon| is **0**

* L = {Phi}
* Cardanality of 'L' or |L| = 0 ['L' contains no. of strings]
* Length of **Phi** or |Phi| is **non existent**. There is no question of **length**, as there is **no string**.
* There is no question of **length** as string is **not there**. **N0** string is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17923429-d3cf-4c05-bd97-cdc0687aeb9c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a65d4e6-646b-4f9b-9898-afd270387c5d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40b84e88-8be4-46a6-a07f-47e682031e01)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7987f28c-bfaf-4cd6-8e46-d5086320b48a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cff1369a-04c2-43e2-b649-3544a444cff2)

* [**IMPORTANT**]
* GRE, L = {Set of all strings of a's and b's where each string contain exactly 2-a's}
* Minimal length -> 2
* Minimal string -> aa
* **b's** can come at any place.
* Inbetween can also come. Question didn't mention about **consequitive a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f4151179-19a8-47de-9127-72015cd5021c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8cff01b8-28d0-43ed-9c16-dcf11cc0e85d)

* Correct answer. [**IMPORTANT**]

* ((b ^ * ) * a * (b ^ * ) * a) -> If the **last (b ^ * )** is not present/not written then we can say that the string is always **ending with 'a'**.
* (a * (b ^ * ) * a * (b ^ * )) -> If the **first (b ^ * )** is not present/not written then we can say that the string is always **starting with 'a'**.
* **Possible options to the question**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/117a86ae-5a8b-4040-b8a7-521039f51282)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d900b77-6b7c-4eff-bbe8-b25672709753)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c711258-6d94-46b0-ba59-a5bd0abf83be)

* L = {Atmost 2-a's}
* **a's** may come or may not come.
* If **a's** come then they can come for **2-times** only.
* ((b ^ * ) * (a + epsilon) * (b ^ * ) * (a + epsilon) * (b ^ * ))

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ae1308b-9b4b-4eeb-8acf-ee6f6e486c43)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c6beb69b-45fe-4b5e-ab38-119842c6fa5d)

* Minimal string -> Epsilon.
* Max of **2-a's** only possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66685807-d6cd-4d0a-9430-a335ec8f2987)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf593466-69bb-4a6f-a730-9c150f94d68d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fe09511-f862-45c2-8f01-15c0497a34e7)

* L = {Atleast 2-a's}
* Minimal string -> aa
* **2-a's** are compulsory then anything can come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6f51673-b52f-4231-810b-0b48db3abccd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/46a848fc-7905-4edf-be8b-c4deddf0977c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d1ae94e-b854-410d-847c-d5153b160a9e)

* All **four** are **correct**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/170c2c04-53c7-41b9-b62f-5f67ad561d3d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7442a82-585c-4868-ab5f-8f44a4f7e346)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/410380d6-0532-4ccf-8a89-f07ed5f87126)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8256389-cdb1-4bb6-a4e7-e0fa64b01696)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea3be7a3-833e-4335-a5d7-912d3a75d1f6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c64e095-cd79-466b-b329-9685c24535d9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7570d838-e01f-4981-aeb1-4f302796af72)

## regular-expression-iii (15) [10th Sept 2023]

* GRE,  L = {All strings of a's and b's including epsilon}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40a170f3-c7a9-438a-9cbc-45bb1814dafe)

* In **(a + b) ^ * )**, we can get **epsilon**.
* If we want to get **epsilon** then don't go **inside** at all.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ee0263d-3913-4692-91b5-29e1ff156900)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2a77132-5969-4436-8699-861dc5068351)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1068ab10-63fd-4d42-bf88-6269c49cce60)

* If we want to get **epsilon** then don't go **inside** at all.
* If we want **10 a's** then just go inside **once** and then take **(a ^ * )**. It will give **10 a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6466f787-2d3b-456c-a3e3-513a3c71ce29)

* Both mean the **same** thing.
* We wasted **one star(*)** in the **second one**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16f88583-cbca-4cff-9b7a-be3e5502b94e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1bdd847f-bee6-4baa-aab2-66eac421a0f9)

* Meaning wise all are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4df34106-84e7-4f50-8bfb-ceefc2373fcc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78abb4d-3934-4ca4-9008-e2dc349175d7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8d28756-ff7b-4e20-87f1-cb681ae1b538)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd42f3f5-96c2-40b3-9039-b44a0b322506)

* Epsilon is possible, a's possible, b's possible, a's followed by b's possible, b's followed by a's possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a0c3e45-1f83-4d01-9794-9ee4733ffaa8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9fdd81c5-8852-4607-947a-90ea3624cad5)

* Which one **even**?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad06799b-0837-4059-9c9d-be39d9b53fa9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f0e1b2c-6534-4849-bf42-eba03749c6ed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83e2d960-5494-4f24-b3a7-256291138648)

1) (0 *) -> All there.
2) ((00) ^ *) -> Even no. of zeroes.
3) (((00) ^ *) * 0) -> Odd no. of zeroes.
4) (((00) ^ *) * (0  + epsilon)) -> Even followed by one odd and sometime, even followed by **zero(0)**, it is **even**.

* So, **1 and 4** are **even**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2133bd2a-941d-4c91-8f84-5f0db897eea3)

* ((0 ^ *) * (1 * (0 ^ *)) ^ *) -> Only 0's is possible, Only 1's is possible, 0's followed by 1's possible, 1's followed by 0's possible.
* It is like **((0 + 1) ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a04a0efd-4d5b-4086-bdb8-66e442499a75)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23d99b1c-fd4e-4eac-993a-9e38af7cddfe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ddc9962-6186-4f95-becb-b87d6b70d211)

* These **four** are **same**.
* Always ending with **b**, why not ending with **a**.
* Always ending with **a**, why not ending with **b**.
* Always starting with **a**, why not start with **b**.
* Always starting with **b**, why not start with **a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5294122-8cc3-46c8-b4e5-4cd32d3b039c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f855522d-b720-4595-839a-403474f31244)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3509f7c6-3817-4607-a5c0-a7904c620fe8)

* No problem
* Last **a** will be given by **(a ^ * )** outside.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/605f3b30-7eb6-4331-a546-7179be805d78)

* All **12** of them are **equal**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fcd48d57-6824-4d78-b604-479f3dfb44c9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/52697abe-d850-40d6-83c3-8b5e1b3ef1b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/90d41c02-87b7-4d07-b21b-eff7ce49d2de)

* L = {Set of all string over it's alphabet, {0,1,2} in which every **2** is immediately followed by exactly 2-0's and every **1** is immediately followed by **0 or 2**.
* Everyone is immediately followed by **zero(0)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f988dbf-cb2e-418c-904f-4f560cf9d70c)

* [**IMPORTANT**]
* Directly we cannot write **regular expression**. Directly we cannot construct **DFA**.
* We have to start with **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a5e231d-fa56-45bb-8dac-f959483a625f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dca33ec-bbcf-461c-af33-f87c9e9fa2e2)

## NFA Construction

* **NFA** will cover only valid things.
* When we are constructing an **NFA** for a given language(L) then we will try to cover everything in **L** only.
* **DFA** will cover everything in **(Sigma ^ * )**.
* **NFA** construction much easier than **DFA** construction because **NFA** will cover only string present in **L** but **DFA** will cover every string present in **(Sigma ^ * )**.
* **(Sigma ^ * )** -> (L U L') -> Valid and Invalid both.
* L' -> Complement of **L**.
* **L'** complement people will go to **non-final** state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c31411b-bf81-4312-a871-1f1a6415b7dc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34701ac8-969c-44f9-8b7f-e4c2fd1f7162)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6bca4dc8-1612-4e4e-94bf-bf236fe492d1)

* **NFA construction** will take care about **valid things**.
* **DFA construction** will take care of **everything**, valid, invalid both. 
* **DFA transition function(Delta)** -> Any state which is present in **Q** and applying any of the symbols that are present in **sigma**, we have to go to one of the states present in **Q**.
* **NFA transition function(Delta)** -> Any state which is present in **Q** and applying any of the symbols that are present in **sigma**, we have to go to **maximum** which is the **worst case** and it is the **Power set of 'Q', P(Q)**. Any combination can happen. This is the meaning of **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88c5e62e-7a45-4923-b518-e37307d043d7)

* **NFA** can go anywhere.
* **DFA** will go to **exactly one(1)**. 
* In **DFA**, **valid** is **yes** and **invalid** is **no**.
* In **NFA**, **valid** is **yes** and we don't talk about **invalids**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4c1be57-215b-4d7f-bea5-5be45c33a4fe)

* **NFA** having **choice**. It may not going anywhere but it may go to all also.
* **DFA** will go everytime **one(1)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d645e613-60b6-469d-b8ab-3e27a4edb55b)

* In the **transition line** of both **NFA and DFA**, the symbols that are present in **sigma** are allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/24dbcb93-8ad8-4a5c-91aa-db8fbfb73e2a)

* The **transition line** of **Epsilon-NFA**, any state that is present in **Q** and by applying any one of the symbols that are present in **sigma**, we will get **power set of Q, P(Q) or (2 ^ Q)**.
* Any **subset** we can go.
* Both are **same**, **P(Q) or (2 ^ Q)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16cc4bb6-8cf9-4806-9a41-599049a28efb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa416336-c693-4d55-aa3d-3b6feb51c4a1)

* As it is the **Epsilon-NFA**, on the **transition line** the symbols that are present in the **sigma** are **valid** and **epsilon** is also **valid**.
* On the **transition line**, we can give **epsilon** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2bdf6433-26fc-44cb-b899-9167bde8c482)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff32dc61-dc27-4180-973d-1b29fa404c41)

* This is allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c6f45349-50cb-407f-a402-5b4d0b7dad5f)

* **NFA** means both **epsilon free NFA** and **Epsilon-NFA** will come.
* **Finite automata** means **all**, we can take any.
* In **NFA** construction, do the required things only.
* Everything that is present in **L**, we have to **accept**. That is **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1f3b23e-5efa-408a-9fff-7d2aacdd61d7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e25a3763-3648-4638-a0c7-9b58565cceec)

* yes.
* Epsion, only a's, only b's, a's followed by b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34ef8255-9037-4990-91ac-781443bb257b)

* All valid things we have to cover. [**IMPORTANT**]
* Only a single invalid should be accepted. [**IMPORTANT**]
* **NFA** never contain **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ff7e7d8-1d85-41db-abe8-ad34e15065cd)

* Every **valid** should be **accepted**. [**IMPORTANT**]
* One **invalid** also we cannot **accept**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea1990a3-47d3-4b0d-a49f-3d08d5b8d59e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d527826-6ec7-4df1-983f-8beea178b4b1)

* First **a's** should come then **b's** should come.
* Whenever **order** matter then what we do is like **below**:- [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a759c03c-07ed-4e31-abc9-8826018eb2d5)

* **S1** will take care about **a's**.
* **S2** will take care about **b's**.
* We can put **epsilon** on the **transition line**.
* By reading **epsilon**, we can go to **final state**.
* **Epsilon** is **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d3a4153-7068-40e3-a979-a6163389e80f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/41d9fc89-b117-48c9-980a-8157387fa7e5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/debb0c6c-f4c5-4265-93fe-5bf8ab47e474)

* We can go from **one state** to **another state** without reading any symbols also. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/442e20f7-480b-48e5-8a04-71cacd2cce25)

* This is **Epsilon-NFA** construction.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f461555f-5afa-419e-a820-5c3ff940bf70)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88a9608c-383a-45fd-88f2-d0d600841c28)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42e96e82-4756-4bcc-ad5b-6ad36e194046)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d239709-687f-4e77-8a3c-57f5b6133228)

* Epsilon-NFA [**IMPORTANT**]

## doubt-clearing-session (16) [11th Sept 2023]

* C-NFA -> Construct NFA.
* L = {Set of all string of a's and b's where each string contain 'abb' as substring}
* Min length -> 3
* Min string -> abb
* Before and after 'abb' can be anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6966ae0e-5709-4bd2-b8a3-d74adc9cb37f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25b58886-1d17-4cf6-9fcf-cf2f834cbb13)

* NFA.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c441800-73e1-4da5-9d6b-4a6983cdfad7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/579cc605-0e96-473e-92ab-031fd32036b1)

* Epsilon-NFA.
* Minimal NFA not unique.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8dd943bf-a01e-44c9-bea7-1267f5ab5b6d)

* C-NFA
* L = {abb, baa}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1becf3f-5e7e-4c32-9221-58b1d2821cbf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53a2d26a-e0fa-4631-8863-1943443dfead)

* Power set of Q, P(Q) means **subsets**. All **subsets**, anything can happen.
* There is chance of going to **all** because one of the **subsets** is going to **all**.
* There is chance of going to **nothing** because one of the **subsets** is going to **empty set**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d0e85cf-da60-4612-8813-ba21e644e670)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c7c17b1-c27d-469f-ab6c-cfd12acade9e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81fbfbde-40a0-48df-9473-dabc812bb29d)

* Finite Automata(FA).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50a62eee-a075-4fa4-8417-047d8d12262f)

* **NFA** starting and ending symbol are different.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5675b626-0adf-4ba0-81a5-5747ca0c7609)

* Language matters.
* **Order** relation is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3c1f46d-af4e-4dab-b863-ba348fb6913f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89455f97-d44f-46c2-9695-98331b2564f3)

* If **order** important or something related to **order** then **Epsilon-NFA** comes to the **picture**.

## Epsilon-NFA to NFA conversion

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7488cfcc-a1fe-4286-b072-e6099232970f)

* This is **((0 ^ *) * (1 ^ *) * (2 ^ *))**.
* **((a ^ *) * (b ^ *) * (c ^ *))**.
* Any no of '0's' followed by any no of '1's' followed by any no of '2's'.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a439541-9d2f-44bf-adba-87bc47f9db4e)

* **Epsilon-NFA** having **3 states**.
* **Equivalent NFA** containing **3 states**.
* In **Epsilon-NFA**, **q2** is **final state**.
* In **Epsilon-NFA**, whoever is **final state** make that state **final state** in **Equivalent NFA** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/edeef8fb-7eb3-40b6-a121-c0119ebe6f3e)

* From **q0** by reading only **epsilon**, we can go to **final state**.
* Final states may **increase**. Sometimes may not **increase**.
* Either **same** or more will be there.
* **Initial state** is **same**.
* **No. of states** is **same**.
* **Final state** is **same** final state, plus, from any state by reading only epsilon if we can reach **final state** then make that state as **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99c8b52d-b4ec-4b21-a272-c0b247f75ec8)

* For doing **transition lines**, we have to see the **original diagram**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bee1026e-6162-4a48-a669-4c4a6294a41a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f35460e-26b8-4627-9461-ecaf809994c6)

* On **q0**, if we apply **0**, where can we go.
* 0 * epsilon * epsilon -> 0
* 0 * epsilon -> 0.
* We can read any **no. of epsilon**.
* **Zero(0)** should be there.
* **Zero(0)** followed by any no. of epsilon we can read.
* Before **Zero(0)** also any no. of epsilon we can use.
* We can take the **epsilon's help**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/560cf266-1b23-4035-92ed-e9026e856ede)

* On **q0**, if we apply **1**, where can we go.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c1850b8-799f-4cfd-a8ad-1d6fb9306432)

* On **q0**, if we apply **1**, we can go to **q1 and q2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2877b426-a179-4fad-ab4f-2ac93272b97e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d91dac25-5727-4ba8-926a-e5ef0a34a8a4)

* On **q0**, if we apply **2**, we can go to **q2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0380102c-22cd-4a63-80e4-ea3d6dc408cf)

* We cannot. Where is the **2**?
* **2** is not visible.
* On the **transition line**, **2** should there.
* We have to read **2**, we only read **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/94ea5b29-06ce-48a4-a7b5-4dffa9c90ad7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/03bb7b6b-97a7-4188-9237-c918f23ea64a)

* No one is going **before**.
* We are at **q1** and we want to apply **0** but no where **zero(0)** is visible. At **q1** no zero(0) and further also **no zero(0)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59f7db6e-3d9f-4f15-bf8f-761281a38b17)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8d92308-4165-4cea-915a-9cbcba8034b3)

* **q1** on **0**, no chance.
* In case of **NFA**, not going anywhere is possible.
* In **DFA**, not going anywhere is not possible. We have to go to **trap state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d192eb78-68ad-4243-bf58-1eaa794ddbb1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e22f89af-9c3d-47d5-aacd-a537668e0dc3)

* We are at **q1** now. At **q1** or **after q1**, anywhere **2** is visible, as we cannot go back. We can move in the **forward** direction. From which side we can go, that side any **2** visible? At **q1**, **2** is not visible but after **q1**, **2** is visible.
* We can go to that **2** with the help of **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/28c55491-4d9f-4b49-b9ba-86f2df9c2fb5)

* **q1** on **2** is **q2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fce86e5-b801-460f-9cdc-9c81a03ec18d)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/361450dc-c669-4c10-a782-a4481f70ceb4)

* We **ignored** it.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d6bdfde-fcd3-4181-9ef7-0aab0038b5de)

* We are at **q2**.
* On **q2** we want to apply **0**.
* On **q2**, **0** is not available.
* We cannot cannot go back. We can go in the **forward** direction and foward is not there. **Backward** we cannot go.
* Just neglect.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95b32fb9-6438-4602-a3c3-df5cd4046695)

* We are at **q2**.
* On **q2** we want to apply **1**.
* On **q2**, **1** is not available.
* We cannot go back also. Forward is not there.
* Just neglect.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2da56565-90e3-4f3e-ba92-050e22e5e5ae)

* We are at **q2**.
* On **q2** we want to apply **1**.
* On **q2**, **2** is available and we can go to **q2**.
* We cannot go back also. Forward is not there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95c30f6c-84e8-47ea-8c98-b76355b0bc24)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f26b049-b5f1-4849-bfde-7461773d36ee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f287e85-2022-4671-af02-37fc9f1f9168)

* [**IMPORTANT**]
* Major things is **transitions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/928812ce-61af-45b0-b916-00023812be38)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4fc94da-ce59-4800-a5d2-5578e0e7f3db)

* We can take **any combinations**.
* We can take **epsilon's help**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39074573-f773-4ae2-92b2-52d4ce7ac8f2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4921f76f-5a99-440d-ae2d-e5e871cb8c39)

* Minimal string -> Epsilon.
* Some many 0's are allowed.
* Some many 1's are allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e5a71b4-1b9c-46a6-9f2a-9e81c2359a2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc645e9b-1c84-4bf5-a389-e6e3f3b7175e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/af3f51b6-11df-4fff-9047-de8b0ef9d9f8)

* **q0** on **1**, we can go to **q2**.
* **S1** on **1**, we can go to **S2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b657b2f8-7fbf-4b20-aec0-0508bd92dd52)

* On **S1** on **1,2,3** we can go to **S3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ff0471b-312a-4898-895d-443ac4415480)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12f9d5fc-0882-48f9-9aa0-8bb1361631cb)

* Example.

* **STEPS**:-

1) Take every state.
2) Take same initial state.
3) Take same fianl state. Chance of **final state** may increase.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5a28f99-4433-4a94-837a-d2d64b077c59)

4) In the original diagram go to every state and we currently at **A** and by reading only **epsilon**, we can reach the **final state**. **YES**, Then **A** also is **final state**.

* We currently at **B** and by reading only **epsilon**, we can reach the **final state**. **YES**, Then **B** is also **final state**.
* We currently at **C** and by reading only **epsilon**, we can reach the **final state**. **NO**, Then **C** is not **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9c1a1c4-f67e-41a3-9313-3a40392a442e)

5) Now, do the **transitions** using **epsilon**.

* Free service  -> **epsilon**.
* Symbols in the **original diagram** -> {0,1}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/41cb1653-6daf-4531-87b7-140ca274602f)

* We are at **A**.
* Now see the **original diagram**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/73af1409-3a61-434e-9fda-2a1698fcff64)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f83bc74-6a22-440a-9c52-18544ec653c9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bee7147d-371b-4e63-b350-f360bde71c3f)

* From **A**, using **0** we can go to **A,B,D,C**.
* From **A**, using **1** we can go to **A,B,D**.
* We are at **A** and we want to go to **C**, **zero(0)** is **compulsory**. we cannot do with **1**. Not possible.
* For **A**, on **1**, we never go to **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d30c6c4-a222-495c-9ed6-44b4801d590f)

* We are at **D**.
* Now see the **original diagram**.
* We cannot do backward.
* From **D**, using **0** we can go to **D**.
* We cannot do backward.
* From **D**, using **1** we can go to **Phi**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ca85cdc7-b8b1-4956-901f-fab666aae608)

* We are at **B**.
* Now see the **original diagram**.
* We cannot do backward. We can go **down and right** and **not left** of **B**.
* From **B**, using **0** we can go to **C,D**.
* We cannot do backward. We can go **down and right** and **not left** of **B**.
* From **B**, using **1** we can go to **Phi**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/995e808d-47c8-48b0-ac7a-34669c23d8ef)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9ce448d-b3a6-4b7b-bcd6-7e15b8c66e9e)

* We are at **C** now.
* Now see the **original diagram**.
* If we want to go **outside** then we need **1**.
* From **C**, using **0** we can go to **phi**.
* We cannot do backward. We can go **down and right** and **not left** of **C**.
* From **C**, using **1** we can go to **B,D**.
* From **C**, using **1**, we went to **D** by **1 followed by 'epsilon'** which is **1 * epsilon -> 1** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a3a8e0e6-a68f-4dd4-b9f3-9e89706faa36)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/756df3d3-aa3d-477a-920c-3e8b747af2f4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a539323f-21b3-40ca-b671-9c629e5d8183)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f4e1383-fcbe-4cd4-8b58-bb28f5e48010)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1f8d376-1d2b-49b7-98d0-9fccdc72640b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecfb07c6-6149-42ec-a7f9-b2db15c77524)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/85c51903-b847-4a43-93cc-aea28c31b4ed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb6f3b08-2dae-436b-a70d-f8d35fb25741)

* Example
* States will be **same**.
* Automata can be represented in a **table** as well.

* We currently at **A** and by reading only **epsilon**, we can reach the **final state**. **NO**, Then **A** is not **final state**.
* We currently at **B** and by reading only **epsilon**, we can reach the **final state**. **NO**, Then **B** is not **final state**.
* We currently at **C** and by reading only **epsilon**, we can reach the **final state**. **NO**, Then **C** is not **final state**.
* We currently at **D** and by reading only **epsilon**, we can reach the **final state**. **NO**, Then **D** is not **final state**.
* So only **one final state** here, which is **E**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9d7c6c3-cd0b-4471-980f-9eba55d56eb0)

* Take whatever **final states** we have from the **orignal diagram** and see if we get more **final states** or not.
* From any state by reading only **epsilon** if we can go to final state then make that state as **final state**. [**IMPORTANT**]

* We are at **A**.
* Now see the **original diagram**.
* From **A**, using **0** we can go to **A,B,C,D,E**.
* From **A**, using **1** we can go to **D,E**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42e3cc39-3f0b-4d5b-b205-19f8ada5903c)

* We are at **B**.
* Now see the **original diagram**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **B**, using **0** we can go to **C**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **B**, using **1** we can go to **E**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b9c05be6-4b17-4ff5-a387-61f5ae4dfebd)

* We are at **C**.
* Now see the **original diagram**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **C**, using **0** we can go to **Phi**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **C**, using **1** we can go to **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f09a417f-4101-4ecf-b0d0-5d55e6ddf619)

* We are at **D**.
* Now see the **original diagram**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **D**, using **0** we can go to **E**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **D**, using **1** we can go to **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f287a15c-c71e-40ea-bdba-68b7b448f774)

* We are at **E**.
* Now see the **original diagram**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **E**, using **0** we can go to **Phi**.
* We cannot go back. If backwards edge there then go **backwards**.
* From **E**, using **1** we can go to **Phi**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/551d9012-18dc-4838-96da-66c11e21ff4f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/821603b4-92f5-4198-90e4-f9f9838b1683)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/73c63274-c7dc-4c27-97ee-ec648ef8bab4)

* In the **epsilon-NFA**, **q0** is the **initial**.
* From **q0** by reading **epsilon**, we can go to **q1,q2**.
* By reading **epsilon** wherever we can go from the **initial state(q0)**, make the total people as **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7c115c3-cbc1-4942-a8fc-243e52253051)

* From **q0** on **zero(0)**, we can go to **q0,q1,q2**. We can go to **all**.
* From **q0** on **zero(0)**, we can go **everywhere**.
* For **q1 and q2**, something will come.
* Overall **everything**.

* From **q0** on **one(1)**, we can go to **q1,q2**. 
* From **q1** on **one(1)**, we can go to **q1,q2**. 
* From **q2** on **one(1)**, we can go to **phi**.
* Overall we got **q1,q2**. 

* From **q0** on **2**, we can go to **q2**. 
* From **q1** on **2**, we can go to **q2**. 
* From **q2** on **2**, we can go to **q2**.
* Overall we got **q2**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1295abc4-80d9-47c4-8026-df801cf2a072)

* Yes, **new state(q1q2)** came.
* From **q1q2** on **zero(0)** which is **q1** on **zero(0)**, we got **phi**  and for  **q2** on **zero(0)**, we got **phi**.
* From **q1q2** on **zero(0)**, we got **nothing**.
* **Nothing** means we have to go to **trap or dead state**. 
* From **q1q2** on **one(1)** which is **q1** on **one(1)**, we got **q1q2**  and for  **q2** on **one(1)**, we got **phi**.
* From **q1q2** on **one(1)**, we got **q1q2**
* From **q1q2** on **2** which is **q1** on **2**, we got **q2**  and for  **q2** on **2**, we got **q2**.
* From **q1q2** on **2**, we got **q2**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc3d07a9-9fbc-42b5-a5db-b9902bc1f689)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2e2993fa-3573-49e6-abd4-71fbf9f19500)

* **q2** on **0** cannot go anywhere. So, **dead state**.
* **q2** on **1** cannot go anywhere. So, **dead state**.
* **q2** on **2** we go to **q2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe7e283a-10f2-4e53-8698-402cb5cfd59b)

* This is **DFA**.
* In the **epsilon-NFA**, **q2** are **final state**.
* Where **q2** visible that is **final state** in **DFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d69a5a55-098f-4a0d-b17e-f9e74bb96341)

* This is like **NFA to DFA** with **one change** which is **initial state** and **transitions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/35ff2a80-deb4-4fbe-b270-67b506d5c257)

* Initial state -> Same initial state as original diagram **plus(+)** from the initial state by reading **epsilon** whichever state we can go to make those also part of the **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/944b1045-ede1-4b95-a89a-64316e0dc88d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e69db6f-9465-4b25-bb21-9e5329827da3)

* Epsilon NFA to DFA [**IMPORTANT**]
* **NFA** to **DFA** conversion is going on then who are **final states**?

> Wherever **final state** is visible in the **DFA**, make them as **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb6cb907-3466-48e3-a3ab-aad2ec0d97ab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbfa6f19-520f-43db-b85a-7e4980cae9c5)

* Any where if we see **epsilon-NFA's final state** then make that state as **final state** in **DFA**.
* **Epsilon-NFA to NFA**
* **Epsilon-NFA to DFA**
* Options.
* Minimal DFA no gurantee.

## conversion-i (17) [11th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98d4e805-f36d-4f47-a49f-98ed9243caa7)

* NFA to DFA.
* Taking the starting state which is **A**.
* From **A**, we can go to **B**, so **B** is **starting state**.
* From **A**, we can go to **D**, so **D** is **starting state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e693a5b6-2672-4039-8ce4-cd1db7f67ddc)

* For **ABD** on **0**, we got **A, B, C and D**.
* For **ABD** on **1**, we got **A, B and D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8eb3aed8-ad87-4670-b1e7-17e4d06b0ad0)

* New state is **ABCD**.
* For **ABCD** on **0**, we got **A, B, C and D**.
* For **ABCD** on **1**, we got **A, B and D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ff097fd-064f-4187-b4c3-8acdbd9276e4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c7eace29-ef19-454d-b7d0-bca79e7b9a29)

* As there are **no new states**, so we can stop.
* As **D** is the **final state** in the **original diagram**.
* So, in the equivalent DFA, we have created, wherever **D** is present in the state, mark them as **final states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/216c02d6-ab09-462e-8d83-7fc61205f62b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dd596496-478f-4142-adbf-eea6d70fd920)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f12a79b5-958c-4b1b-97b3-a1cb1919229f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dd4d4dce-2c66-435d-887e-2fc11f6dce9d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/860e0d5a-df74-4816-99bb-175b8c20b2b0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/adc11fa1-0a34-450d-af8f-6d780e616c0a)

* Expressive power of DFA = Expressive power of NFA = Expressive power of (Epsilon-NFA)
* They will all accept the same power. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/592fd618-3033-460c-a3ec-01afa7d25458)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/deefc805-49d4-42e8-b6bd-4b22b332f086)

* [**IMPORTANT**]
* **Epsilon-NFA** providing a lot of **flexibility**.
* Power -> What we can **accept**.
* In terms of **power** all three will accept the same story.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b2da3227-d9cb-46f5-8da3-babdd1ac3500)

* It is accepting **epsilon** which is nothing but **zero(0)** length string is **accepted**.
* In **DFA**, on the **transition line**, we cannot take **epsilon**.
* **Epsilon** is not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc59f08b-ae99-40a9-ae4a-01b6e8a44b3f)

* This is the way to accept **epsilon** in **DFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b690ff21-6b89-4abe-ab61-274438110809)

* First is **epsilon-NFA** and the second one is **DFA**.
* Minimal finite automata -> We can consider NFA.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c43f9b34-47aa-4709-9ebf-6ec5f991ca5e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/165e8f0a-1209-4074-be6f-84306ca81430)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9dbde87-1492-4e22-9433-ab6565982e94)

* Using the **conversion** algo, **Epsilon-NFA** contain **4** states and **equivalent NFA** also contain **4** states.
* For the given language, **Epsilon-NFA** is possible **many ways**.
* If **NFA** contain **5** states then the **equivalent DFA** will contain in **worst case**, **2 ^ 5 = 32** states.
* All **subsets** we have to cover.
* The **Epsilon-NFA** contains **4** states then the **equivalent DFA** will contain in **worst case**, **2 ^ 4 = 16** states.
* All **subsets** we have to cover.
* In **worst case**, all **subsets** will come.
* **NFA** means both **Epsilon-NFA and Epsilon-Free-NFA** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f29a27d1-1249-469a-8cb2-9f3abf1452c9)

* In terms of **power**, all of them will be **similar**.

## Decidable Problems of Finite Automata(FA)

* **Finite Automata(FA)** has no chance of **hanging**. It will either **accept** or **reject**.
* **Small machines** having **two choices** only, either they will **accept** or **reject**.
* **Biger machines** having **three choices** only, either they will **accept** or **reject** or **hang**.
* Computer program is nothing but **Turing Machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f3e881f-1ac4-4fe9-bb3e-5e0f5969292f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8d9e300-9134-47e3-aaf4-d7e0f739926d)

* **Hanging** concept will come from **tuning machine**.
* If we have **three choices** then it is **not decidable**.
* If we have **two choices** then it is **decidable**.
* **Finite automata** is having **two choices** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9a7b9f61-5dc4-4b42-a739-02056178329e)

* Problems of **FA** which are **decidable**

1) Emptiness Problem
2) Finiteness Problem
3) Equality Problem

## Emptiness Problem

* Input -> Finite Automata
* Output -> Empty or Not Empty [Two choices]
* We can give **NFA, DFA, Epsilon-NFA**.
* We can give anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f18b49d9-7b0c-4bf6-9bf5-000d542fae49)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4cdead04-153f-42da-a904-17949dd6164f)

* In the given automata, **no final state** then it will accept **empty language**.
* **Final state** is there but from **starting state** it is not **recheable**.
* To check if the given automata is accepting empty language or not?

1) Eliminate those states and it's transitions which are not reachable from **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4efc9db8-0df6-4b9d-b182-a8b255761c69)

* **E and F** are not reachable from **initial state**.
* Whoever left are reachable from **initial state**.

2) In the remaining **FA** if we found atleast **one(1)** final state then given **FA** accepts non-empty language otherwise **empty language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c072eb21-5f3c-4835-b3ea-535ecd659516)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1e15bb3-113c-4d13-8beb-543f4b8cb12d)

* We don't see any **final state** so the **FA** accepts **empty language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/49bab000-6375-41dc-bffc-556238d2d020)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/029cbfa6-f6ae-4649-bdf9-3baee677cd5e)

* [**IMPORTANT**]
* To solve any problem, if we can give an **algo** like **above** then it is a **decidable** problem otherwise it is an **undecidable problem**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/684b47c2-3170-4534-9cba-9e70f404e484)

* Example
* Empty or Not Empty?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc161c4c-de7d-42af-bf99-a74abcc24139)

* After **simplying** we saw that we have a **final state** which means it is accepting **some language**. So it is a **non-empty language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8aa7d872-19e6-4565-84bf-655e2e2416b0)

* Emptyness problem of **finite automata(FA)** is **decidable** why?

> There is an **algo** to do this.

## Finiteness

* If we want to get **infiniteness** then **loop** is required.
* Without **loop** we cannot say **infinite**.
* Without **loop**, then it is **finite**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d61cfa24-ee12-46a8-8dc2-ad1322a64d55)

* Loop there -> Infinite
* Loop not there -> Finite.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/460366f5-631d-4351-b264-edf45495146e)

* **Loop** is there but that state is not recheable from the **initial state**.
* Recheable loop or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae444015-904c-43b5-b2f1-c9a923f93b44)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32c4ffc4-b99e-48d0-8847-0a1845be098c)

* From **starting state**, **S4** state is **recheable**. **S4** is **recheable** but what is the use, **S4** is **dead state**. There is **no chance** of going to the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f393bff4-54c6-4944-b0f9-53653ae47a0a)

* Finite or Infinite -> Belongs to **loops** or not.
* **STEPS**:-

1) Eliminate those states and it's transitions which are not recheable like **previous problem** from **initial state**.

* When first step is over all states are **recheable**. We can go to **every state**.
* One person is **recheable** but from that **state/person**, the **final state** is **not recheable**.
* From any state we cannot reach the **final state** then that state is **dead state**.

2) Elimiate those states and it transitions from which we cannot reach final state.

* There is no use of **loop** at the **dead state** because nothing accepted.
* **Dead state** means nothing accepting why bother.

3) In the remaining **FA** if loop is present then it accepts **infinite language** otherwise **finite language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71e6bd9a-f8e7-44ec-a404-242def85f261)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34c32df6-d9a5-4581-a589-7bcb86d0767a)

* Algo. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb9b34be-fbdc-4cd0-9fe4-5f644ca7f1db)

* All states are recheable from **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2057a3c6-94b8-4ddd-a0e7-787ed18c9b4d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/afcb031e-2ba5-450d-bde6-c4b76b43995d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34679e9b-28dc-4cd2-881f-dd89c0349e23)

* In the remaining diagram there is **no loop**.
* So it is a **finite** language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eccb3baa-09a2-41b6-beda-cfbd555357bb)

## conversion-ii(18) [11th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b08df2c2-e5a6-4c64-9680-caa9205fb928)

* All states are recheable from **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19c64ae7-9292-4658-b1cf-e344e462edf0)

* No **dead states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1abc5e8-c882-4a76-925c-1ec39a9b9368)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e29dca49-9734-47e5-9e8c-0a0b5b3f494d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f959bf6-bfd5-4d88-816c-ea3c2b1c6208)

* We have **three** loops.
* So it is an **infinite language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a10373d-3b87-471e-8a13-2131fef03ca3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9f68465-167d-4ff5-bf30-9244b8c6f8b7)

* [**IMPORTANT**]
* In the **3rd step**, **loop** is there and **atleast one(1) final state** required.
* **Loop** is there but **no final state** then it is accepting **empty language**.
* Whenever **empty language** we cannot say **infinite language**.
* **Atleast one(1) final state** is there but **no loop** there, then it is **finite language**.
* **Loop** is there but **no final state** then it is **empty language** which means it is **finite language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bbcf8d31-db50-4daf-9c6f-d59ff5c02595)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07f26a19-7529-4b8d-b25c-ea2305c6e849)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59e13762-ad2c-472f-a296-a9672446532a)

* [**IMPORTANT**]

## Equalities

* For **equality**, we need **two** inputs.
* Not only **Two finite automatas** but **two DFAs**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/034cdd4d-34de-4903-8501-0f646748eb8e)

* Both are **DFAs**.
* Two machines are equal if both contain **same** no. of states. It is **wrong**.
* It may be or may not be.
* No relation.
* Two machines are equal if both contain **same** no. of **final states**. **NO**. It need not be. 
* What language they accept that matters.
* If both accept **same** language then they both are **equal**.
* When **two machines** are equal, when they both accept the **same** language.
* Language only matters.
* If **alphabet** itself is different then we don't check also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/814c5ea9-2138-4ec4-b886-0209548650c2)

* From both the machines, stay at the **starting state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ceca147-0cde-4756-a54e-d0ef68bf4511)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c3458e4-f8fa-4335-83f7-5414bc669bd6)

* Both are **equal** measn both accepting **same language**.
* One machine is on **C** and another machine is on **D**.
* Both machines contain **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6cbc6f29-4766-428e-8c82-cd42f762a82c)

* Different alphabet, no need to compare. They are not going to be **same**.
* Because of **DFAs**, some behaviour is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4039783d-f4d2-4a8f-8976-db2b6f933208)

* Both the automatas start form **starting** only.
* The table contains **two machines's** behaviour.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dcab623-f13a-4195-a1fb-846674ba8e0b)

* First machine is **accepting** and second machine is **rejecting**.
*  At anywhere combination of **final and non-final**, not it.
*  Both are **not same** because one is accepting(final) and the other is rejecting(non-final).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f4b0b11-d5ec-4c42-bb3a-398b6ab32485)

* Using comparison table we can say that they are **equal or not**.
* No. of states doesn't give gurantee that they are **equal or not**.
* No. of **final states** doesn't give gurantee that they are **equal or not**.
* The only thing that gives gurantee that they are **equal** is the **language**.
* Both are **accepting** same language or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c640bd65-259f-4869-a314-89bbfad9aaa3)

* These **three** problems of **FA** are **decidable**.
* In case of **emptyness** problem, our goal is **accepting something**.
* The **FA** which is a **DFA** is accepting **empty language**. How?

1) If no final-states

* For the given **DFA**, do **complementation** which is turing the **non-final** states to **final states** and then the **final states** to **non-final** states.
* If we check the **DFA'** or **DFA complement** if it is **empty or not**. **YES** it is **empty**.
* It means that the given **DFA** is **accepting everything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6f33ae0-d26a-4bad-95dc-48adcc100200)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1e523316-d949-478c-bd79-266af315d3de)

* Given **FA** which is a **DFA** is accepting everything or not that is also **decidable**.
* It is called as **completeness problem** of **finite automata**.
* So, **completeness problem** of **finite automata** is **decidable**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b12ed508-3ca7-4d0e-b217-cdc703ae1187)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f52ddbfc-b68f-4a4d-8239-19ffdcb66a0d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a37fb47-40bd-48f0-919d-1445b6ac3db3)

* Does **FA** accepts the given string **w**?

> On the given **FA**, apply the string **w**. Finally, we are in **final state**, so **w** is **accepted**.

* It is a **decidable** problem. 
* It is called as **membership** problem.
* The string is a **member** of the given **FA** or not.
* If any string that is accepted by the machine is a **number** otherwise it is not a **number**.
* So, **membership** problem of **FA** is **decidable**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ead1798c-52be-4711-a848-a9383e02e81c)

* Does **FA** halts after reading string **w**?

> **YES**. It will **halt**.

* This problem of **turing machine** is **undecidable**.
* Hanging** is a part of any device.
* Small machines may not hang.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5884f501-c598-46ed-b226-a4fff148422b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/28440839-5db3-45dc-b3cb-69d486243a56)

## Minimization of FA(DFA)

* It is **DFA**.
* Goal:-

1) If any 2-states are behaving as **same** then make it as single state.
2) Before applying minimization algo, remove unrecheable states from the **initial state**.

* Not recheable is anyhow **useless** only.
* It will eliminate **redundancy**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/991a0a6c-5dce-4ebc-914d-3f33a896e272)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ca086b8a-8d7e-4c1e-94b3-febfc1b8060b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3a56ffc-271a-41e0-95dc-728b85bb2e95)

1) Taste Filling method -> O(n ^ 2) Time
2) Partition-Algo -> O(n * log n)
3) Myhill-Anilnirode Theorem.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/24534891-41f5-439d-9e8a-8f902d2c022a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3593e523-c5e0-4df2-9963-2d60cdd0bd8e)

## conversion-iii (19) [12th Sept 2023]

## Partition-Algo

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/314c108f-6f6b-4fd6-8c11-6d2501c59135)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb4a50d0-7768-4850-bc08-46e41f898660)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1693bead-f032-4bab-8362-6b22540f4177)

* Draw the **diagram** in the exam

* **STEPS**:-

1) Not reacheable states **delete**.
2) Original algorithm, Partition will start. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a36e418-1219-4ebb-b5ac-4df5ecf0c51a)

* **q3** is not recheable.
* **Partition algorithm** -> It divides the states into groups, based on the **behaviour**.
* Total we had **8** states as, **q3** state is gone, we now have **7** states.
* We have divided the states into **two** groups which is **pie0**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c36477c-0795-45df-9bad-610438799fb7)

* Starting itself we have **two** groups.
* **Final state** never be **equal** to **non-final** state. [**IMPORTANT**]
* **Non-Final state** never be **equal** to **final** state.
* All **non-final** state maybe **same**.
* All **final** state maybe **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2bf379c0-17bd-4b29-9877-ef69742b9b09)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8f02af3-906b-414e-860d-3cf7d84aad5c)

* Without reading **epsilon**, we got **two parts**.
* By reading **zero(0)** length string, we got **two parts**.
* Without reading any symbol, **automata** states can be **divided** into **two parts**. One group is **final states** and the other group is **non-final** states.
* This is called as **zero equivalence**.
* **Only one** person, we cannot **divide** further.
* **q1** saying that **q1** wants to be in the **same** group as **q0**.
* If **q0 and q1** are having **same** behaviour then only we can stay in the **same group**.
* How can we decide, two people are equal or not?

> By applying a **symbol** if they both go to the **same** group then they are **equal**.

* For **q0 and q1** for **0**, they were going to **q1 and q6** which are in the **same group**.
* For **q0 and q1** for **1**, they were going to **q5 and q2** which are in **differenet groups**.
* so, **q0 and q1** are not **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2a1183b2-c8e7-465e-a8ee-b3049fe2daf8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83760d14-d4f1-4268-b220-229f6ac987b6)

* For **every symbol** both are going to the **same** group then only they are **same**. [**IMPORTANT**]
* Further **divides** will only happen and **no combines**.

* For **q0 and q4** for **0**, they were going to **q1 and q7** which are in the **same group**.
* For **q0 and q4** for **1**, they were going to **q5** which are in the **same group**.
* so, **q0 and q4** are **same**.

* Why doing **pie1** or when **pie1** creation is going on we will use **pie0**. [**IMPORTANT**]
* For **pie1** creation, don't use **pie1** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f644586-7477-409b-b8d2-cc6ddf967faf)

* For **q0 and q5** for **0**, they were going to **q1 and q2** which are in **different group**.
* so, **q0 and q5** are **different**.
* For **q1 and q5** for **0**, they were going to **q6 and q2** which are in the **different group**.
* so, **q1 and q5** are **different**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/49ef42dc-f4d4-4897-907e-85b38812b783)

* Because the first one is **q0** in the **group**.
* Captain kind of thing.
* Main person.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9782411c-5a7d-4f1a-8f75-f91f658199d1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/971737ee-7c5c-4170-9546-4d03d8fd565b)

* **Pie1** is created using **pie0**.

* For **q0 and q6** for **0**, they were going to **q1 and q6** which are in **same group**.
* For **q0 and q6** for **1**, they were going to **q5 and q4** which are in **same group**.
* so, **q0 and q6** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab86b42f-ac11-4f56-a9c2-3e9f3af4360a)

* For **q0 and q7** for **0**, they were going to **q1 and q6** which are in **same group**.
* For **q0 and q7** for **1**, they were going to **q5 and q2** which are in **different groups**.
* so, **q0 and q7** are **different**.
* For **q1 and q7** for **0**, they were going to **q6** which are in **same group**.
* For **q1 and q7** for **1**, they were going to **q2** which are in **same group**.
* so, **q1 and q7** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cea31a29-2999-41d1-b7b9-f184e87be3f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/081b722b-53e0-40f2-887e-ec262cd3ab5e)

* All states are over.
* This is called as **one(1) equivalent**. **One length** strings(0 or 1) we applied.
* **q0 and q2** are **different** in **pie0** itself.
* They will be **different** in **pie1** as well.
* **One(1) equivalent** is nothing but we devided the states by reading **less than equal to 1-length** string.
* **q2** is already **divided** by reading **zero(0)** length string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4873562f-05d8-4d38-9402-14d51137d40e)

* According to **pie1**, we have **4** states and we got them by reading **less than equal to 1-length** string.
* In **pie2**, **two** people are said to be **equal** when if they both are going by applying **same symbol**, they are going to **one** of the groups. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/20206c92-0b2c-496f-9157-11e549e5faa5)

* For **q0 and q4** for **0**, they were going to **q1 and q7** which are in **same group**.
* For **q0 and q4** for **1**, they were going to **q5** which are in **same group**.
* so, **q0 and q4** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/379a22ee-ea8a-4f54-b0e0-212741b8db99)

* For **q0 and q6** for **0**, they were going to **q1 and q6** which are in **different group**.
* so, **q0 and q6** are **different**.

* We cannot **join 'q6'** with other groups.
* They are **divided** already.
* We cannot **merge**, further groups will **divide** already.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30240a8e-71e2-4e41-ae35-082542108411)

* For **q1 and q7** for **0**, they were going to **q6** which are in **same group**.
* For **q1 and q7** for **1**, they were going to **q2** which are in **same group**.
* so, **q1 and q7** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ece21c8b-b1b3-415b-8dd2-30255a62ed74)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e060ae1d-c7fd-41ce-9633-88dde43ffd4a)

* In **pie2** we have **5** states.
* **q1 and q7** are **two equivalent**.
* At what length string they are **equal**.
* Till now, **q1 and q7** are **two length equivalent**.
* Until which equivalent?

> Say **maximum** number.

* **q0, q4 and q6** are **zero equivalent, one equivalent** but they are not **two equivalent**.
* Until **one equivalent** they **satisfied**.
* That's why * **q0, q4 and q6** are **one equivalent**.

* **q1 and q7** are **zero equivalent, one equivalent, two equivalent**.
* So, they are **two equivalent** which is the **max** till now.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c924ed76-8ecb-4764-9490-504c563b072c)

* In **equivalent**, say **maximum**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75f6d4d3-4e90-4e5a-81fb-6447a6c8546b)

* For **q0 and q4** for **0**, they were going to **q1 and q7** which are in **same group**.
* For **q0 and q4** for **1**, they were going to **q5** which are in **same group**.
* so, **q0 and q4** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5673b2ed-a313-42a8-a81f-f37df97c18d7)

* For **q1 and q7** for **0**, they were going to **q6** which are in **same group**.
* For **q1 and q7** for **1**, they were going to **q2** which are in **same group**.
* so, **q1 and q7** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7decfa1-4dfe-4ddc-b13c-b25512d5962d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a317de9f-b372-41aa-9040-b8a6ea219e2f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a344e37-ef0b-4f4b-9ef2-1ce63d601c30)

* **pie2 and pie3** are **equal**, it means that if we go **pie4** then also it is **equal**. Same thing will come.
* **q0 and q4** are **forever equivalent**.
* **Forever equivalent** means that **q0 and q4** are **same**.
* The person who created the **DFA**, unnecessarily wasted **one state** because both are **same**.
* We can make it as a **single state**.

* **q1 and q7** are **forever equivalent**.
* **Forever equivalent** means that **q1 and q7** are **same**.
* The person who created the **DFA**, unnecessarily wasted **one state** because both are **same**.
* We can make it as a **single state**.
* DFA has **8** states.
* We removed **one state** directly that is **not recheable** from the **initial state**. We have **7** states now.
* Why applying **partition algo**, we got to know that **q0 and q4** and **q1 and q7** are **forever equivalents**. They are always **behaving** same.
* Last **two passes** are **same** means that they will be **same forever**.
* So, we cannot separate **q0 and q4** and **q1 and q7**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6b4bc56-80a8-4cc3-acc2-1781968fcc3e)

* Last round also **same** means they are **forever equivalent**.
* **q0 and q4** -> **forever equivalent** -> They are just equivalent.
* **q1 and q7** -> **forever equivalent** -> They are just equivalent. 
* **Equivalent** means that give anything they are **equal**.
* **Equivalent** means **forever equivalent**.
* **q0, q4 and q6** they are **1-equivalent**.
* Until **one(1)** only they are **equivalent**.
* **q5 and q2** are never considered as **equivalent**. Last round **no**, before also **no**.
* Final state cannot be **equal** to **non-final** state. Never.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee050b0e-1fc5-43ee-893f-cd8ec9895442)

* **q0 and q7** are **zero(0) equivalent**.
* **Partition algo** is also called as **state equivalence** method.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d28c9325-eb55-4c86-85a9-526a78c3052d)

* If last **two passes** are **same** then stop it.
* **q0 and q4** are **same**. Why would be want to manage **q4** again. Just delete it.
* **q1 and q7** are **same**. Why would be want to manage **q7** again. Just delete it.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4e70ae2-2546-4c7b-9204-97ae1bdd94f1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/772bd84b-943e-4e15-8eeb-182ac6d5f0e2)

* Now, we have **5** states.
* If we see **q4** anywhere then change it to **q0** because **q4 and q0** are **same** and we deleted **q4** already.
* Whenever we have **q4**, we can use **q0** in place.
* If we see **q7** anywhere then change it to **q1** because **q1 and q7** are **same** and we deleted **q7** already.
* Whenever we have **q7**, we can use **q1** in place.
* One copy we **delete**.
* Out of the **two copies**, delete **one copy**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a817d95d-750b-4682-b38f-a6da9e74fb94)

* Table is **better** than **diagram**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2187fb18-fa70-4e1a-a79b-c91e3fde8076)

* Example

1) Find the states that are **not recheable** from **initial state(q0)** then **delete**.

* No one is going to **q7**.
* So, delete **q7**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a5e076c-de02-4294-afcf-b53a8be7b49a)

* We are drawing to see if any states are **unreachable or not-reachable**.
* If states are **unreachable or not-reachable** then **delete**.
* No new states came.
* From **q3**, nothing new came.
* From **q0** which is the **initial state**, we cannot go to **q4**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29544f3b-50b7-4b72-b8a7-6cf56639c6ee)

* From **q0** which is the **initial state**, we cannot go to **q4,q5,q6,q7**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37c9bbab-74a2-42ce-8ebb-9f1e3f33d5aa)

* If the states are **not recheable** from **initial state(q0)** then **delete**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/54c7f2fd-d0d6-47b1-ae01-8c72ce958e0a)

* So, we **deleted** the states **q4,q5,q6,q7** from the table.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c5bf138-53f8-4ae3-bea8-335129274729)

* They are anyhow **uselesss**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18341a34-4438-4210-90a3-5a3f2eded0b5)

* Carefully perform **step 1**.

2) Partition-Algo

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7bbffc8c-d976-4cfb-9d28-520a9c2fbac9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11ab6b47-5991-482d-a948-98ce4e42f42c)

* According to **partition algo**, we will have **two groups**. One with **final states** and one with **non-final** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/03be7a92-7f0e-45ff-92fb-21c508956c82)

* If we are **lucky** and **final state** is there but it is **not recheable**. We will delete the **final state**. Remaining all of the states will be **non-final states**.
* We go anywhere **rejected** as it is accepting **empty language**.
* So, we will have exactly **one state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97af5efd-b237-42c3-9df0-5bf5dbd9f838)

* For **q0 and q1** for **a**, they were going to **q1 and q0** which are in **same group**.
* For **q0 and q1** for **b**, they were going to **q0 and q2** which are in **same group**.
* so, **q0 and q1** are **same**.

* For **q0 and q2** for **a**, they were going to **q1 and q3** which are in **diferent groups**.
* so, **q0 and q2** are **different**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39f3abe8-8217-4e61-bdde-fe9628116d1e)

* For **q0 and q1** for **a**, they were going to **q1 and q0** which are in **same group**.
* For **q0 and q1** for **b**, they were going to **q0 and q2** which are in **differemt groups**.
* so, **q0 and q1** are **different**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2e501f1-eeed-41f6-b547-46fa81a2f96b)

* No requirement of going further.
* We cannot divide any further.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42212e29-d737-4a2c-b388-0a47b7a0762b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e73f9b0-993a-43c4-9d8b-8e7e5c294547)

* So we have **4** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/110660b3-da3a-4b35-870d-5d4b6d6f5d79)

* yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe884f77-4652-4bdb-bf4c-025ea92224f9)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cf0dfddd-35fd-409a-ab36-3a8b6d494ec9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/003baaab-04cc-4e8b-926d-9f861718486d)

* Questions
* Steps to solve it.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/643339e5-79f5-4c50-9ed2-d83563da70ee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/757cdcb7-0034-490c-80bd-af2b88dbaa80)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c11bf632-2ee2-44fb-b84a-d1ccb596db5e)

* **NOTE**:-

* If DFA contains **n-states** then **equivalent minimal-DFA** contains **less than equal** to **n-states**.

## doubt-clearing-session(20) [12th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c1541d6-9338-4951-8555-47435c143a64)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4d30981-8d79-4bc8-9042-347bb4a9c3dc)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/570cd76c-92e6-425e-8816-300ac458da66)

1) Check if any states are **unrecheable** from the **initial states**.

* **q3** is **not recheable**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42b00660-f5d6-4799-a4a3-159f066d69a4)

* Divided into **two** groups, **final and non-final states**.

* For **q0 and q1** for **0**, they were going to **q1 and q6** which are in **same group**.
* For **q0 and q1** for **1**, they were going to **q5 and q2** which are in **differemt groups**.
* so, **q0 and q1** are **different**.

* For **q0 and q4** for **0**, they were going to **q1 and q7** which are in **same group**.
* For **q0 and q4** for **1**, they were going to **q5** which are in **same group**.
* so, **q0 and q4** are **same**.

* For **q0 and q5** for **0**, they were going to **q1 and q2** which are in **differemt group**.
* so, **q0 and q5** are **differemt**.
* For **q1 and q5** for **0**, they were going to **q6 and q2** which are in **differemt group**.
* so, **q1 and q5** are **differemt**.

* For **q0 and q6** for **0**, they were going to **q1 and q6** which are in **same group**.
* For **q0 and q6** for **1**, they were going to **q5 and q4** which are in **same group**.
* so, **q0 and q6** are **same**.

* For **q0 and q7** for **0**, they were going to **q1 and q6** which are in **same group**.
* For **q0 and q7** for **1**, they were going to **q5 and q2** which are in **differemt group**.
* so, **q0 and q7** are **differemt**.
* For **q1 and q7** for **0**, they were going to **q6** which are in **same group**.
* For **q1 and q7** for **1**, they were going to **q2** which are in **same group**.
* so, **q1 and q7** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19bfb7f6-5852-4bf1-8c6b-80473b81b12f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e103d189-758f-441d-85e2-62c1542851ab)

* We have **4** groups.
* We cannot divide **q1 and q7**. They are exactly **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e33ad661-6548-4fd9-b23b-e76d1764e08c)

* For **q0 and q4** for **0**, they were going to **q1 and q7** which are in **same group**.
* For **q0 and q4** for **1**, they were going to **q5** which are in **same group**.
* so, **q0 and q4** are **same**.

* For **q0 and q6** for **0**, they were going to **q1 and q6** which are in **different group**.
* so, **q0 and q6** are **different**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a1f0a66-d219-4e65-9afc-3136003a636c)

* For **q0 and q4** for **0**, they were going to **q1 and q7** which are in **same group**.
* For **q0 and q4** for **1**, they were going to **q5** which are in **same group**.
* so, **q0 and q4** are **same**.
* Last **two rounds** are **same**, so **stop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e770b2c2-f77e-4279-90d0-da2da0517d4f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f068e10-d6b0-4e29-b2b0-c801d33a945e)

* In **pie3**, we have **5** states.
* **q1 and q7** are **same**.
* Make them as **one state** only which is **q1**.
* **q0 and q4** are **same**.
* Make them as **one state** only which is **q0**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/943f3ada-824b-4c97-b121-9fd02ef71830)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87c4b3f2-1612-4bdc-a780-5e3039fa362f)

* Transitions of **q7 and q4** delete as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3479fc77-7e01-4be3-9ea3-277c1da138ed)

* After deleting, do some **adjustments.
* **Minimal-DFA** contains **5** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80cdd00e-13f4-49af-ba4d-03125e8f36a7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66e27210-550f-4c2d-bceb-91833930d370)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad95a9a6-38ec-4caf-9ebb-95cdd6f543d4)

* [**IMPORTANT**]
* Minimal-DFA

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/00dce909-70be-49c8-95e3-049f0cf6c6c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e4326ac-95de-4cec-a8db-dcd94f33c369)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74ab8806-4e88-4201-9aef-64e28fbdec3a)

## Finite Automata to Regular Expression

1) Arden's method -> Standard.
2) Static Elimination method -> Non-standard, meant for **GATE** exam.

* Worst case use **methods**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29f4a7f9-c1e0-4580-9a28-7a9a7df98f95)

## Arden's Method

1) We can't apply this method for **Epsilon-NFA**.
2) If **P and Q** are two regular expression and **P** not contain **Epsilon** then the equation, **R = Q + (R * P)** can be uniquely written as **R = Q * (P ^ *)**.
3) If **P** contains **Epsilon** then we have **infinite** no. of solutions.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1e1d6b6a-5208-4ff4-84e6-c32fa32bba7f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a41f071-16b9-46dd-9b75-995b0c36b181)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06d54875-3e01-458c-9f1c-a21a1eb9a674)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/418a2a00-0d01-4845-8f98-658500ca44ae)

* Example

* In this automata, any state which is **dead state**.
* Except **epsilon-NFA**, this method is **applicable** for **NFA and DFA**.
* If we have **epsilon-NFA** and we want to apply **Arden's method** then we have to convert the **epsilon-NFA** to **epsilon-free-NFA**.
* As there is **dead state** also, so it is **DFA**. 
* As **q4** is **dead state**, so if we **remove 'q4' or not remove 'q4'**, the **language** is **same** only.

1) Unreachable states from start states, **delete**.

* We want **language** for this **finite automata**. So, **dead state** cannot bring any language.
* As it is **DFA**, we have to respond to **everything** and the **unnecessary** things are sent to **dead state**.
* In **language** participation, **dead state** cannot do anything.

2) **Delete** the **dead states**.

* It is because they don't participate in language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6a82b91-c376-497e-92c7-fa8af2851b52)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/287cce27-93ed-4017-81d9-5c41a732cc98)

* **DFA** means **dead states** required.
* This method is applicable for **DFA and NFA** also. That's why we are utilizing it.

* **Arden's method's**:- [**IMPORTANT**]

* Do the above **two steps**, so we remove the **unnecessary** things, which we don't want.
* It will save a lot of time.

1) Write state equation for **every state**.

* **q2's** state equation -> Who can come inside **q2** -> **Only incoming edges** take.
* q2 = q1 * a [**q2's** state equation]
* q3 = q1 * b [**q3's** state equation]
* q1 = q2 * b + q3 * a [**q1's** state equation]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cbc2d72-90b9-4f9f-b9b7-e6ce060bb9d4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e2a160af-1bb5-49b1-b128-31ad057a1e26)

* For **everyone**, we have written the **state equation**.
* Now, go to **starting state**.
* For the **starting state** we should write **epsilon**.
* **q1** is **starting state**.
* While writing the **state equation** of the **starting state**, write **epsilon** also as it is the **starting state** irrespective of **final state** or not.
* If **q1** is **not final** then also we have to write **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/176f5d33-ef67-422a-b70a-154cd042d216)

* [**IMPORTANT**]
* If **q2** is **final** then what **q2** will accept? 

> Whatever **q1** is accepting, followed by **a**.

* What is the meaning of **q3** state equation?

> Whoever is coming inside of **q3**, **q3** is accepting. 

* It means that when **q3** is **final** then what **q3** can **accept**.
* If **q3** is **final** then what it can **accept** is that whatever **q1** is accepting followed by **b**, **q3** can accept.

* What is the meaning of **q4** state equation?

> If **q4** is **final** then what **q4** can **accept**.

* If **q1** is **final** then it can accept **epsilon** also because **q1** is already **starting state**.
* While writing **state equation** for everyone, if the state is a **start/initial state** then add **epsilon** also. [**IMPORTANT**]
* For **starting/initial state**, **add 'epsilon'** also to their **state equation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4a1854d-9d58-4c9e-a4f1-9b2f3304adb6)

* What is the meaning of **q2** state equation?

> If **q2** is **final** then what **q2** can **accept**.

* If **q1** is **non-final state** then also we will add **epsilon** to the **state equation**  of **q1** as it is the **initial/starting state**.
* We don't care if it is **final or non-final**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/af4c1bb6-0e15-40f5-bada-4b317ea054f8)

* [**IMPORTANT**]
* **Language** means what **final state** it can **accept**.
* We have written **state equation** for everyone but at the end of the day, we want **state equation** only for **final state**. 
* **q1** is the **final state**.
* Only **final state** person is **required** to us.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8350d900-5990-4a88-be46-34523a31da9b)

* The **final answer** should be in terms of **a's and b's**. No one wants **states**.
* We don't want **states**.
* **q1** state equation is the **answer** as **q1** is the **final state**.
* We want **q1** in the form of **a's and b's** only. We don't want **states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f34b3f1e-cf37-4f1d-81b8-3e23a50f3b14)

* **Final state** only we want.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92c34262-34f2-4460-9b37-2a570ae32dd7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab5137bb-ce28-45d1-8aca-b0ef9a87677b)

* We got **4** by substituting in **3**, **1 and 2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55980ea3-a9cb-42e5-ab28-15579ddd9e3f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d0bb1531-fffd-4e9a-b287-3a6d0252b7d4)

* We are comparing the equation with **R = Q + (R * P)**.
* R = q1
* Q = Epsilon
* P = (ab + ba).

* As **P** doesn't have **epsilon** so the equation, **R = Q + (R * P)** can be written as **R = Q * (P ^ *)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbfbba3a-13b9-4adc-bccb-5bf8fc971227)

* We got **final equation** of **final state** which is **q1**.
* Inside we don't want to see **states**.
* We want **final equation** of **final state** which is **q1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c8cb686-d612-41a1-9bdc-b7bbc5ba8a33)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32a83709-d61a-4e18-b13a-355f6d4c8480)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09e5c336-142d-4cc6-b3f3-bf07e5e6efba)

* [**IMPORTANT**]
* Final state equation write using **alphabets**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96ffcb3c-7a1e-43df-83c3-746698926181)

* Nothing, individually find out the **equations** without the **states** and **add them**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05aac810-517d-483b-9dd0-4df2aa3b83be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c35d9a53-e6af-4aa9-925d-6007bbd9037e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f8f7a2f-c5a1-4dda-89a7-73abd7a08905)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71e5dcd1-9b3d-444a-919e-8f7fb0580f62)

* Yes, but maybe **time consuming**.
* In **worst case**, apply this method.
* If the **diagram** contains **more states** then **don't apply this method**.
* For every state we have to write **more equations**.
* Use this for **tricky and small problem/diagram**.
* For **more states** use the ** second method** maybe.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32a19b72-29a6-473d-a788-5af283ae0f3a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c22fe0c9-95c5-403b-b593-1437a8fffe23)

* They are **same answers**.
* Maybe the **first expression** we got not there in the **options**, the **second** one is there then choose the **second expression**.
* Meaning wise both are **same answers**.
* Tricks being played.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84db42c5-8371-4070-9335-f7920df92f6f)

* last year question, 2022 paper.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1342a499-9bb5-45ca-815d-6aaa84afdca2)

* First try by solving it **manually**.
* Problem coming then do **Arden's method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0fa74e9f-5506-4106-b25a-2a9f6635e772)

* Meaning wise they are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/86d97aae-bc36-4620-9cf4-b9eebd43ad60)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21e9c62c-5d0b-418a-a474-60c37f813a61)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3db3f7ac-a468-479c-9170-25ce3ebecf31)

* After **substitution**, in the **q1** equation we have **q1**.   [**IMPORTANT**]
* If we want to remove **q1** then we have to **apply arden's method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fa3a6bd0-f71e-48f1-95a3-feacd9ae0996)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4b028d6-d10a-4ecd-82d6-8a5ef738eef1)

* Example.
* As **q1** is the **initial state** of the diagram, so we are putting an **epsilon** on **q1's state equation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d01ddcdf-1636-4a91-81c4-181d9cd3625d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f23dffe4-23ce-4539-a6e4-16ef33706c9d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22894bfd-b7e6-4cf3-b64b-2d2390d27b81)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6bd13e0d-336b-4323-836e-9dfb01774c6b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c5f8e1e-ad44-418a-bbf8-d4e9302fbf6a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1002a15-a37d-434f-8c90-45bfec383186)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5de7a4b7-a2a4-4fda-9424-3e4d026a4310)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ffa6369b-2920-48c5-95a2-cded52713341)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95456df7-e353-466e-9ebf-204c59e97eb0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b716263b-a7f9-4be4-a953-71edbca35fdd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b19486dc-eb2a-4408-8bf2-e38946dbff11)

* [**IMPORTANT**]
* After writing **state equations**, solve in whatever way we want.
* Options given in **GATE exam**.
* Check the **options** one by one.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07b2f1fc-db5e-4041-b0a4-ac93bef4b416)

* See the **automata** first which is **minimal**, which regular expression giving **minimal**. Check next minimal.
* If we are **lucky** then **one only** will satisfy.
* Others don't satisfy.
* Check the **minimal string** in **automata** as well as in **regular expression** also.

## closure-properties-i(21) [12th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cea30e39-16bf-4ed4-beee-31bdede6b4c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70142ecb-754f-432c-85ae-aeeb4c116603)

* It will work for both **NFA and DFA** also. 
* No state is behaving like **dead state**.
* No state is not recheable from **initial state**.
* Every state is recheable from **initial state**.
* If **q0** is the **final state** then it can only accept **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/866ecf89-3550-4868-a122-499b94d48f54)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/331c6fcd-87a2-46ab-b6be-79909ab92452)

* We want **q3** interms of **0's and 1's** as **q3** is the **final state**.
* Epsilon * 1 = 1

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a82e3655-9052-47fb-91cf-41c1f7ac70a0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95e34159-f07d-4b0d-83e3-60a65d9d66cc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8ba0de6-3d7a-45c9-8709-d3db967f9241)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee9b9878-26e5-4b84-99bd-f4c7a25f79ff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/868a8a8f-82af-4ce9-a4c4-9e9f61d9ee6e)

* **Options** will be **guranteed** there.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/292f75fc-e853-4675-946e-32e9a7cc28a6)

* We are taking the **whole stars(*)** as **epsilons**. So the minimal string we are getting is **101**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c4a6b02-72ea-48f2-bccc-aa7cbf6cf3ba)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/466e01dd-0084-4fd5-83ab-04a3abae0ddc)

* In **GATE exam**, mostly we have to do **manual checking**.
* Go to **final state equation** and convert the **final state equation** in terms of **alphabet**.
* If we want to remove a **particular state** from **himself** then use **arden's method**.
* If we want to remove other people then use **substitution method**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a46cd3c1-6fb8-4169-a83b-6b4c85497176)

* Example.
* As in the **A's state equation** only **A** was there, so we were able to apply **arden's method** on **A**.
* 1 * (1 ^ *) = (1 ^ +).
* 1 * (1 ^ *) -> To **(1 ^ * )** we are **concatenating a '1'** to all of it's values.
* Epsilon * 1 = 1.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/48198c19-e349-4fd2-a0f5-91dd5458b651)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ceb6498a-7f23-4b68-a7ec-ed0b1d226798)

* As **all** of the states(A,B and C) are **final states** so we are **adding** all of them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70031047-53ab-4bea-8f3e-0d9bd94f331f)

* From the **bracket**, we can only get **epsilon**.
* We can get **only 1's**.
* We can get **1's followed by 0's**.
* In the **options** verify properly.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/68b2667d-1484-4961-9d28-07b2acf79d8b)

* **Epsilon** possible.
* So many **0's** are accepted.
* So many **1's** are accepted.
* **0's** followed by **1's** possible.
* **1's** followed by only **0's** possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1251edc9-dd1b-48ca-b7d2-19fb0bb13af0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a87aaff5-015b-42a4-b39e-13cf7bf7eea7)

* [**IMPORTANT**]
* On the given automata, if we apply **minimization** algorithm and really if it is a **one state** then **one state** will come in **minimization** algorithm.
* All states will be **eliminated** and **only one state is left**.
* **DFA** will cover everything.
* Everyone's **final** also will be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/633bf7e6-354f-46d8-848e-9f0a73a641c0)

* Directly we can say that it is covering everything.
* In **DFA** every state is a **final state**. It will accept everything.
* In **NFA**, every state is a **final state** then also **no gurantee**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/776a1558-3c94-487d-8286-b3ee8880a645)

* In **DFA**, for everyone there is exactly **one transition**.
* **Minimization** algo will be applicable only for **DFA**.
* **Minimization of DFA**, if it is **NFA** then some people may not be having some transition.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/299fcb91-d1dd-4424-b9ae-110341308bc1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a85d4d0a-1783-4079-997f-5a5587ce1fe7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10ce0d15-62db-4d83-b6bb-a7bbcdbc31a1)

* So there is **only one state**.
* Apply **arden's method** on **q1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e06f61d6-4687-4878-83d5-8f7bf4ada027)

* It will give **one formula**. It cannot give **all formulas**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21dbe476-19b4-41c5-aa1d-85359a054cc4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5321d744-864d-4f71-b962-e3d3cf0c98fb)

* Finally we wannt **q1** answer.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b9e7f43-100a-4e24-acce-5abba574b145)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed800082-6fd4-4fcc-80a2-f614f3f1fe7c)

* **q0** using **q1** and **q1** using **q0**.
* As both are using **each other**, anyone we can **substitute**.
* Both are **same**.
* In **q0** we are using **q1** and in **q1** we are using **q0**.
* Anywhere we can **substitute**.
* Finally we will write **final state** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b43e332-7d08-4059-8127-507d0fd46160)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec6335f3-e120-429d-be2e-27f144d08a72)

* [**IMPORTANT**]

* Between two people, loops means **one person** is using **other person**.
* They are both using each other.
* We can substitute anywhere.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a9b3b75-9b51-4f3b-a293-00130fde0a5a)

* **NOTE**:-
* (a * r) ^ * = a * ((r * a) ^ *) [**IMPORTANT**]
* Between two people, **loop** is there, where we will manage the **loop**?

> Anywhere. No need to manage both the side. Manage anyone of the sides. We can manage wherever we like.

* Manage the loop anyside.
* No need to apply **both the side**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e81f640-22e0-4a55-894c-2e659299c8a5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0eb5040-fa62-4ab8-b9e8-3c39a5b4c796)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4fa981be-0e31-4c1c-9e8e-37c3cc9a0caa)

* **1.0** is **not equal** to **0.1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93dd38af-eb57-46b0-bd83-1abcc517b3c1)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36525644-89ea-4561-b977-01017188ef9a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ae34335-d5fc-48c5-af47-90b7fc6c46c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1178f073-c0a4-4031-9b98-c875dcac7932)

* **+** is **'or' operator**. [**IMPORTANT**]

## State Elimination Method

* No algo, nothing there.
* For **GATE** exam purpose it is **created**.

* Our goal is in any method when writing regular expression, our goal is to go from **starting** to **final** state.
* We will start from starting and go to **final** state.
* From starting to **final** state, is our goal.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ea4bbf8-e668-4d3e-b93c-dd5258ec80d6)

* We eliminated the state, **s2**.
* For the given diagram, if we apply **arden's method**, we will get the **answer**.
* So, finally **regular expression** is **ab**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8fdc8de3-be55-4ca0-bd4f-72ba36daed7f)

* [**IMPORTANT**]
* If we see this type of **diagram** then use this **method** and remove the **states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d925cb83-5405-460f-9bcb-1bd6e2de8b72)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23ac49a7-622e-4c91-a791-a73a0741ec6d)

* [**IMPORTANT**]
* Our target here is **regular expression** and not **constructing DFA**.
* We are eliminating **states** one by one.
* In the **first problem**, **two edges** are there and they are **one after another**. It means we have to do **concatenation**. [**IMPORTANT*
* In the **second problem**, **two edges** are there and they are not **one after another**. They are going at a time. It means we have to do **'OR' operator**. [**IMPORTANT**]
* We are not creating **finite automata**.
* To get the **regular expression**, we are compressing the diagram, **one by one**.
* We are eliminating unnecessary things, **one by one**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de2f55f4-6810-473a-854a-558760c3c9a8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef5256d1-2c79-4db2-ac0e-6cf396e09abf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a2bfaa5-9d79-42f9-a3ae-350224655e32)

* [**IMPORTANT**]
* After minimizing the diagram then we can apply the **arden's method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63b32c91-c121-4daf-af69-37b2135765c4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d09a20af-dbb2-47f9-adcf-5b7c8d96d8ea)

* Because of the **loop**, **(c ^ * )** came.
* After **a** and before **b**, **loop** can happen.
* [**IMPORTANT**]
* We are eliminating, one by one states.
* Given automata, we are compresing state-wise.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a2a417d-9f37-469a-8e7d-62aa71f6f3c8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/387155e4-4e7d-4f41-949b-b37d9fcd87e1)

* We can apply the method on **all** which is **NFA, DFA and epsilon-NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f42da357-0583-4b57-9c56-7cdcbc0c2c80)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3b448671-f701-48fe-87df-147a946de6a3)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d001d56-207f-45a4-9655-e045c01ea543)

* Because of so many **final states** which is confusing, we will take one more **final state** which is **S9** and we will make them as **non-final states** by joining them to **S9** using **epsilon**.
* Now, we have **one final state** which is **s9**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/69fca6ef-171a-4e10-a00a-9084ba7f4042)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4e9f52b-57f0-4fcd-8953-8fddbffe922f)

* From **S4 to S9**, we can write them as **(e + f + g + h)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dfd17f1c-82ce-4005-b96d-299f15ecfca5)

* From starting to **S4** we can come by either **'ac' or 'bd'**.
* By any one of these, we can come.
* After **S4**, we got **(e + f + g + h)**.
* Make sure to give **brackets**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/296aa727-4b8c-4da6-b52c-26366dbb3d09)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6764de44-9193-4ec4-a371-6e66b2890f99)

* [**IMPORTANT**]
* More states are there then apply the **above algo/method**.
* Less states are there then apply the **arden's algo/method**.
* More states and they are complex, then first make the more states as less states and then apply **arden's algo/method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/742e9572-6cfc-4c7f-bcfd-f192c2a103e9)

## closure-properties-ii(22) [12th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5504db2d-158c-4922-9215-cc1e322aae60)

* Example.
* At **B** there are **two loops**. One loop is **ba** and one is **c**.
* Between **A and B**, there are **two loops**.
* We want to manage both the **loops** at **B** only.
* First of all, from starting state, go to **B**.
* We have **two loops** at **B** and we will manage the **two loops** at **B** by writing them as **((ba + c) ^ * )**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0c5fb59-2575-4fc1-92fb-1b7192e8cd34)

* Minimal string -> ad.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d85c2e19-a2d4-4794-8c3b-c51bf9dbc3f5)

* Between **A and B**, there is **one loop** and we can manage the loop at **A**.
* Inbetween **c** may come as **c** is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/888e647f-cec9-462b-a43a-29e5a6da9f04)

* At **A**, only one loop is there which is **ab**.
* After **a**, **(c ^ * )** may come and afterwards **(b ^ * )**.
* While going inbetween **c** may come. So **(c ^ * )**.
* **c** loop is at **B**.
* After going from **A** to **B**, inbetween **c** can come, that's why **(c ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/337ee15b-bfba-4596-900f-10f20e62379a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7dfa9127-b7ac-426e-85bd-3be35fa5ed98)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b41540c-e660-4197-86f4-bef67b294ae1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c7b5aa56-28be-44db-adbe-4ec9f2dc74e8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82dd052a-5f98-43cf-83ec-19a56c6b77f5)

* On the way **(c ^ * )** is coming take.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ea86562-d73f-4322-8599-cbbf53643cf9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34fa89d2-894b-42c8-b411-5fb50d14fb09)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/389c8716-7c81-465f-9730-7206f8cbc578)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97c8d02e-ee40-4bc5-ab3a-ecca06b40f23)

* At **S1**, we have **two** loops, which are **b and c**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2145db8e-c890-4578-b6af-67ccbabf47a0)

* (a ^ *) * (b ^ *) -> a's followed by b's only possible.
* We are unnecessarily giving order.
* Only two loops are there. We cannot separate them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f651dee-026d-4af1-9853-fbf068ed32ce)

* At one place, **two loops** are there, don't write them **separately**. Keep both of them in a **loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3518d696-9119-4a81-9874-8a3353e41182)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66566e08-be86-4c16-b8fe-a957923edac8)

* One person having **many loops** so keep **everything** at that place only. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b2cca222-f083-4129-aaeb-3369930892c8)

* At **B**, two loops are there, which are **ba and c**.
* They can come in **any order** for any no. of times.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ce4ad08-7411-42da-bf4f-872b9af7ada3)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6556e969-b061-43e0-8b8e-0478b19df87b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5d0f3a5-e48f-467d-acc4-18db65110c16)

* They are **same**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae01a8fb-b3e0-4927-801c-6eeb912d5ed0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cc28e90-c9d5-485a-a22c-96bc4a31965f)

* Some of the other possibilities given in options.
* They are all **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea72c03e-4235-49f2-a193-bbd343b43bfe)

* Example.
* We have **three** loops.
* One loop is at **S1**, one loop at **s2** and one loop common between **S1 and S2**.
* We want to manage the **common loop** at **S1**.
* One loop is at **S1** which is **b**.
* The common loop is **a * (a ^ * ) * b**.
* Two loops at **S1**.
* After all loops are over, we have to go to **S2** as it is the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b9a7afa-ffd5-4e8b-b46b-a3cf34761169)

* Managing the **common loop** at **S1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df0923f7-819e-4309-bd7e-eb47e3544f2e)

* Managing the **common loop** at **S2**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ceca233e-44d4-435d-9a70-fbccb686f4e0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34eceb4f-496f-44ed-a1ee-04c11153c06b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e2070d8-6ca7-45a5-8433-48144c88e12d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf6c1a16-a144-484d-9063-5a0db5cbfc60)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2a1d0a93-c1d0-436f-b626-8c8dd1f302ec)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5f2f561-4db4-42ca-8aa7-3dc99e7af2ee)

* Example
* At **S1**, there are **3** loops.
* As we didn't have any **final states** at **S4**, so we removed **S4** state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae6e815b-c460-4002-9c8a-dc9acb5647c8)

* After all loops are over, we are at **S1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfca70fa-29e6-43aa-b242-13d6b58d5999)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2bda565b-5a97-4e02-b17c-d88c598d194a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd5703b0-2c47-4103-8bf0-416a7b10d8c8)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4d7900f-f2bf-489f-bbba-19736ba7da88)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/43733fe7-38da-4b4d-b128-ff1a82ab281f)

* Example
* Who are going from **S1** to outside there is **no change** of them going back to **S1**.
* So **only one loop** at **S1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d826d459-490a-43f7-b40c-94bf58b45a37)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c34eb45f-4473-4db4-b359-bb4a05181412)

* That is not **e**, that is **epsilon**.
* So instead of **feg**, we have **f * (epsilon) * g -> f * g -> fg**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d70d882a-385c-4970-b02e-0af0faeed2e6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfb4d927-0107-47f8-bddf-0a6dffe9f110)

* [**IMPORTANT**]
* Starting to ending we want to go, that is **our goal**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3dfcad97-2729-44d2-ac6e-8b3fe436762b)

* **Ignore** that path.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36ed843c-7f2a-4469-9066-20c47828558b)

* If any thing looks like a **dead state**, then we will **not consider** that path.
* If any path looks like a **dead state**, simply ignore it. It cannot contribute to the **language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bd1e4f8d-ad76-407a-b776-72ff7614ae2c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/90657b8a-d56f-4718-a970-426e4108187b)

* Example.
* No state is **dead state**.
* No state is **unrecheable state**.
* All states are participating.
* In **S1** we have **two loops**, they are leaving **S1** and are coming back to **S1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07a8e4de-8c80-4e66-9239-649ce5e8c556)

* After both loops are over, we are at **S1**.
* We don't want to stay at **S1**, we want to go to **final state**, which is **S4**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbd4c907-ba26-4adf-b20e-8dcfd492dd80)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b6565d3-5ece-4c71-9c42-3da5fdb54285)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/52360e11-4bcf-4d21-a59c-c65c4765c8b2)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66a1284d-e24b-4526-82a5-9d23f7418965)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a88d6b6-12e9-43a8-b742-d8d9eae363b6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/616920b5-780f-43b4-aae7-ee70af6e34eb)

* Example.
* No loop at **S1**.
* Between **S2** and **S3** there is a **loop**.
* To reach **S2**, one way is **a** and another way is **b**.
* Paths to reach **S2** -> (a + b * (a ^ * ) * b.
* By taking one of the paths, we are now at **S2**.
* We did th loop on **S2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83e7fc77-d0e2-4d5f-817f-9948186105d2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/085ee946-e10e-4273-bec4-059d7f15d114)

* [**IMPORTANT**]
* Give importance to those states which are on the way to the **final state**. 
* We are managing the loop on **S2** as **S2** state is on the way to the **final state**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc28d641-7da0-407c-b751-8675eb138328)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05cf9a5a-c264-4aa0-a4ba-b432525e8ac3)

* After **bb** we are at **S2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17aa29b9-84f1-4b6e-b6e6-b70e573b44c4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ef80ba4-22c2-48af-a1c8-3ebccc03680d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8c459c1-ebde-420a-8b07-16ec21784ec7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/856be65c-650b-40a2-b1e1-be9b887a44be)

* Two ways we can go to **S3** is by **b and aa**.
* We are trying to keep the loop between **S2 and S3** at **S3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/afc2b703-276b-42d0-b4a0-ac3a52172aeb)

* Starting with **a**, we will get **aa** followed by **bb** which is **aabb**.
* We want **ab**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1f09de8-c292-4a6c-8ae0-a314cf173a58)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5d4d730-42a2-45df-9095-9a52dadfe282)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de90c42e-3115-4b70-a19e-3fb2aa59d6d8)

* [**IMPORTANT**]

## cfg-and-pda-i (23) [13th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f49c2b8b-33b5-4beb-bfd3-1de9471ce137)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecdab918-8d8c-4348-acf2-61f069edb135)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2bc891a-4a96-4715-9acd-1c8e345b4bb0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f96db4c6-98d9-4999-a733-58c888c1f909)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56b98360-4e9a-4429-95bf-91dd0b2aa0d4)

* [**IMPORTANT**]
* Last class's problem.

* **STEPS**:-

1) First do **manual checking**. Checking first minimal string, second minimal string. Verify 3-4 strings.
2) Apply State elimination method.
3) Apply Arden's method.
4) Combine State elimination method and Arden's method. If possible **minimize**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee687c10-49af-4228-82be-5e20ecfd46e9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/52ec5a2e-1864-4520-b66a-d2f6653d4460)

* Example.
* Starting state is **S1** and **final state** is also **S1**.
* After **two** loops are over, we are at **S1** only.
* We want to be at **S1** only as it is the **final state**.
* So **stop it**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb8bd833-acd7-4edd-9777-f73909430f5b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4c68dd4-d4db-45fd-aac4-c071fc2e8126)

* [**IMPORTANT**]
* Minimal string -> Epsilon
* Next minimal string -> a.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b914a14c-94ee-48af-a38d-1a91663a675a)

* Example.
* **S1** is the **starting** as well as the **final state**.
* Other than **a**, if we go outside of **S1** then the rest of the states are **dead states**.
* So **S2 and S3** are **dead states**.
* Before starting the procedure eliminate the **dead states** first. Also delete the **unrecheable** states.
* We have **(a ^ * )** which is **left**, which is the **remaining diagram**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97da3e27-1a58-4d86-8646-d0257e8fe1cd)

* We cannot write **one loop** as **two loops**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f634e4b-1372-41f1-882d-d25c68aad044)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ad84b62-0cbe-41ee-a3d5-5948052123d3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f707a2d-eabf-4cee-aa0a-5c4d5c9af5de)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2eeadb7f-30e3-4dd1-b716-51a3cd043ec1)

* When **multiple loops** are there always loop at the above diagram, it will give **clarity**.
* Don't forget **basic models**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ddc72543-3e9d-4c66-a428-a938807e2375)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a92eeb20-e781-4fb9-ad4c-ce978b36ce3a)

* Example.
* Some portion is **common** which we can take.
* Not only **a and b** , position also matters.
* In **automata**, not only **common string** but position also matters.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19600d26-9fe3-4f47-96c3-efe6151419de)

* Because of **concatenation** we cannot go wherever we want.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9a92d73c-3bd0-4671-9677-9a663161c5d9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9a0283a-13b8-4b2d-a93f-e19bf30f627c)

* If we want to take **common** then **ab** should be present in **both**. **ab** is there in **both**.
* Where it should be **common**?

> Either **starting** or **ending** then only we can take/make **common**. We cannot take wherever we want. Some limitations are there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f21b79c8-82aa-490c-9a58-3b73263d9363)

* Meaning should be **same**.
* **Starting or ending** should be **common**.
* It is normal mathematics.
* Means are changing.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/332832d6-c388-470a-ab50-2bc7b3ffa926)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff8f6321-aa7b-48a4-9778-103f42a39c6f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/03647ba1-4901-4f09-b3e8-16092a42775a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b65c3e0b-ed5e-48d3-866a-69a08af939a2)

* [**IMPORTANT**]
* The string is changed.
* **ab** is at the middle of the string but we kept **ab** at the **beginning**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88a6a59f-b98b-4dbd-8ee7-da5f5232795d)

* Answer -> Set of all even length strings.
* Right side we made common.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10139c95-a9b5-46cb-a339-5f41b9dc658a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c604f885-7d87-4109-b7b4-342560bec819)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3b8becc1-5631-429d-bd49-c0819e63ef08)

* At **S1**, we have **three** loops.
* There is a loop between **S1 and S2** which is **10**. We kept it at **S1**.
* **S3** is having **two** loops.
* There is a loop between **S2 and S3** which is **10**. We kept it at **S3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3f51984-af92-4228-a478-75df17c41041)

* **S1** is having **three** loops now.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63b8e98c-6208-48a6-ab2b-331d3b2abef8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7bcdde4-cc88-4013-aac4-8d5d00c245dd)

* After all of the **three loops**, we are at **S1** now.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d354343-8110-462d-922e-cfbd508b124a)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cdee4fd-cae1-46c1-9483-5c69cc3a56b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa230300-9e19-484c-a390-d3351fcf6d7b)

* 5 times **10**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0d55935-1b67-46f5-817a-acf7a3dfee01)

* yes, possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dcce685-1137-4850-aa2d-3e841bc7f0cd)

* Between **S1 and S3** there is a **common** loop, we kept the **common loop** at **S1**. We can keep it at **S3** also.
 
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1aea1435-10f0-4a3c-859d-6626069e3054)

* Use **Common Sense**.
* Starting to final how to go -> **GOAL**.

## Regular Expression to Fininte Automata

* Reverse of the previous problems
* (a + b) -> **a** or **b**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7fb12c6-103a-4e7b-b532-a62f967b298e)

* [**IMPORTANT**]
* One language is there which is **regular**, so it's **regular expression** is **possible**.
* **a** is **one language** and it's **regular expression** is **r1**.
* **b** is **another language** and it's **regular expression** is **r2**.
* If **r1** is **regular** and **r2** is also **regular** then **(r1 + r2)** is also **regular**.
* As **finite automata** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/554d904f-4859-4e52-af86-df6e25cceb36)

* yes.
* One langauge is there which is a **regular language** then it's **regular expression** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a672ac67-f7a5-40cd-b761-6d50d39a5104)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a5c59776-b126-4429-af79-d6da171c9e83)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a45c9be-fde3-4e06-9e15-6d1297b12b6a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fa528c82-a5fb-4a91-b34e-94fe63e8d162)

* Combines one is **(r1 + r2)**.
* If **r1** is **regular** and **r2** is also **regular** then **(r1 + r2)** is always **regular**.
* **r1** is **regular** means that finite automata is possible.
* **r2** is **regular** means that finite automata is possible.
* **(r1 + r2)** is also **regular** because finite automata is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dcb264a-e5c0-4ea6-affd-e7905bfc3f0f)

* Automata is accepting **r1**.
* Automata is accepting **r2**.

* **STEPS**:- [**IMPORTANT**]

1) Take both the diagrams.
2) Add one common final and one common initial state. Connect using **epsilons**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39f4c14a-8d80-4122-b3be-6be963134548)

* It is accepting **(r1 + r2)**.
* If **r1** is **regular** and **finite automata** is available.
* If **r2** is also **regular** and **finite automata** is available.
* Then, **(r1 + r2)** is also **regular** because **finite automata** is available.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dda34624-2ec1-4dc7-88af-3bb12b0c4117)

* [**IMPORTANT**]
* It is **Epsilon-NFA**.
* **Epsilon-NFA** to **DFA** and **Epsilon-NFA** to **NFA**, both are possible.
* **r1** is **finite automata** and **r2** is **finite automata**, **(r1 + r2)**, how to get?

> Above solution.

* If **r1** is **regular** and **r2** is also **regular** then what about **(r1 + r2)**?

> It is also **regular** because **finite automata** is available.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13284836-6c17-4f3f-b80d-0510e10f88c2)

* Both the **finite automata** connect like the **above diagram** with the help of **Epsilons**.

* If **r1** is **regular** then **finite automata** is available.
* If **r2** is **regular** then **finite automata** is available.
* What about **(r1 * r2)**? [Concatenation]

* **(r1 * r2)**, **r1** Concatenation **r2** means that **r1** is followed by **r2**.
* Both should go in **one direction** only but **one after another**.
* In **Concatenation**, **order** is important.
* **r1** followed by **r2**, so **r1** is the **first one**.
* So take **r1's** initial state.
* **r2** is the last one. So, take the **final state of 'r2'**.
* Conncet both using **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25d457a8-4fbc-4e8d-9fc4-77b3cac3a9c0)

* **(r1 * r2)** [**IMPORTANT**]
* **r1** followed by **r2** means that **r1** is **starting** and **r2** is **ending**.
* Take the **Ending diagram's** final state and the **starting diagram's** initial state.
* Conncet both using **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fc0294c-6be6-48f6-8899-3e3c7a125a83)

* If **r1** is **regular** then **finite automata** is available and **r2** is **regular** then  **finite automata** is available.
* **(r1 * r2)** means that **r1** followed by **r2**.
* Both should go in **one direction** only, **one after another**.
* In **Concatenation**, **order** is important.
* **r1** followed by **r2**, so **r1** is the **first one**.
* So take **r1's** initial state.
* **r2** is the last one. So, take the **final state as 'r2'**.
* Conncet both using **Epsilon**.
* This is **(r1 * r2)**.
* **r1** followed by **r2** means that **r1** is **starting** and **r2** is **ending**.
* Take the **Ending diagram's** final state and the **starting diagram's** initial state.
* Conncet both using **Epsilon**.
* If **r1** is **regular** and **r2** is **regular** then **(r1 * r2)** is also **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/550a3672-59fb-475c-84d0-65791de0711c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d00c7876-6386-4d95-a3a9-5f5da48f7855)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d7b2267-44a3-437a-a82e-e315751528e0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cba5f179-f245-4180-9df1-ce2e9cc5dd05)

* **Two** final states we have, which are **S2 and S4**.
* **S4** is the **final-final state**.
* **Two** initial states we have, which are **S1 and S3**.
* **S1** is the **initial-initial state**.
* **r1's initial state** take as **initial state** and **r2's final state** take as **final state** of **(r1 * r2)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1afb874-1521-4aa6-b799-7950852743b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8901eb0c-7103-485a-a18a-2fd854afb85b)

* Connect with the help of **epsilons**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10445cbd-d0e9-432e-8ff0-8f0784562d63)

* We are not bothered about **decreasing** the **no. of states**.
* Automatically convertions are there.
* Goal is **finite automata** possible or not.
* Writing the **finite automata** of **Epsilon-NFA** is easier.
* If **r1** is **regular** and **r2** is **regular** then **(r1 * r2)** is also **regular**.
* If we change the **order** then they are **different** languages.
* **(r1 * r2)** will be **different**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76f39b30-98cd-410a-8158-6735317a8b5c)

* **(r1 * r2)**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3712b18-d5a4-49f7-968c-47ca1d2e16c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ceb2802-faf8-4189-875c-d78423effd87)

* **r1** is **regular**, so **finite automata** is available.
* We can go from **starting to final** by reading **r1**.
* The **automata** we have constructed is accepting **r1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4fec1403-5e04-4b7c-a79d-0284235bea6d)

* **(r ^ * )**
* Minimal string -> Epsilon, r1, r1r1, r1r1r1, .....
* If we want **(r ^ * )** then **Epsilon** should be **accepted**.
* Take **one state before** and **one state after**.
* **Before** is **starting state** and **last one** is **final state**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/daa46ba5-fbd8-4ba5-8b29-dfe253b3edb2)

* We want to accept **epsilon** so from **initial to final** state draw a **transition line** with **epsilon** on it, like **below**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9861e777-ec32-4283-a2a2-3b3ea08f332c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf5a5642-c09d-450a-abdc-659fa6a5e6ae)

* **r1** should also be **accepted**.
* With the help of **epsilon**, connect **r1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8346804f-4bcc-4452-8b22-e5f84f76e671)

* **Epsilon and r1** are  **accepted**.
* **r1** is many no. of times.
* Come back **epsilon** like below.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c402a8f0-ff90-4ff3-bac4-b9e1be025a08)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3f8ff5a7-17cf-489f-9e53-df9b3ee8841a)

* If **r1** is **regular** then **(r ^ * )** is also **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93bb622e-100a-4a64-b37f-342219af847c)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecf45414-728f-42cb-bac6-0d7702f9899a)

* For both of the machine by keeping the **white colored edge**, it became **concatenation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ba304612-526a-430f-8499-39b6102a9c22)

* For both of the machine by keeping the **white colored things**, it became **union**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80223388-8991-4a0a-82d5-a5ca0979fa47)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9045fc98-98c8-4672-a4ad-4fe428b41108)

## doubt-clearing-session(24) [15th Sept 2023]

* Draw **FA** to the **RE** for **(0 * (1 ^ * ) + 1)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b6cf20c-5fae-4d5d-8016-f6ba1aebed3d)

* Union(+), dot(.) or concatenation and star(*) operator, which has the highest priority?

> **star(*)** operator -> Highest.

* **dot(.) or concatenation** operator -> Second highest.
* **Union(+)** operator -> Lowest.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a28e35dc-bb39-404e-b582-4bd4ed175a94)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1f04319-6ebc-4a97-a4e5-847568ee0bd4)

* By default, **bracket** have the **highest priority**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ffef45c2-4636-4b98-b02e-70843b34745d)

* Example.
* Who can fight or who are the fighting people?

> **Neighours**.

* **Neighours** only can always fight.
* The automata accepts **minimal** as **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11035bd0-5d8f-4693-9839-d1e7a786257e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c4b642f-78ac-418d-b342-70171bf97d3f)

* If we can construct **finite automata** then it is a **regular expresssion**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ec5dd86-4d57-4bf6-a1bc-0bf4fa3d536c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8d9a6ec-0121-404c-b20f-baa774c05fca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/681293ac-3d01-4e6e-b67e-58bb97dbf11f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7c21a50-8e70-407f-9c5a-62642f27193b)

* [**IMPORTANT**]
* We got the meaning, don't worry about the **States**.
* Automatically ***min. no. of states** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac4919c1-8ed0-4fbd-9e68-081868573b8c)

* **Brackets** are having the **highest** priority.
* **Two brackets** are there, **left and right** side brackets.
* **Left bracket** is **highest** priority as it came **first**.
* So, the **Left bracket** is done **first**.
* **Star(*)** and **dot(.)** are neighbours.
* Between **Star(*)** and **dot(.)**, **Star(*)** is the winner.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bbf7898b-5507-4d48-be6b-e7fb2a4701e6)

* If we want to do **union** then both the things are **required**.
* **11** we have done.
* **(11 + 0)** is **union**.
* For **union**, we have to do **commomn final and initial** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/611b4ffb-1a96-4cee-b821-e14d6b1517d3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7eb02475-b18a-4ac9-bd00-3670dcb3c8a1)

* We now have **(11 + 0)** using **union**.
* This is **R1**.
* How to do **(R1 ^ * )**?

> One state before and one state after.

* With the help of **epsilon** connect the states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/401fa646-a954-49ea-a4af-efdf1a8b695b)

* Exactly same template
* We don't worry about **no. of states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f112e226-eb6a-458e-8247-52eca6b9fc8b)

* **(11)** or **(1.1)** is **concatenation**.
* After this is over, next star will **start**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef56f345-c74d-4c81-83cf-a725c6d9d60b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/58e74b38-e51f-42d8-8b8a-5f8f8561e1af)

* **(00 + 1)** is completed.
* Making it **whole star(*)**, below.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2718fd72-e1d4-4d26-86fc-5427748b491f)

* [**IMORTANT**]
* We can do **concatenation** and in **concatenation**, **order** is **important**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e20243bc-2a39-4a18-8110-00a7a90e8079)

* **Final state** keeps on shifting.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ca77bcc-4789-4c47-928d-1cd95eb91efc)

* [**IMORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/132fbf27-5053-45ab-8d2d-7320e0a92ff8)

* Example.
* We have **two** brackets.
* So, we have to do the **left bracket** first.
* Do **union** operator between **1, 01 and 001**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e3565050-99d4-4f51-b435-6c2f7e2bedac)

* This is **(1 + 01 + 001)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e0e1b80-9e67-4388-8535-739e13cf9b97)

* This is **((1 + 01 + 001) ^ * )**.
* In this method, **problems** are **only states**.
* First bracket, whole star(*) completed. After that we have a **dot(.)**.
* After **First bracket** is over, we should go to the **second bracket**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/882be0e5-6587-4d86-b3fc-67bc84e740cc)

* Both are available, we can do **concatenation** now.
* After **concatenation**, we got the **total diagram**.
* As the **total diagram** is over, **last state** is the **final state** and the **first state** is the **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d1b0675-c549-4df1-8019-d9b6662d2fa2)

* **Total diagram**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/701b3160-c71a-4f92-bf52-0a5485b46a90)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a56e4736-dea6-4cae-8f7c-f5040edb8ddb)

* In the **third** expression, we have **three brackets**. We have to do the **left bracket** first.
* **Left bracket** has **01 + 10** which means that it has **two** diagrams internally.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/672e98db-04e9-4a33-ac57-2ebbe8443c27)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e796cac2-7403-4c38-b93f-3378967bc975)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/91d95ea2-c820-4e32-8063-2a45c91eae34)

* All of the **three expressions** are completed individually.
* Now we can do the **OR operation(+) or union**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/990ab9b0-95ee-49ce-9e52-d3e13cca0783)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88e7d2e0-db41-438b-b4e0-4a0d2b9d6d57)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b7744885-3bc6-4906-8c93-1cf91e2e16f2)

* Union.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17fcfa9a-a125-45fb-98b2-8a88c85b038b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/702954e7-c728-4494-a302-811d8c1868ab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83aef96e-ab47-41cf-b4e8-1c0e2fb7e57e)

* Bring the kleen closure template. [**IMPORTANT**]

### Second Method, Method 2.

* From **starting state** to **final state** we want to go by reading **(0 * (1 ^ *) + 1)**.
* For **one purpose**, **star(*) and plus(+)** are fighting. Who is the winner?

> **star(*)** is the winner.

* **star(*)** will go with **1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75b21792-b40e-44e1-9193-a022805f43bc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b8b42e6f-f407-4d21-bb15-5cf0e417dab9)

* We will go from **starting state** to **final state** by either reading **(0 * (1 ^ * ))** or by reading **1**.
* For the **1**, two people are fighting, who are **star(*) and **dot(.)**.
* **star(*)** is the winner.
* **star(*)** will go with **1** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7277e8af-78ae-4f4b-88f0-52107665c5cd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dd0666fa-35db-420e-a4da-b10acf056986)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d5dd19f-9ed6-4ffb-af9a-12db5ccf73c4)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/58fb6782-fb56-40cd-8908-4aeb398b6f0b)

* We have **(1 ^ * )**.
* Whenever there is a **star(*)**, to make it simple, take **one new state** and keep **epsilons** on the **transition** lines and do the **self-loop** for the **star(*)** on the **new state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc22d7c2-ca13-4544-b144-30bdc140cffc)

* [**IMPORTANT**]
* Compared to the **previous problem**, these **method** has **very less states**.
* In these method, whenever **stars(*)** will come then only **two epsilons** will come.
* In other places **no epsilon**.
* To make it **simple**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1805642c-9808-4f29-9dbe-9df416a03a4c)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc6b6472-7f8c-426d-b39b-dc4fe0dad5c0)

* **FA to RE**, it is **State elimination** method. **Bottom to top** is **state elimination** method(SEM).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/979da0db-a536-4e91-8a61-18e7ab68c30c)

* **RE to FA**, it is **top to bottom**. States expansion.
* Both are **similar**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a9a0221-027d-4a33-b372-e37dea699ba5)

* Example
* In-between **concatenation** is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/897492d9-607e-43ca-9557-255808e9ecc9)

* We have **whole star**.
* Whenever **whole star** came take **one new state** inbetween and **add 'epsilons' before and after**. To the **new state**, keep the **self loop** for the **whole star**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ef8cf52-bf59-4cd6-b791-553bfcf4fb3e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/125d3f89-3b06-4947-b5de-9f694af0849c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/914015f2-914b-4cee-8e7b-17055ef903bf)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dddbfb04-35d4-44a7-882e-92a6ad92ad26)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fd59f08-ea45-459f-b325-5d0a02397216)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec653e64-b937-4fbe-96b1-1daa4358b2b1)

* We are creating **finite automata**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e4f2639-a0ca-4dee-8f3a-300df4b13af3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/453b1437-a490-409c-b19e-dfc91b8b6db7)

* Example
* As we have **whole star(*)** so one new state will come in-between.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f0102a6-5a12-4a5e-b1f7-7ffd8e128de2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ccf22c7-7717-452d-9282-631ccbcd5b5a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5fe6a5a-566b-491d-9523-61fbbad0652b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37ddcc16-5901-4124-a805-86756ec65e04)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6e98064-2377-49fa-81cc-f1566e33bded)

* Meaningfully expand.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f968acb-c6a9-481d-b7cf-2e0c58e3855b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/373cc193-8071-4450-a2f7-9b9b5f227870)

### Construct Epsilon-Free NFA.

* **NFA** means both will come, **Epsilon-Free NFA** and **Epsilon-NFA**.
* Construct Epsilon-Free NFA for the **regular expression**:-
* r = ((a + b) ^ * ) * (aa + bb) * (a + b) ^ *.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66aab381-a846-4cdd-8697-73edc4f039be)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cb91467-733b-46cf-a4c0-010fa6042562)

* Without **loop**, write first.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09638d03-b1c2-4601-b967-1051051596cb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a30cb86a-21d4-40e5-823e-04c085765689)

* Try **minimal** thing **first**.
* This is **NFA**.
* Don't worry about the **loops**.
* Without **loop** try.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9655c7bf-d512-457d-b0ee-f833ab32aa73)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6d059b4-2e3b-41f6-a4a5-aa15fe12cfb2)

* Next class.

## cfg-and-pda-ii (25) [16th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4c532654-8a01-414e-a8c3-aca53982e0c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc1ba056-9d98-4817-b04f-88e402b756a9)

* Give **last importance** to **loops**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f764f00f-3bec-47a3-a845-5a4f0569f061)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/28ac29d1-b001-48d3-a407-d8d66fdfb21d)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/189c253c-0982-4f5b-8775-bd302881d2e8)

* If we keep the **(1 ^ * )** on the **final state** then problems will come.
* We have to take **one new state** to keep the **self-loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9592e9c-fec5-4f2b-b3c0-e4601846bbd6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e934acfe-e9c6-4bbc-a13c-59ebfe7e84f1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d897c9d-6db6-4920-b0b3-edea7bc0a6d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6afacf02-fd09-41a2-87fc-b5c8855d335d)

* This is like **(A ^ * ) * (B ^ * )**.
* This is not **((A + B) ^ * )**.
* Don't keep to the **same** states, different states we have to go. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e309f3ce-f2da-4bb7-b2f0-bd61da5578cf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5119e6d5-cab0-4efa-9b61-935f3dc317cb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f0ae559-8122-43d8-badd-1ca71145f975)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7f3c290-54d8-4220-ae48-a8fa33d7a32a)

* Many ways we can do.
* If we don't want to use **epsilon**, write **minimal thing first** and then go to **final state**.
* We decided that **((0 + 11) ^ * )** should be on the **starting state**.
* We decided that **((1 + 00) ^ * )** should be on the **last state**.
* We have to go to **final state** by reading **minimal thing** as **epsilon** is not allowed.
* **Epsilon-NFA** is easy.
* Directly doing **Epsilon-free-NFA** is a bit difficult.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07ebb08d-493e-4f7a-9560-e89361d2c677)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/975aeefc-47ce-45dd-99d9-f74f9fc7755c)

* This is the possible mistake we can do while solving this type of problem.
* **Order** is important.
* **Order** important and **Epsilon-NFA** is easy.
* Keep **Epsilon** between whichever **order** is important.
* Try one thing before **epsilon** and try another thing after **epsilon**.
* For **Epsilon-free-NFA** then we need the **minimal things**.
* **((0 + 11) ^ * )** should be at the **starting state**.
* **((1 + 00) ^ * )** should be on the **last state**.
* To go from **starting to ending state**, we have to read something, we cannot read **epsilon**, so we are reading **minimal things**.
* The **minimal** is either **1** or **00**.
* Starting loop manage at the **starting state**, intermediate loop manage at the **intermediate state** and final loop manage at the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d49bea69-1cc1-4b81-9bd3-d556618204af)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/942b54be-8860-4d76-bb5a-78ccd876e98d)

* Conversions we have done.

## Finite Automata with Output

1) Moore Machine
2) Mealy Machine

* They will produce the output.

### Finite Automata without Output:-

1) NFA
2) DFA

* They will accept or reject the strings.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97c9652a-d04c-4f4d-afdb-9dd08e377565)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59ecf374-7d48-4ac8-8422-2e53ebb3c229)

* If we have **moore machine** we can convert the **mealey** machine.
* Conversion possible.
* Construct moore machine that count no. of occurences of substring 'ab' in the given string of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad45d761-457f-4fad-82ed-fa83ed77bb72)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7988ba93-ecf4-4985-b513-d4312c44a8c7)

* To get atleast single '1', we need one substring of 'ab' in the string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ada891e-2c2c-4211-b850-6b1bfde833c5)

* From the **starting state**, **s1**, if we go to **s3** then **ab** is over.
* From the **starting state**, if we read **ab** then we are at **s1**.
* We are at **s3** means that we have already seen **ab**, **one time**.
* As we have seen **ab**, **one time**, so produce **output** as **1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e821377-ecd3-43fe-8299-9a3b0ef28296)

* We are at **s1** means **ab** is not completed and afterwards it will come.
* We are at **s2** means **ab** is not completed and afterwards it will come.
* If **ab** is over then we print **1** otherwise print **0**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ac310f6-cb68-4184-9e3d-b2f2820ac114)

* In **s3** state, the output is **1** as we have already seen **ab**. 
* In **S1 and S2** state, the output is **0** as we haven't seen **ab**.
* In **moore machine** the output is there **within the state only**.
* The state will decide.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2d62e57-23b6-4e44-93a7-a0337339c360)

* **Moore and mealey** machines both are **deterministic** in nature.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5bae177-95cd-48ee-93de-95ed1c2cb3d5)

* We are able to come to **S3**, for **two(2) times**.
* Two times are printed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13ad091d-d3a9-49bd-be17-6a405d822785)

* It is something like **DFA** construction but take care of the **output** also.
* For **S1** on **b**, there is **self-loop** as **ab** hasen't come and will come afterwards and then we will print **1**. Before that any no. of b's come, doesn't matter.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/14db2add-e00b-4cbc-a3e8-bbf0944f537e)

* In **S2**, already **a** is over and we are in the process of finding **ab**.
* After **a**, if **b** comes then we will print **1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d4291ff-342e-4f03-a150-7acb52cc4a36)

* For **S2** in **a**, we are keeping **self-loop** because **a** is over and we are in the process of finding out **ab**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50793e69-0fa3-4425-ae45-9c77ce7e8d9d)

* **DFA** construction only.
* We want **output** for everything, **no final state** required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b86c81ae-5f9c-42c4-80de-6a6f564b618e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0134b3f9-d01f-43f6-b50d-f811da23e96d)

* **Moore and mealey** machines are **output generators** means **no final state**.
* [**IMPORTANT**]

* **Mealy** machine will produce **output = 1** when **ab** comes **1**.
* When we come to **s2** then **a** is already over. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1e903cf2-aac3-430a-a5ec-46ff11d8f5d0)

* On **S2**, if **b** comes then go to **S1**.
* Now **ab** is over and we have printed **1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87782382-943a-4d32-b4a5-d21ced528ef3)

* If unfortunately **b** came then print **1** and go to **S1** because **one time** printing of **ab** over.
* **S1** means nothing is over, it is **starting state**.
* When nothing is over then **b's** are coming then keep **self-loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3567373-d081-4c89-a5f2-ca8f268bb591)

* 10 b's are on **S1** state then we print **0**. 
* 10 a's are on **S1** state then we print **0** as **one 'a'** is for going from **S1 to S2** and then rest a's are **self lopp** for **S2**. 
* For **ab** we are printing **1**.
* Don't worry about **no. of states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c830f771-0ee0-4f51-b5d7-9117db3b31cd)

* **S1** indicating **two things**, one is **nothing is over** and the second is that **ab** is over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d05956d5-1166-4825-b1d3-b7e4f8e5b3b1)

* Both are correct.

1) Moore and mealy are deterministic(like DFA)
2) No. of final states in moore and mealy machine are **zero(0)** because these are not language recognizers but they are **output** generators.

* In the **moore** machines, the **output** is within the **states**.
* In the **mealy** machines, the **output** is in the **transition lines**.

3) Lambda : Q -> Delta [Moore Machine]

* Delta -> Output alphabet
* Q -> State
* Lambda -> Output function.

* If we know **state** then we know the **output**.
* In case of **moore** machine if we know **state** then we know the **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae1ff3e0-5592-455e-8488-5d46a3635ba4)

* Sigma -> Input alphabet -> The symbols allowed to give **input**.
* Delta -> Output alphabet -> The symbols available to produce **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/157a8877-c7d1-4db3-a7d6-4a2ff0aa49a7)

* Input alphabet  -> a, b
* Output alphabet -> 0, 1

* If in the **moore** machine, we want to know as of now what is the **output**?

> Please check which **state** we are in.

* If we know **State** then we know the **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b39515f5-7752-4903-9de0-447b6ffff858)

* **Mealy** output is based on **states as well as input(symbol)** also. Both will decide.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1788219-5cc3-4f20-bcd9-ed5c0fc3f9a6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1400ad3e-0670-4570-9b06-df6ddad02c02)

* Both are **same**.
* Left is a **better diagram**.

* On **S2** state, **b**, the **output** is **1**.
* On **S2** state, **a**, the **output** is **0**.
* Not only **state** but the **input symbol** matters. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3480d2ab-c0d3-4ae3-9116-48babf9a15bd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ef6fffe-5280-4423-9477-056775687210)

* Which state we are in, what **input symbol** we applied, then accordingly **output** will come.
* [**IMPORTANT**]

4) Moore machine, **m** = (Q, Sigma, Phi, S, lambda, Delta)

* Q -> States
* Sigma -> Input alphabet
* Phi -> Transition Function
* S -> Starting state
* F -> Final state -> No final states in **moore machine**.
* Lambda -> Output function
* Delta -> Output Alphabet

* In place of **Final state(F)**, we got **Output functio(lambda) and Output Alphabet(Delta)**.
* Output is coming how?

> Check **point 3**, output function written there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df3f5b5f-c7b9-45b4-9c48-6ae96f52bd9b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f235f44b-a9d5-4e7c-b585-c91b9686badf)

* It doesn't matter what **input** we are giving.
* Delta -> Transition function
* Lambda -> output function
* This is for **normal** machines(FA).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/85cd777b-d566-4b3f-a996-c7b37a5dd77d)

* **Finite automata** is called as **5-tuple machine** because it has **5-values** are there.
* In **moore machine** we have **6-values**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e9445d54-b80b-4951-be42-9d5d70e832aa)

* The **difference** between **moore and mealy** machine is that the **output function**. How are we getting the **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c030fd30-a501-4348-a283-f76a1925dad6)

* In which of the machines, the output is based on the **current state** only?

> **Moore machine**.

* In which of the machines, the output is based on the **current state** as well as **current input symbol** also?

> **Mealy machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c377585-e139-4e78-890b-8bb63fa80538)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed90e41a-2f20-4c16-8e67-f7d150b50e04)

* Lambda -> Output function
* Delta -> Output alphabet.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec09e85b-7f4a-474a-9b9b-26830002bff1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4d6ebce-91c0-41d2-965c-e02326c59070)

* Input size is **8**.
* **States** will decide the **outouts**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0cdff942-4ed4-4a50-9183-bfdab155dd8e)

* Input length is **8** only but **output** length is **9**.
* Initial output did not came by **input**.
* Initial output came by **starting state** only.
* Because of **starting state** one extra output came.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cf50ba02-498f-4e92-8be5-ea52c3c4fb13)

* We got **three 1's** which means we have **three ab's** in the **input**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96589767-b278-408c-bedb-1961b3fbb88a)

* If we give, **input length** of **8** then we will get **output** length of **8 + 1 -> 9**. This is in **moore machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1965aa7-6f0b-4557-b132-ba988ad38ba6)

* **moore machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4f56aa2-3924-46cf-8428-ccd49ec91e17)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7592989-805f-44ae-967d-591d2c67d552)

* In **mealy** machine, whatever **length input** we give that **length output** only we get.
* We got **three 1's** in the **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b190949c-d5f7-449c-acee-f44b2d78686b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be20c0cc-a7dc-4c26-afca-63c2a89845e0)

5) In moore machine for **n-length input** string we will get **(n + 1)** length **output** string but in **mealy** machine we will get **n-length output** string only. 

* [**IMPORTANT**]

## cfg-and-pda-iii (26) [17th Sept 2023]

* Construct moore machine that accepts all strings of a's and b's as input and produces output '1'  if it's input ends with **aa** and produces output **0** if the input ends with **ab** and produces output **2** otherwise.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17f37180-8c6e-4607-9172-d7224a661223)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e3c5a9e4-f563-4b5c-9508-9b4a6dda29c0)

* **aa** -> 1
* **ab** -> 0
* **otherwise** -> 2

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/68e58a6f-0377-4e5d-b241-3763b3b4ef67)

* **Moore and mealy** are **deterministic** in nature.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/64dee5b5-c81a-48cf-966e-0bcb67e6a482)

* We have to cover remaining **possibilities** also.
* Our concentration is **ending**.
* **S3** means **ending** with **aa**.
* **S4** means **ending** with **ab**.
* **S3** means **ending** with **aa** but if we get another **a** then ending with **aa**. So for **a** on **S3**, we do **self-loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f124b37-d0b1-42b2-b65e-01268815ba87)

* **S3** means **ending** with **aa** but if we get **b** then ending with **ab**. So for **b** on **S3**, we go to **S4**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee6e1f55-c7a3-4886-ab9b-4bb77e5d5b7b)

* **S4** means **ending** with **ab** but if we get **a** then not ending with **ab**. So for **a** on **S4**, we go to **S2**. Because we are getting **a**, so if we get another **a** then we will go to **S3** which is **aa** and if we get **b** then we can go to **S4** which is **ab**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53f2b4d1-a26f-4305-93ac-b1fa6f955299)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6892f7c5-6b2d-44c2-a036-0b4a7ab6899d)

* **S4** means **ending** with **ab** but if we get **b** then not ending with **ab**. So for **b** on **S4**, we go to **S1** as **bb** or **b** do not work. So we are going to the **starting** which is **s1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/904a6a14-89ef-4faa-b1fd-f15bc500e080)

* After **S1**, ending will come by either **aa** or **ab**, before that any no. of **b's** no problem.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e36ed439-4e6d-453a-965a-0fc88e6033c8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99baeaa0-f478-40eb-9346-c1af27412c56)

* This is **moore** machine.
* In **moore** machine, if we give **5-length input** then we will get **5 + 1 -> 6** length output.
* Initially we are at the **starting state** without reading any **input symbol** it will print the **starting state** output.
* **moore** machine means that the **output** is within the **state** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8d002ae-a0d0-45c4-94fd-effa7ec13b21)

* We have **7-length input**.
* Output length is expected to be of length **8**.
* As of now, the **output** printed is **11** as we have gotten **ending with 'aa'** in the **input**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63194059-7526-475f-92dd-dce20c5494ac)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93353b2c-a2e7-4c85-8a1f-5bdb389a4412)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fd5994b-c958-4233-992e-71e811861783)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/669e9897-357a-408c-9690-da124fe052e4)

* [**IMPORTANT**]
* To us, the **last two** people are **what** that is very **important**.
* Which is **bb** here, so **2** should be **printed**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/824ef6c1-08b0-40e2-8b9a-9eaeea0cb13f)

* Solve the **last problem** using **mealy**.
* In **mealy**, on the **transition line** we will get the **output**.
* Based on the **input as well as the state**, we will get the **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1b35045f-6fad-47d0-b359-78fff90c8b7c)

* **S2** means ending with **a** happened.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/beb9ff8d-ac29-4c40-81b0-355b3ffcc12b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/33733e44-824e-4bda-8d02-d9cc5baddce4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f77e8888-689e-436c-9a1c-0b197e7222be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7fbf5f11-a119-47cf-bb47-13a78cfbff12)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2caae46b-2933-4135-8c66-f70889980aa9)

* **Minimal DFA, minimal moore machine, minimal mealy machine** is **unique**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bda13931-b526-41d8-b8cb-96247181d622)

* In **mealy**, if we give **n-length input** then we will get **n-length output**.
* For **every input symbol** we have an **output**.
* Within the states we don't have any **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cabcc4f6-9108-4bb4-a4b6-5eb59c37a40c)

* If we have **state** then we will have **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/639ba4f9-7ca7-4906-b2e7-224161e8925c)

* If we have **state and input symbols** then we will have **output**.
* Machine stops means **string** is over.
* If machine continues then **string** is not over.
* It is not **conversion**, we have done the **drawings** directly.
* If we do **conversion** then we will get **answer** then do not bother about **minimal things**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/136c5625-e2a4-4f49-8a4f-728b592b4c8b)

* In the diagram, we have **4-states**.
* How many **outputs** are there? [Output alphabet size]

> **Three output symbols(0,1,2)**

* So, (4 * 3) -> 12.
* The diagram is **moore**, we want to create **mealy**.
* **Moore** machine contains **4-states**.
* **Mealy** also takes **same** no. of states.

* **STEPS**:- [Moore to Mealy conversion]

1) If **Moore** machine contains **4-states** then in **mealy** machine take the **same** no. of states.

* Take **same** no. of states as **moore**.
* Copy states as it is but don't **copy** the **outputs** from inside the **state**. Just copy the **states** not the **outputs**.
* Inside the **state**, don't write the **output**.
* **Starting state** write as it is.

* **S1** on **b**, we are going to **S1** and the output is **2**.
* **S1** on **a**, we are going to **S2** and the output is **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f2b7eeb-42f1-4709-afff-02a27c18cb11)

* **S2** on **b**, we are going to **S4** and the output is **0**.
* **S2** on **a**, we are going to **S3** and the output is **1**.

* Instead of writing the **output** on the **state**, write the **output** on the **transition line**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cb3507cf-3900-4f27-892a-3ba371c470af)

* **S3** on **b**, we are going to **S4** and the output is **0**.
* **S3** on **a**, we are going to **S3** and the output is **1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0830f424-c15c-4dcf-bd68-b88b0bf4fa80)

* **S4** on **b**, we are going to **S1** and the output is **2**.
* **S4** on **a**, we are going to **S2** and the output is **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c4357f6-3359-4a25-a744-f505b53ddee6)

* GAME OVER.
* DONE.
* [**IMPORTANT**]
* We have not done any **minimization**. It is **as it is**.
* If we want to do **minimization**, then do the **diagram** on our own. Do it **directly**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/271e49d3-0086-47b4-b14f-b5727c638750)

* **minimized** diagram.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/15593bd8-58aa-4d52-a7a3-3518e5bd34af)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/af59fb0e-c71b-492d-b771-3558b36a61b9)

* [**IMPORTANT**]
* **Input** is either **a** or **b**.
* By giving **some input** it will go to some other state.
* NS -> Next state
* o/p -> Output
* i/p -> Input

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/edee8afa-2ee4-43b2-a824-01c2cd2bddb1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/defbc794-a550-4ae6-8690-58a54ca1deda)

* Don't worry about **minimization** here.
* Both are **same**.
* One is **transition diagram** and one is **transition table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e87a7b22-8077-4bae-aaad-bce35b193c36)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/521f6ff2-4854-44dc-8412-0401e75b4534)

* The **diagram/table** came from **moore machine**.
* **Moore** to **mealy** conversion.
* From the **moore** we constructed the **mealy**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d16306f-faee-47e5-8054-0327230375d9)

* **Moore** diagram.
* **Moore** machine **output** is based on **state only**.
* **Moore** machine **output** is not based on **input**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05eb6c22-c9a7-4a06-b7e8-28f9be2d1353)

* By seeing the **table** we can say that it is a **moore or a mealy** table**.
* In **moore** table, there is **only one column** for **output**.
* In **mealy** table, for **every input** there is a **output**.
* **More output** columns are there which means it is **mealy** table as it is based on the **inputs and states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd6fe804-c124-4c07-8ed7-ee0e521aa319)

* [**IMPORTANT**]

### Moore to Mealy conversion   

* We have **4** states.
* In **Mealy** output is based on the **input**.
* In **moore** machine **output** is there in **one column**.
* In **mealy** machine write the **output** in **two columns**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/00237235-b0c3-4713-b078-148003585469)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bd044f12-c2bc-429e-8150-8613eeec2038)

* **S2 and S3** are looking **same**.
* **S1 and S4** are looking **same**.
* We can combine **S2 and S3** and we can also combine **S1 and S4**.
* In **moore** machine, the **output** column is **separate** which means that based on the **state**, the **output** will come.
* In **mealy** machine, the **output** column is **not separate** which means that based on the **current state and the current input symbols**, the **output** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b85743b-794e-4c23-b48e-60c6239c0146)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f4cba4e-ae4e-45ed-9a74-a8631c9a492a)

* **Output** is based on where we are going. **S2** output we will write.
* Not only the **state** is **same**, not only the **input** is **same**, **output** is also **same**.
* Here **output** also matters.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e3b7447-6e25-4277-8061-869a34de4ecc)

* We don't bother about **minimization**.
* The **moore** machine contains **10 states** then the **equivalent mealy** machine contains **10 states**.
* The **moore** machine contains **20 states** then the **equivalent mealy** machine contains **20 states**.
* **Moore** machine -> **1** column for output.
* **Mealy** machine -> **2** columns for output.

### Mealy to Moore conversion

* **Mealy** has **2-states**.
* **Outputs** we have is **3**, which are **0, 1 and 2**.
* If we want to construct **moore** then **output** should there within the **states only**.
* We have **2-states** and **3-outputs**.
* We don't know what **output** should be there within the **states** in **moore** machine as **3-outputs** are possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/549a70d3-269f-4eaf-ba0d-4436057ed97b)

* **Output alphabet size** is **3**. 
* We don't know the **output** of **S1 state**, we should keep **0, 1 or 2** inside the **S1 state**.
* We don't know **inside the state** what **output** to keep.
* Try all **outputs**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0d332ac-b33f-4dc4-ad6b-168ef3df4770)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4691aaa3-ae3b-4fc6-ab4d-fce65f26f030)

* In **moore** machine, inside the state we have to keep **output**.
* We don't know which **output** to keep.
* So in **every state**, try all possibilities.
* **2 * 3 -> 6** combinations. Keep all of the **6** combinations.
* Out of the **6** people, few of them will be wasted.
* If we know exactly then we will cover **exactly**.
* This is the **maximum** thing which can happen.
* **Conversions** normally give **maximum** only.
* We are talking about **conversion** only. Not **minimal diagrams** and all.
* If **mealy** contains **2-states** and output alphabet size is **3** and **equivalent moore** if we create then **maximum** how many states are there?

> **2 * 3 -> 6** states are there, which is **maximum**.

* Out of them, few are **useless**.
* **Maximum** contains **6** states.
* Within the state we have to keep **output** but we don't know which **output** to keep.
* With the name **S1** we have **3** people.
* With the name **S2** we have **3** people.
* **Transitions** are missing, we will take care.

* In **mealy** machine, **S1** on **b** we are going to **S1** and the **output** is **2**.
* In **moore** machine, **S1** on **b**, but we have **three S1's**. We don't know which **S1** to take. So take all of them.
* * In **moore** machine, **S1** on **b** we are going to **S1** only, but which **S1**?

> **S1** on **b** we are going to **S1** only but that **S1** which contains **output** as **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b4db977-1ae6-43b8-a55c-fbc17adea901)

* Where are we **going**? **Going** point needs to be **clear**.
* From **which place** we are going is **not clear**.
* Where are we going is **clear**.
* **Out-going** is **not clear**.
* Where is it **going inside** is **clear**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/543ffc90-b321-436e-90e5-5dbaa9be8fad)

* **Out-going** -> Going outside.
* **S1** only, everyone is **going** but coming to **S1** which has **output** as **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6aac68ec-9676-4a50-82d3-22b486ff625f)

* In **mealy**, **S1** on **a** we are going to **S2**.
* Which **S2**?

> The **S2** which has **output** as**2**.

* Which **S1**?

> All of the **S1's**.

* **Output** is **clear** and where we are going is **clear**.
* From which place we are going, we have so many **S1's**, we don't know.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21075233-c3d4-47d4-b108-3f31bb4c9d92)

* Everytime see **mealy** as **mealy to moore** conversion is going on.
* In **mealy**, **S2** on **a** we are going to **S2** and the output is **1**.
* Where we are going is **ok**, we are going to **S2** whose output is **1**.
* From which place we are going?

> **S2** but so many **S2**. Take all.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe82f8fd-0c8f-40be-a76a-04ded63a152e)

* In **mealy**, **S2** on **b** we are going to **S1** and the output is **0**.
* We are going to **S1** whose output is **0**.
* Every is coming to **S1** whose output is **0** but from where? 

> From **S2** but so many **S2**. Take all.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c9747f9-d36a-4056-a632-a1628bb0ea93)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/936f0cb1-0322-4a44-903c-5b659454ef48)

* **Where** we are **going** is **clear**.
* **From which place** we are **going** is **not clear**. So many **S1 and S2** are there.
* **Output** point is **clear**.
* **From where** we are **going** is **not clear**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/936f0cb1-0322-4a44-903c-5b659454ef48)

* We have to find those **states** which don't have any incoming people?

> **S2, 0**, **S1, 1**.

* **Incoming** means **no one using** those **states**. **No one is coming** inside those **states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df050c34-38d7-4dbb-abaf-e05d2bf608c5)

* **Resultant diagram** contains **4-states**.
* How many states are there?

> **S1 and S2**. Because of both the **states** are **same** we are having some confusion. We can give **different names**. No need to bother.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e2b4e42c-8887-4281-ba19-7893f5507187)

* Who will be **initial state**?

> **S1**.

* Can we make anyone as **initial**?

> **No**.

* If **transition** not there then what will happen?

>

* If we make **S1** as **initial state** then What will be the **output** printed **starting itself**?

> **0**

* At the **starting itself**, the output should be **2**.
* So **S1** on **2** is the **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4713ea2d-abff-4c56-8263-c1f71a65c42e)

* We have done this **problem**, so we know which **one** is **initial state**.
* Can we **generalize** and say anything?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9bb242f9-d27c-4cf4-9234-8d5887f06697)

* Maybe we have done **some mistakes**.
* Max states -> **2 * 3 -> 6** states.
* We have **6** possibilities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26bd92c1-4579-4881-abdb-8d5df348f6b1)

* If we see the **mealy** table and we only see **two choices** for **S1**, which are **2 and 0**.
* So we can remove **S1, 1** from the **6-possibilities**.
* If we see the **mealy** table and we only see **two choices** for **S2**, which are **2 and 1**.
* So we can remove **S2, 0** from the **6-possibilities**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/811b855c-64d6-4028-89f0-3cc59e8f10ab)

* Now, we have total of **4-states**.
* As we want to construct **moore** so the **output** will be there within the **states** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30c81765-8449-4f5c-9732-8cc5e65c2973)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/47209514-3336-41a6-b71c-e85db77ac4db)

* Changing the names for **differentiation**.
* No problem there.
* We didn't create any problem.
* This is the **actual problem**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6893a625-fe9f-4444-bc44-cb846a179c02)

* **2 * 3 -> 6** states are there.
* As **no one** is coming inside of those states, then **cancel** those **states**.
* After that we are getting **4-states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59c7c980-e013-408d-8508-978e5e49bf56)

* Transitions are **same** story.
* **S1** on **a** we are going to **S2** with **output = 2**. Both the **S1** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e42036cc-f9f7-42c8-9af2-0c1ef8020009)

* **S1** means both the **S1's**.
* **S1** on **b** we are going to **S1** with **output = 2**. Both the **S1** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b34bdc8-9196-4866-b80c-4708075dc858)

* **S2** on **a** we are going to **S2** with **output = 1**. Both the **S2** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92d81a66-60f8-41ee-b8c0-3ef4aefec35a)

* **S2** on **b** we are going to **S1** with **output = 0**. Both the **S2** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3778c0c7-7032-4000-a2a5-4427fab92f87)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a852d685-030d-4398-9b67-9f1bfe0aea76)

* Who is **initial** in **moore** machine?

> **S1** with **output = 2**.

* In the **mealy** machine, **S1** is **initial state**.
* In **moore** we have **two S1's**. Who we can make **initial**?
* Any **generalization** can we do?
* **aa** -> Output is **1**.
* **ab** -> Output is **zero(0)**.
* How can we print starting itself as **zero(0)**?

> **ab** then only we can print **zero(0)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1997051-1c84-4d38-a2ac-857d96db2203)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1e416cd9-243f-42e3-822d-13ec4f1e121f)

* How can we do **generalization**?

> **Next class**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a09ee956-5306-4881-9b99-d1faa182a9d7)

* In this **problem**, **initial** is **S1** with **output = 2** because **starting** itself we cannot printout **zero(0)** because according to the **problem** when we get **ab** then only we can print **zero(0)**. **Starting** itself, where is the **ab**?
* This **problem** is **OK**.
* We will see **next class**.
* With the help of **Epsilons** make **single initial state**. That is the thing, one book is saying.
* Make the **new state** as the **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/52ab5477-1323-4b54-901f-e56058cda209)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29e6262d-9734-4e76-9455-ee159458d38c)

* Doubt.

* **States** are **2** and **outputs** are **3**.
* **Equivalent moore** machine how many **states** as **maximum**?

> **2 * 3 -> 6** states.

* While doing the **conversion**, if **more than one initial states** comes then what we will do?

> With the help of **epsilon**, make it as **single initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8bf0e054-48bc-44f1-b727-1cffeca37ecf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63a72df9-41c3-4222-b213-cc2b4f89a388)

## cfg-and-pda-iv (27) [18th Sept 2023]

### Mealy to Moore

* In **moore** machine the **output** will be within the **states**.
* Write all combinations with **states and outputs**.
* Out of the **6-combinations** we got, some of them may not be **useful**.
* In **worst case** this kind of diagram.
* In **worst case** all will be useful.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae004270-5ddf-44ca-89df-29a4ed6458b7)

* For **S1** on **b** we are going to **S1** with the **output = 2**.
* For **S1** on **a** we are going to **S2** with the **output = 2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fdd38c78-7794-4ae8-8ce7-8c9ca17293a9)

* For **S2** on **b** we are going to **S1** with the **output = 0**.
* For **S2** on **a** we are going to **S2** with the **output = 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/45bd5725-bcbf-44d0-9cc0-b2848451bec2)

* If we say **S1** on **a** then we are going somewhere.
* **S1** means **every 's1'** we covered.
* **S1** on **a**, we covered all **S1's**.
* Whatever **out-going** edges one **S1** is having that **same outgoing** edges are there in other **S1's** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ccf84184-91fa-4ba8-b30b-25eec882e103)

* In **moore** machine, **S1** on **a** and **S1** on **b**, both the things we have covered.
* Where they are going, it is ok.
* **S1** on **a** and **S1** on **b**, we have covered.
* **S1** on **a**, every **S1** we have covered.
* **S1** on **b**, every **S1** we have covered.
* In the **mealy** machine, the **S1** state is the **initial state**.
* In the **equivalent moore** machine, the **initial state** is **S1** only.
* We have so many **S1's**.
* We applied **S1** on **a** for **S1, 0**, **S1, 1** and **S1, 2** also.
* We applied **S1** on **a** for every **S1**.
* We applied **S1** on **a** and **S1** on **b** applied for every **S1**.
* For that reason **select any state** as **initial state** no problem at all.
* For every state we have done the **same**.
* Select anyone. No problem.
* Blindly select something from **one of the initial states**. There is **no problem**.
* We applied **S1** on **a** and **S1** on **b** we covered for **all three of them**.
* Take **one of the initial states** as **initial state** and ignore **initial or first output**.
* **Starting itself** one **output** is coming, there is **no use** for that **output**. Just **ignore it**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5321af0b-3a26-45b9-8487-e5aec0cf9f23)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2cbc2b53-932b-4d85-9707-46fef39f8a00)

* Take one of the initial states as initial state and ignore the **first output**.
* Any states which do not have incoming?

> (S2, 0), (S1,1)

* No incoming or incoming not there -> Useless states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34c0ffa9-094c-4390-8c04-e52339ce31df)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1b69446d-b2f8-4c96-bfe3-14335bac4c47)

* Between the **S1,0** and **S1,2**, except the **outputs** there is **no difference**.
* **Initial output** we are anyhow **ignoring**, so no problem.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2a3e64a-5cf9-492f-9fb7-4b018b8575b5)

* No clarity about **minimal**.
* It just does the **conversion**.

* **NOTE**:-

* For the given **m-states** and **n-size** output alphabet of a **mealy machine** to construct equivalent moore machine required.
* **(m * n)** states -> Worst case.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7758efcb-1527-452a-87d0-5f9b01c6c32d)

* **S1** having copies in **moore** machine.
* **S1** having three copies.
* Take **one** copy.
* We have to manage the copies.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6c9b8fd-6fdb-4003-844f-5390fe903da7)

* How many copies we have to manage?

> Depending on the **output alphabet size(n)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ef6fe52-b8d5-4fe8-9253-5061995d0d70)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ea8276d-48e8-48ad-a0da-5f4a265daa71)

* Example.
* Worst Case -> 4 States * 2 outputs -> 8 states.
* Every state having **two copies**.
* **q1** on **0** means every **q1**.
* That's why **every copy** contain **outgoing same**.
* **Outgoing is same**, we have to **differentiate** on the **incoming** ones.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cb8b6d96-58b7-4fa4-a388-2a9d8d542587)

* These **inside things** are **incoming**.
* No state of **q1, 0** on the **incoming things**. So remove **q1, 0**.
* There is state of **q1, 1** on the **incoming things**. So keep **q1, 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d7e0640-7114-45b4-b7f7-81bb28d41fdd)

* There is state of **q2, 0** on the **incoming things**. So keep **q2, 0**.
* There is state of **q2, 1** on the **incoming things**. So keep **q2, 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7cdc4e3a-0bac-4a8f-b199-59b5c700419c)

* There is state of **q3, 0** on the **incoming things**. So keep **q3, 0**.
* No state of **q3, 1** on the **incoming things**. So remove **q3, 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ef68976-698d-4454-959b-532381c9d0f3)

* There is state of **q4, 0** on the **incoming things**. So keep **q4, 0**.
* There is state of **q4, 1** on the **incoming things**. So keep **q4, 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89338b6a-2960-4e62-9a0b-fcde410352c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/877dab21-258d-4297-93bf-adfc46e49edb)

* Actually **8** are required.
* Out of the **8** some of them are not coming **inside of state**, so **delete** them.
* In case of **moore** machine, **output** is written once only.
* NS -> Next State.
* We have **two 'q2's'**.
* Why giving input we have to consider **all q2's**.
* We have **two 'q4's'**.
* Why giving input we have to consider **all q4's**.

* For **q1** on **0**, we are going to **q3** on **0**. As **q3** has **one output** only, so no need to write anything else.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b95aa33-3189-4272-ac12-f35437eed6e9)

* For **q1** on **1**, we are going to **q2** on **0**. As **q2** has **two outputs**, for **q2** which has **output = 0**, which is **q20**, so we have to write **q20**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b96f336-4aef-49cb-b7a3-1da782c04870)

* For **q2** on **0**, we are going to **q1** on **1**. Which **q2**?

> All **q2's**.

* While giving **input**, we have to give **all**.
* Both of the **q2** we have to take care.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6734ecf8-28b2-44c4-b43d-c53cfe3a6246)

* For **q2** on **1**, we are going to **q4** on **0**.
* So for both **q2** on **1**, we are putting **q4** and as **q4** have **two outputs**, so we will put **q40** which has the **output = 0** which we want.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b8ba3e3-859b-4e7b-bef9-c4c711812a15)

* For **q3** on **0**, we are going to **q2** on **1**. As **q2** has **two outputs**, so we have to write **q21** which gives **output = 1**.
* For **q3** on **1**, we are going to **q1** on **1**. As **q1** has **one output**, so we have to write **q1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b437e8f7-75f2-4332-b3c9-e7c2b832123c)

* For **q4** on **0**, we are going to **q4** on **1**. As **q4** has **q40 and q41**, we have to take care of **both**. As **q4** has **two outputs**, so we have to write **q41** which gives **output = 1**.
* For **q4** on **1**, we are going to **q3** on **0**. As **q4** has **q40 and q41**, we have to take care of **both**. As **q3** has **one output**, so we have to write **q3** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f9f5c42-786c-4e23-8274-7e6ec1987bb7)

* We have **initial state** only one here, which is **q1**.
* Remaining copies are cancelled.
* If **more copies** of **initial state** are available then select anyone of them **blindly**. Any how starting output we ignore.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b63d7255-cc2d-4d59-920c-71a41bd9015b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50b4ddc9-a91c-453d-9acf-44a9af9a3171)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b7c371e6-6bc5-4644-9371-8e27b4f3ac58)

* Example
* As we have **4-states** and **2-outputs** so the **worst case** is **4 * 2 -> 8** states.
* States not available -> (q1, 0), (q4, 0)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/72a46c51-98a9-4f11-b9dc-f4013d3c95d1)

* We now have **6-states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd99a602-9ac8-4f5c-bd87-28609f3a2983)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e0b9e5c-e53b-43c4-a000-e08458ee454f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ce0e3d3-73dd-4c31-ac9c-28a88809fe73)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ed7e121-25d8-4487-b684-62864528e19e)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9575f199-9012-4b3b-bb17-db47f2108920)

* Construct mealy machine which will take binary numbers as input and produces same **binary number + 1)** as output.
* Assume **LSB** comes first and end carry discarded.
* If we give **input** as **8** then we will get **9** as the **output**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4676595-2af2-42db-a832-c23fab8d559f)

* Simply **binary incrementation/incrementor**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8703c2e8-0502-4ad5-a6f2-64de8354bcd4)

* If we give **input** as **15** which is **1111** then we will get **16** as the **output** but the **end carry** is discarded and we will get **0000**.
* Only **four bits** we have to show.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82e6337c-403b-40c6-86f2-ce76858133cd)

* Here, **one value** extra is available.
* Incrementing by **1** means it is having **1**.
* He is already having **1**.
* He is ready to give the **1** to us.
* He already has **1** and is ready to give to us.
* If **LSB** becomes **zero(0)** then **0 + 1** becomes **1**.
* Replace **0** by **1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd2ad74e-e12d-4bef-a90b-847498258101)

* **1000**, the **LSB** is **0**. To the **LSB = 0** add **1** and it became **1**. Remaining people copy as it is.
* So the **1000** becomes **1001**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a78caa4-5f92-40dc-b5cf-d0d9338a12f0)

* **S1** is having **carry**.
* **carry** means **1**.
* We have **two possibilities** here. Either we have **carry** or we do not have **carry**.

* For **0111**, the **LSB = 1**. We are in **S1** state and we are also having **1**. So, **1 + 1 -> 2** but we want **binary representation** which is **10**. Take **0** and **carry = 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc9593dd-aa72-4e67-8a7c-3feaf567e9fa)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7500c3dc-c115-40b7-b2b1-1788bbd8e5ca)

* Just **adding '1'**.
* For **binary number, adding '1'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8569c12b-79a2-4c54-8c36-4af70709f21e)

* **1 + 0 -> 1** and **no carry**.
* As there is **no carry**, so **copy** as it is.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76e089ff-2fb7-4334-8620-98943bd568db)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/497e7439-e9c4-4b61-a5da-6d3467b07120)

* **1 + 1 -> 2 -> 10**, take **0** and **carry = 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cb530fa1-2cd5-4a80-9daf-d45042dab6a1)

* End carry **discarded**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6d2ff79-a5c8-4cb2-a4aa-45f103f349ca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b9eae613-a951-4845-a94a-80dcf5223f2a)

* Initially we are at **S1** state.
* At **S1** state, we are able to see **LSB**.
* **S1** means we already have **carry**.
* We are at **LSB** and **carry** already there.
* Assume **LSB = 0** and we already have **carry**. So, **0 + 1 -> 1**. **Carry** is not there.
* Further **carry** is not there.
* **0** and we already have **1**. So **0 + 1 -> 1**, **add** output as **1** but go to **S2** as **no carry** further. It means that remaining all are **copy**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/68f3f4d8-c69f-43c3-9f42-7d8bb7832345)

* Any boundary on **no. of bits**?

>  No.

* **No. of bits** are how many **bits** that are there on the **input**, those many. Input contains how many.
* Input stopped means stop the machine.
* Input stopped means stop it.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f8e849f-605d-4cf1-8e61-6b499deca62d)

* We are at **S1**, so we have **carry**.
* On **S1**, **LSB** coming as **1** and **S1** already having **carry = 1**. So, **1 + 1 -> 2 -> 10**. Keep **0** here and keep **1** as carry for the **next**.
* So, we have **carry** still. So, stay in the **same state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcb8bb1b-2b4d-4db0-a0e2-33b88f171031)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38c05556-6a46-468d-8597-f043d9843bc8)

* Input over so **stop it**.
* Even though **carry** there, don't write it.
* End carry is discarded.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/421ee1d4-7762-409b-848c-d3fa5ee51a95)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ca527ef2-2005-4526-a502-06915d8778ed)

* [**IMPORTANT**]
* If input still coming then we will continue.
* If we feel that **carry** is there then stay at **s1**. [**IMPORTANT**]
* If **carry** not there then go to **s2**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/673a4210-3426-408e-bf21-9a17df838042)

* **Binary Incrementor** -> **one(1)** only we have extra. When we came to **S2**, we lost that **extra one(1)**. Remaining thing copy.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c5fd95e-cf83-4068-8ac7-bfeaf531c401)

* [**IMPORTANT**]
* Initially we have **carry**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/182d66cc-4e2a-4e6e-8fbf-6602f40f9aee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78e2e98-b2b7-423a-86c0-7381e136357b)

* See **machine**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bbd8dcc3-a8a0-4bcc-a983-8a5aecb11373)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0030fd3c-4fee-475c-b7fb-70146b8e59cd)

* Mealy
* Input -> Two binary numbers
* Output -> Sume of those twi binary numbers
* Assume LSB comes first and end carry discarded.
* It is like **adding** two binary numbers.
* Binary Adder.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80b747dc-261f-4a70-80aa-8196cfab80c0)

* This is not a **binary incrementor**.
* In the **binary incrementor** we have **carry**. One carry is already there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3f620138-ee72-49aa-a5cf-66b3480d9319)

* This is not a **binary incrementor**, so we don't have **carry** at the **starting only**.
* **Carry** means **two bits** should come.
* **S1** not having carry.
* We have two binary numbers.
* We don't have anything extra.
* **S1** is **initial state**. We have two binary numbers but their **LSBs** only. Two bits.
* The combinations of LSB are **00,01,10, 11**.
* **S1** is **initial state** and it is having **no carry** because he has only **two binary nos** and from where we will get **carry**.
* If both **LSBs** are **0's** then **0 + 0 -> 0** and **no carry**.
* If **LSBs** are **0 and 1** then **1 + 0 -> 1** and **no carry**.
* If **LSBs** are **0 and 1** then **0 + 1 -> 1** and **no carry**.
 
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/009cb327-3a50-405d-ab61-95d6f1c34a04)

* **S1** not having carry.
* If both **LSBs** are **1's** then **1 + 1 -> 2 -> 10** and write the **LSB** first and the **one(1) extra** is the **carry**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d08cc991-9add-41fc-a5c7-28f60bec49d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44819403-8421-46c8-8997-1be89356d990)

* So, we have **carry** now.
* **(1,1)** came and we added them and we got **10**, we wrote **0** as **output** in the **transition line** and **1** is **carry** and go to **S2** state.
* When we come to **S2**, we have **one(1) extra**.
* **(1,1)** came and we are in **S2** state.
* Now, we are in **S2** and **(0, 0)** came, **s2** already having **1**, so **1 + 0 + 0 -> 1** output. We lost/completed the **carry**.
* As we have **lost/completed** the **carry**, we have to come back to **S1**.
* If **carry** is there then **stay** at **S2** state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f285e82b-1f03-4c11-b219-edb5b4c90885)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11b42697-813c-44fd-924b-04d3f187fd17)

* In **S2** state, **1 + 0 + 0 -> 1**, write **1** and comeback to **S1** state. **1** is the **carry** at the **S2** state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0401759d-cad7-45f4-9acd-a98a042d1862)

* **S2** is having **carry** which is **one(1) extra** and we got **(0,1)**.
* So, **0 + 1 + 1 -> 2 -> 10**. So, the **output** is **0** and we have carry of **1**, so stay in **S2** state only.
* **S2** is having **carry** which is **one(1) extra** and we got **(1,0)**.
* So, **1 + 0 + 1 -> 2 -> 10**. So, the **output** is **0** and we have carry of **1**, so stay in **S2** state only.
* **S2** is having **carry** which is **one(1) extra** and we got **(1,1)**.
* So, **1 + 1 + 1 -> 3 -> 11**. So, the **output** is **1** and we have carry of **1**, so stay in **S2** state only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97536a32-7d58-4c64-8e9d-9baf0e03e13e)

* [**IMPORTANT**]
* In the diagram, **S2** state remembers **carry** and **no carry** in **S1**.
* Initially we do not have **any carry**. So the initial state is **S1**.
* Starting itself we have **carry** then **S2** state become **initial state**.

* Suppose we have got **three people**, **two binary numbers** and **one bit also which is '1'**.
* Now we have **carry** at the starting itself.
* Now, start with **S2**.
* We have to **add two binary numbers**.
* In the **above question**, there are **two binary numbers** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c395d87f-6af2-4d0b-95b9-fb4b2362e158)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb55a60c-c5af-4ecf-9dee-4288fca97980)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/caef80ac-f288-4136-907c-79475c62468a)

* As **mealy** is there so **moore** is also there.

* **NOTE**:-

1) For any regular language **minimal-DFA** is **unique**.
2) For any regular language **DFA** is **not unique**.
3) For any regular language **minimal-NFA** is **not unique**.
4) For a given problem, **minimal moore and minimal mealy** are also **unique** for a given problem.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f24c82d-1d62-4b85-97e3-a4970c0b4f6e)

* [**IMPORTANT**]

## doubt-clearing-session(28) [18th Sept 2023]

## Closure Properties of Regular Languages [**IMPORTANT**]

* **5** marks from **closure properties** only.

### Union

1) L1 = Sigma ^ * then L1 U L2 = L1 [Complete Langauge U anything = Complete language]
2) L1 = Phi then L1 U L2 = L2 [Phi U anything = anything]
3) L1 = (a ^ * ) * (b ^ * ) and L2 = (a ^ n) * (b ^ n) then L1 U L2 = (a ^ * ) * (b ^ * ) = L1

* (a ^ * ) * (b ^ * ) -> Any no. of a's and any no. of b's
* (a ^ n) * (b ^ n) -> No. of a's equals to No. of b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12689100-c003-4979-996e-0039450df72f)

* True.

4) L1 = ((a + b) ^ * ) * b * ((a + b) ^ *) and L2 = ((a + b) ^ * ) * a * ((a + b) ^ *) then L1 U L2 = ((a + b) ^ + ), no one will give **epsilon**.

* Take anything either **a** should be there or **b** should be there. Except **epsilon** everything is possible.
* L1 = It contains string where **b** is the substring. Except **epsilon**, any no. of b's are allowed.
* L2 = It contains string where **a** is the substring. Except **epsilon**, any no. of a's are allowed.
* L1 U L2 = All strings where either 'a' as substring or 'b' as substring.
* So if we combine **L1 and L2**, **any no. of a's and any no. of b's** are allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e33426d-6e33-4610-858a-af25dc85c59b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc8ed8b8-3e28-4aaf-b3f4-0b52d3d24090)

5) L1 = (a ^ * ) * (b ^ * ) and L2 = ((a + b) ^ * ) then L1 U L2 = ((a + b) ^ * ) = L2.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e0b2b3e-d21d-470d-997c-c73e7704975d)

* [**IMPORTANT**]
* Common Sense needed.

6) If **L1** is regular and **L2** is non-regular over same alphabet **sigma** then **L1 U L2**?

* regular -> To whom FA is possible.
* **L1 U L2** is always **regular(R)**, we cannot say that as **L1** is regular and **L2** is non-regular(NR).
* We cannot say **regular or non-regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/475ce846-75d6-4d46-9c58-a438a33c2a61)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c77b701e-ee68-4819-9d0f-709036a8552e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9fbd25bc-22c7-49cd-97d4-e488a68f569f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dda20565-5bd5-434a-a6de-0f0f58278317)

* **Always** we cannot say.
* **Maybe** is **correct**.
* Maybe regular or may not be regular.

7) If L1 U L2 is regular then what can we comment about **L1 and L2**?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/28859a0b-6ca1-48ae-8570-e337ef1932da)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ca382f61-f505-4843-802c-1566a0b90751)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d7871f0-49cd-4222-b579-bfd5e2d2573d)

* L1 -> Maybe be regular, may not be regular
* L2 -> Maybe be regular, may not be regular

8) If L1 is regular and L2 is regular then L1 U L2?

> **L1 U L2** is regular always.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6f56ba8-39a2-489c-8168-de86321c5385)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f33c0ff7-a38e-4863-ad35-6daaa71affd6)

* A -> Finite
* Sigma ^ * -> Infinite set.
* If we remove **3-4** people from the infinite set then also it will be **infinite set**. It will not become **finite set**.
* **Finite sets** are not closed under **complementation**. [**IMPORTANT**]
* For **Finite set** if we do **complementation** then the **answer** is not **finite**. That's the meaning of **not closed**.
* After operation, the set changed it's behaviour.
* Before applying the operation, **A** is a **finite set** and after applying the operation, **A** becomes an **infinite set**.
* Before it was **finite** and after operation it became **infinite**, that's the meaning of **not closed**. That's why **Finite sets** are not closed under **complementation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c37f308f-9610-4b52-b0b6-50e6e4c2634e)

* **Regular languages** are closed under **union**. [**IMPORTANT**]
* **Closed** meaning -> **A** is a **finite set** and after applying **complementation** also, **A** became **finite set**.
* **A and B** are **two finite sets** and if we do **union** then they will become **finite**, **YES**.
* **Finite sets** are closed under **union**. [**IMPORTANT**]
* **A and B** are **two finite sets** and if we do **intersection** then they will become **finite**, **YES**.
* **Finite sets** are closed under **intersection**. [**IMPORTANT**]
* **Complement** of **finite set** need not be **finite set**. So, it is **not closed**.
* **L1 and L2** are **regular** and sometimes **L1 U L2** is sometimes **not regular** then we cannot say it is **closed**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3be0a7c9-802a-4c03-8283-024ed63d8bd0)

* So, Regular languages are closed under **union** operation.
* Closed -> Before and after behaving **same**.
* **L1** is **regular** then **finite automata** is available.
* **L2** is **regular** then **finite automata** is available.
* For **L1 U L2**, we can construct the product machine. **YES**. Using **epsilons** we can do. Like above also we can do. **OR** means any **final** is ok.
* For **L1 intersection L2**, we can construct the product machine. **YES**. Where both the **finals** are there, then only select the **final state**. Both finals are required.
* **intersection** means both finals are required.
* **L1** is **regular** and **L2** is **regular**. So, **L1 intersection L2** is also **regular**

### Intersection

1) Phi(Q) intersection L = Phi(Q)
2) ((a + b) ^ * ) intersection L = L [Everything intersection something = something]
3) (a ^ * ) intersection ((aa) ^ * ) = ((aa) ^ * )

* (a ^ * ) -> All a's
* ((aa) ^ * ) -> Only Even no. of a's.

4) (a ^ * ) * b intersection a * (b ^ * ) -> ab

* (a ^ * ) * b -> Ending with 'b'
* a * (b ^ * ) -> Starting with 'a'

5) ((a ^ * ) * (b ^ * )) intersection ((b ^ * ) * (a ^ * )) -> {Epsilon, a ^ *, b ^ *} -> (a ^ * + b ^ *) [**IMPORTANT**]

* ((a ^ * ) * (b ^ * ))  -> Ending with 'b'
* ((b ^ * ) * (a ^ * ))  -> Starting with 'b'

6) ((a ^ + ) * (b ^ + )) intersection ((b ^ + ) * (a ^ + )) -> Phi
7) ((a * (b ^ + )) intersection ((b * (a ^ + )) -> Phi

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b7afcf8-32b1-4c8c-a9e6-a6d003c19f70)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f24dd84-1b43-47c9-aec5-9e943edaf8d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f07e356b-3ad5-4117-b032-c0d873079c55)

* All are **regular expression** so, they are **regular**.

* [**IMPORTANT**]

8) If L1 is regular and L2 also regular then **L1 intersection L2** is always regular

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31cac30d-b89b-43aa-8832-b544c8297cc7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/527c1894-b043-4bbd-9523-0eaada3d4349)

* [**IMPORTANT**]
* Always regular.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ba315a5-d7ba-481b-83f2-3fa056917b1d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ff944ec-cd03-4949-929c-81f13bcef4d1)

9) If L1 intersection L2 is regular then what we are commenting about L1 and L2?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75209d5a-5320-4ebd-9676-e3fc8ccbb942)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e28fcac-4ce3-4222-8140-f9a46d301ba3)

* Two are non-regular and we got **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3c9056e-c6ab-4421-8ae6-00f32365ad1a)

* One is regular and one is non-regular and we still get **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/071926d3-74a5-4366-ab9f-d942fd4453b1)

* **L1 and L2** maybe regular and may not be regular.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3304ca0f-fa46-48da-bd97-3039ed1d791b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ceeb6489-2035-4c2e-ae93-70f36c8ca3c8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30d82e36-c1bc-45df-961b-500fd67462be)

* If both are regular then also we are getting **regular**.
* [**IMPORTANT**]

* Question.
* **L1 intersection L2** is **regular** and **L1** is also **regular**, what about **L2**? [**IMPORTANT**]

> **L2** -> May be regular or may not be regular.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5dcefcdc-3093-4127-9590-fdfd8b0f444d)

### Complementation

* **L** is regular, so finite automata is available, means **DFA** is available. In the **DFA**, change the **final to non-final** and vice-versa, we will get **complementation**.
* For **complementation** also, finite automata is there.
* Before **complementation** we have **DFA** and after **complementation** also we have **DFA**.
* So, **regular languages** are closed under **complementation**.
* Before **complementation** we have **finite automata** and after **complementation** also we have **finite automata**.
* Both the cases, we have **finite automata**.
* Then we can say it is **closed**.

1) L = Phi(Q) then L' = (Sigma ^ *) - phi(Q) = (Sigma ^ *)
2) L = (Sigma ^ *) then L' = (Sigma ^ *) -(Sigma ^ *) = Phi(Q)
3) L = a * ((a + b) ^ *) then L' = b * ((a + b) ^ *) + Epsilon

* In language **L**, starting with **a** only allowed.
* In language **L**, starting with **b** not allowed. They will by default go to **dead state**.
* Starting **a** only go to **final state** and starting **b**, they will go to **dead state**.
* When we do **complementation**, **dead state** becomes **final state** and **final state** becomes **non-final state**.
* Starting **a** we will go to **dead state** and starting **b**, they will go to **final state**.
* Language **L** contain **epsilon**. **No**, before **complement**, **epsilon** was **rejected** and now after **complement**, **epsilon** should be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ceaf4077-e3fd-4c87-b133-adad11d81619)

* [**IMPORTANT**]

4) L = ((a + b) ^ *) * b * ((a + b) ^ *) then L' = (a ^ *) [**IMPORTANT**]

* **L** -> Contain **b** as substring.
* **L'** -> Contain **a** as substring.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/573b55c2-7ad4-447c-a48b-cda342a571bd)

* We have to do **complementation**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b39cd97-dd64-436b-b05f-d0d077aca22f)

* Draw **DFA** and verify for doing **complementation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/262e552f-e44e-4885-a6a9-78fa4fb781dd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89221dae-546a-4bf3-889e-78cd5190a7cc)

5) If **L** is regular then **L'** is also regular because for **L**, **DFA** is possible and for **L'** also **DFA** is possible. [**IMPORTANT**]
6) If **L** is not regular then **DFA** is not possible and for **L'** is also not regular and **DFA** is not possible. [**IMPORTANT**]

* In **complementation**, it is **true** both the sides.
* **Union and intersection** is **one side** only and that side is if **L1 and L2** are **regular** then **L1 U L2** also **regular**.
* If both **regular** then **union** also **regular**.
* **Union and intersection** cannot talk in **reverse order** but **complementation** can.
* **complementation** is working both the sides.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6600f587-da3d-491c-a052-38be6ce7f80c)

* [**IMPORTANT**]

### Difference

* L1 - L2 -> L1 people but not L2. Our goal is **first one** only. **First one** but not **second**. [**IMPORTANT**]
* Set theory difference.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9b13c37-80e7-4448-b897-26fae2495275)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/611cfa89-2b89-4915-afb5-7d250a2385eb)

1) Phi(Q) - L1 = Phi(Q)
2) L1 - Phi(Q) = L1
3) (Sigma ^ *) - L1 = L1' [(Sigma ^ *) -> Everything/Universal Set]

* We want **everything** except **L1**.

4) L1 - (Sigma ^ *) = Phi(Q)
5) (a ^ *) - (b ^ *) = (a ^ +)

* **(a ^ * )** people but not **(b ^ * )**.
* **Epsilon** is the only **common**. Remove it. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a4bc6e5-1d13-4f6f-a9b7-1dffb3ef1746)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b61c76af-f85f-4716-a883-6cffad283a6e)

* [**IMPORTANT**]

6) (a ^ *) * (b ^ *) - ((a ^ *) + (b ^ *)) = (a ^ +) * (b ^ +) [**IMPORTANT**]

* Common things -> Epsilon, (a ^ *) only, (b ^ *) only.
* Minimum one **a** required and minimum one **b** required.
* **ab** there only on the **left side**.

7) (a ^ *) + (b ^ *) - ((a ^ *) * (b ^ *)) = Phi(Q) [**IMPORTANT**]

* Common things -> Epsilon, (a ^ *) only, (b ^ *) only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/73e1db17-d5ef-4bef-92a3-5b526797fb7d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c0b1609-a29e-4b1f-bd75-a44df6e10f65)

* From the total **L1** part, substract the **L2** part.
* **L2'** -> other than **L2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5bc17afd-0bc3-4865-ab58-c38dbb62a182)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/783f8f60-03d0-4571-a0ac-0281f757c0d6)

* Primary Operations -> Union, intersection, complementation, concatenation.
* Using **union and complementation**, we can get **minus or difference(-)**.
* **minus or difference(-)** -> Secondary operation.
* **L1 and L2** are regular then **L2'** is also regular.
* We know that **intersection** of two regular languages is **regular**.

8) If L1 is regular and L2 is regular then **(L1 - L2)** is also **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e07ed01-5e3b-4fdf-aa29-01de2170f8b0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39325742-90a2-4f15-a362-5fedba78eb20)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f34ea0d-4c16-4b2f-9381-e265022e46d4)

* [**IMPORTANT**]

* **L2** is regular so **DFA** is possible then for **L2'** also **DFA** is there.
* **L1** is already **DFA**.
* **DFA intersection DFA** is possible.
* Intersection of two DFAs is possible.
* Complement of DFAs is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b963563a-a1d6-42c2-97dc-6cb3e2461ffd)

* **Complement and intersection** are already **closed**.
* As both are **closed** and we are using them both in **difference** so **difference** is also **closed**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cbad6ee4-bf1e-405a-af2b-8c61b7b0ef13)

* Closed -> union, intersection, Complement, difference

### Subset

* **L1** is regular so we are taking **((a + b) ^ * )**.
* **L2** which is **subset of 'L1'**.
* **L2** -> **((a ^ n) * (b ^ N))**, which is **non-regular**.
* **Regular** languages are not **closed** under **subset**.
* **Subset** of a **regular language** need not be **regular**, maybe regular, may not be regular. [**IMPORTANT**]
* **Subset** of a **non-regular language** maybe non-regular, may regular also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11f00252-c922-4139-a28d-d182d1741fec)

* If **L** is regular language then it's subset may not be regular, so regular language are not closed under **subset**.
* **CFL** also.
* No person is **closed**.
* **RL, CFL,CSL, REL** all are **not closed under subset operation**. [NOTE] [**IMPORTANT**]
* It is **subset** and not **substring**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4442ea8c-150e-403b-a225-6f3d2c2c2c72)

* [**IMPORTANT**]

## cfg-and-pda-v (29) [18th Sept 2023]

### Concatenation

1) ((a ^ *) * (b ^ *)) **not equals to** ((b ^ *) * (a ^ *))
2) Phi(Q) * L1 = L1

*  L1 * Q = L1

3) Epsilon * L1 = L1

* L1 * Epsilon = L1

4) (Sigma ^ *) * a = ((a + b) ^ *) * a

* a * (Sigma ^ *) = a * ((a + b) ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3aa28a38-4040-4880-a760-09b9c19e9292)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5681c697-561e-4e79-9d09-66b5b900fc3e)

* (Sigma ^ *) * a = (((a + b) ^ *) * a) **not equals to**, ((a + b) ^ *) as in **(((a + b) ^ *) * a)**, the **a** is **compulsory**. Ending with **a** compulsory.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a3baead-2a31-4876-a600-10d0936c654b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17f2f546-360a-44c4-9665-263957c414a3)

5) (((a + b) ^ *) * (a ^ *)) = ((a + b) ^ *)

* Nothing is **compulsory** in **(((a + b) ^ *) * (a ^ *))**.

6) (((a + b) ^ *) * (a ^ +)) = (((a + b) ^ *) * a)

* Remaining all **a's** we can keep in **((a + b) ^ *)**.
* **(a ^ +)** means many **a's** also.
* Here, **ending with 'a'** is **compulsory**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1bfc83a-20a5-4aaf-bb5e-822f4c703c58)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/034e2e93-97f8-4148-9fa0-d23d5d6ed0b8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc8c14e8-fbad-4e17-8084-ffd897b80852)

* [**IMPORTANT**]

7) If L1 is regular and L2 also regular then **L1 * L2** is always regular.

* L1 regular means **FA** there.
* L2 regular means **FA** there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/532e579b-b8ff-4396-b3de-cc487b97a2db)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bd96c5ff-17bb-4658-9087-6666e6ecf543)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f8abe306-406a-455d-9b70-2e9fbe24638e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d9a4e87-5742-480b-a9f9-cb2c1534fc37)

* By keeping **Epsilon**, **L1 * L2** finite automata is always possible.
* Question
* **L1 * L2** is regular, **L1** is regular, what about **L2**?

> **L2** is also **regular8*.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbb01365-2121-44d5-9db6-c83d7205c9ad)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/067baf56-b522-4e8e-acd9-8f7d519d226e)

* [**IMPORTANT**]
* We concatenated.
* It looks like **(a ^ n) * (b * n)** but **no**, they do not have **any relation** at all, that's why we can't keep **comparision**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf854830-5a61-4faf-917d-9806fc1ae9e1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb3b6c1d-d954-47da-872e-675f7c92d71e)

* In the language **L1 * L2** any chance of **a's and b's** are **equal**. **YES**. Sometimes they are **equal**. Everytime, need not be.

* **(a ^ n)** came from **one language** and **(b ^ n)** came from **another language**, if we **concatenate** both of them then people will think it is **(a ^ n) * (b * n)**.
* Actually there is **no relation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/41e3c0aa-b830-4cad-91e6-1af5b27cfb4e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/539dc062-1fcc-47b2-9914-7d82027ea5d4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d704477b-cc8f-4c78-b4c4-46f433dac399)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d632482-ed73-4235-931c-a5bba8fdf38a)

* If **two languages** are **regular** and we do **concatenation** of the two languages then we will get **L1 * L2** as **regular** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ac06684-ebe4-49b3-9c8b-a6a6982945d1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36d11a7b-9656-42fd-88c2-229cd7657d03)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/951fcf8a-6f2e-44f1-aa55-e3d2a595c913)

* if we observe coarfully tha **b's** will be **more** compared to **x**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9488033f-a58f-4a31-80fb-d8e4447be1bd)

* [**IMPORTANT**]
* **((a ^ n) * (b ^ n))** is **CFL**, **TRUE** but it is **not regular**.
* **Regular** means **CFL** also.
* **((a ^ n)** is **CFL** as well as **regular** also, **TRUE**.
* **CFL** doesn't mean **regular**.
* **CFL** is **superset**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/484ce5e3-ed84-4af5-bfb0-2f8f18de913f)

**L1 and L2** are **CFL** and if we do **concatenation** between **L1 and L2** then **((a * n) * (b ^ n) * (c ^ m))**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08a34703-65ac-44d4-91a0-d1547eab817d)

* If we keep two people side by side then don't bring some **unnecessary relations/conditions**.
* **No condition** between them.
* It is **CFL** only.
* Everywhere **same** story.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db20365b-a042-4b1e-8991-0c24530413c2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6e9c50f-82b5-48e1-8bab-9bd68e7bf6d3)

* Recap:-

7) If two people are **regular** and if we do **concatenation** then result also **regular**.
8) [**IMPORTANT**]
9) Examples.
10) Examples.

## Reversal Operator

* Every string ending with **ab**.
* Last two symbols should be **ab**.
* If last two symbols are **aa** then we are in **S2** which means **a** is over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/caf4e7c2-3c0c-4e63-bc10-81fe0d548327)

* L ^ R -> **Reversal** of **L** -> Looks like starting with **ba** and then **anything**.
* This is **reversal**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/86e19629-d3be-4cb3-b201-7753e4d67aa5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b211962-a27d-4f1e-9400-7ca6ae6f8c4b)

* In the existing automata few changes we need to do.
* **Everywhere** reverse the **edge direction** as we want **reverse**.
* Reverse the **edge direction**.
* Edge is going from **S1 to S2** and in **reversal** make it from **S2 to S1**
* Everywhere **edge** reverse.
* **Self-loop** no need of **reversing**.

* We are not **interchanging**, **final to non-final**, we are **interchanging**, **final and starting** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30f4244f-e0b5-417d-be8f-27a60467fb18)

* For the **L**, **finite automata** is possible or not.

* **POINTS**:-

1) Reverse edge direction
2) Interchange initial and final
3) DEA **reversal** leads to **maybe** DFA,  maybe NFA, maybe Epsilon-NFA.

* **Finite automata is there that is the **important** thing.

4) After reversal if more than **1-initial** then make it as **single initial** with the helop of **epsilon-transitions**.

* **NOTE**:-

* If **L** is regular then **L^R** is also **regular** because both contain **finite automata**.
* If **L** is regular then **L'** is also **regular** because both having **finite automata**..
* **L^R** is regular and **L** is regular because **reverse in opposite directions**.
* More than one **final** and we **interchange** then we will make more than **one initial state**.
* Make starting/initial state as **final** and **final state** as **starting state**.

* In a given diagram, we have **1-initial state** and **5-final state**. After **interchanging**, what happened is that we now have **5-initial states** and **1-final state**.
* Insread of writing so many **initials**, make one initial with the help of **non-transitions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4852864b-3f89-4850-b260-1d723f5d64cf)

* **L** is **non-regular** and **L ^ R** is **regular**, how is that possible?

> **Not possible**.

* Either **both regular** or **both non-regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a540d142-2b11-46a5-b2ea-5b65a187f42d)

* [**IMPORTANT**]

* L = sigma ^ *.
* L^R = sigma ^ *.

2) L = Sigma ^ * then L ^ R = Sigma ^ *

* **Reverse** of **(Sigma ^ * )** is **(Sigma ^ * )** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19df8e16-6866-4e9b-9c44-a6a8fcc3ade9)

* **Initial state** become **final state** and **final state** become **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c74bcfb2-fb92-4037-9e36-bdadbae9eb56)

* **Reverse** in each direction but still **same** thing came.
* **Same** thing came after **reverse** as well.

3) L = (a ^ *) then  **(L ^ R)** =  (a ^ *)
4) L = Phi(Q) = **(L ^ R)** =  Phi(Q)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce13f75f-94e6-4e09-b8e5-1518a9d5b481)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/986d2c5d-3ddb-4754-a7ef-caba13749d19)

5) (a * (a + b) ^ * ) = (((a + b) ^ * ) * a)

* **Starting** became **ending**.
* Starting point becomes ending point and ending point becomes starting point.

6) L = ((a ^ *) * (b ^ *)) then **(L ^ R)** = (b ^ *)) * ((a ^ *).

* **Starting** became **ending**.
* Starting point becomes ending point and ending point becomes starting point.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a532cd05-0eeb-4928-8f0f-bb2ebdacab60)

7) L = ((a + b) ^ *) * a * b * ((a + b) ^ *) then **(L ^ R)** = ((a + b) ^ *) * b * a * ((a + b) ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/732bde00-9964-4edf-85af-bd613d046dca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/526301ac-5169-48a6-ba52-9313c667ac0f)

* Both will be **regular** or both will be **non-regular**.
* **One is regular** and **one is non-regular** that is **not possible**.

* **Question**:-
* **L and (L ^ R)** are two languages over the same alphabet then which one of the following thing is possible?

 a) Both are Regular is possible -> **YES&**.
 b) Both are non-regular is possible -> **YES**.
 c) **One is regular** and **one is non-regular** -> **No way, NO**.
 
* [**IMPORTANT**]

## Kleen Closure

* If **L** is regular then **(L ^ * )** is also **regular**. **Yes**.
* For the **existing diagram**, one state add before and one state add after, with the help of **epsilon** connect them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89cf191e-1999-4d1d-8471-22933155e3d3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09c3625b-a37c-4cc2-bbbd-3edbe6e772d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef030a8e-557d-40e1-9cb8-5e86d395195e)

* Adding one state before and one state after and with the help of **epsilon**, we connected the **states**. Make the **first state** as the **starting state** and the last state as the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b7289ec6-fc17-4e67-98cc-213181c410c1)

* If **L** is regular then **( L ^ * )** also regular.
* Regular languages are **closed** under **Kleen closure**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da8a658a-7126-47ee-a381-190fefa0c6eb)

* **1**.

2) L = Phi(Q) then (L ^ *) = Epsilon [**IMPORTANT**]

* (L ^ *) = (Phi(Q) ^ *) = Epsilon

* (L ^ *) -> If we don't go inside also **one time** then **epsilon** will come.
* If we go **inside once** then **Phi(Q)** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ff8d141-0709-4dc8-8639-a0dce8ff7e84)

* **Phi(Q)** means **nothing** man.
* nothing + something -> something
* Phi(Q) + Epsilon -> Epsilon

3) L = ((a ^ *) * (b ^ *)) then (L ^ *) = ((a + b) ^ *)

* In the original language(L), a's followed by b's.
* After doing **whole star(*)**, **a's followed by b's** need not be.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/851d55a9-4104-4da2-9d7b-4a6a0456e8a4)

* **L** is finite automata possible.
* **L ^ R** also finite automata is possible.
* With the help of **epsilon** connect them.
* (L * (L ^ R)) also finite automata is possible.
* So overall **regular**.

4) L = Epsilon + (a ^ +) = (a ^ *)

* (L ^ *) = ((a ^ *) ^ *) = (a ^ *)

* Conclusion:-
* ((L ^ *) ^ *) = (L ^ *)
* If we do **one,two, three** times **star(*)** then it will be **one star(*)** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d4730a6-d441-4cdd-b07a-2ed4844c1b98)

5) ((L ^ *) ^ *) = (L ^ *)
6) (Epsilon ^ *) = Epsilon

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82105881-2179-4090-aae8-310386235df0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71d2c5a2-41b5-47d9-a193-b9402dcc556f)

* Prime Numbers
* 2a's, 3a's, 5a's, 7a's, 11a's, .......
* Prime Number series is very dangareous story, many things we have to remember.
* No factor available except **1 and itself**.
* It is **not regular** and it is **not CFL** also.
* It is **CSL**.
* **CSL** and **turing machine(TM)** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f687c226-fb06-4bed-bfe1-a17d8009ed47)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0121f288-2443-43b7-81bd-e0974a0eff1d)

* LBA -> Linear Bounded Automata
* 2-S -> 2-stacks.
* **Turing machine(TM)** and **LBA** both are **same** but in the **LBA**, the **space** is **bounded/limited**. Some Limitations are there.
* **Turing machine(TM)'s** stack space, no limitation is there.
* **LBA's** stack space, some limitation is there.
* Only **difference** is this.
* If **LBA** is possible then **Turing machine(TM)** is **possible**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a40b39c-2f3a-44d8-b276-da233cecd896)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e98b783-1964-45bd-af16-1b789933066d)

* L = (a ^ p | where **p** is prime)
* (L ^ *) = (a ^ p | where **p** is prime) ^ * -> Epsilon, a ^ 2, a ^ 4, a ^6,a^8, a^10,a^3,a^9
* Except **a or single 'a'** everything is there.
* **a or single 'a'** is not accepted but afterwards everything is accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/48d79738-6ec7-40cf-ae89-f78eff90b2e0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c056dd98-7c8a-44d7-bb29-440ea25cddbb)

* **L** is **regular** then **(L ^ * )** is also **regular**. This is the **only thing** we can comment.
* **L** is **non-regular** then also **(L ^ * )** is **regular** sometimes.
* One possible and another one may not be **possible**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d598730d-6646-4847-84f6-6dddf5e213b6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a41937d1-e9f5-4482-b7d6-bc74d38f8ef0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/194dbd71-5654-49c0-92f3-43fe95fe65fc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/20050cc8-5b63-4ffa-ad82-b1104a332d27)

6) If L is non-regular then (L ^ *) maybe regular or may not be regular.

* If **L** is non-regular then anything can happen to **(L ^ * )**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9440533-f227-4a76-b692-1a561c45319a)

* **Question**:-
* **L** is a language and **(L ^ * )** is also a language, over the same alphabet then which one of the following is possible?

a) Both regular -> **YES**.
b) Both non-regular -> Maybe possible, may not be possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/119c9128-c31b-4b39-8cba-65a55a565b9f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cbbde3f4-7b2d-43ec-adb2-bbf99279e4ef)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5954b956-f868-4c14-858a-f6ec2b5344b8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8612e837-6836-4d11-8098-1e39b41ee33c)

* [**IMPORTANT**]

## Quotient Operation [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/039aca5c-71cc-449e-a908-89e8feca5952)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e52667b-21cd-4494-a9bd-9503d5f829d1)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/943370d4-1116-4232-b668-3a2128302948)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f4a1f3a7-9437-42c4-840f-58bdffb9c6a4)

* **xy** belongs to **L1**
* **y** belongs to **L2**
* Left out part is **x** that is **quotient operation**.
* **quotient operation** which is **L1/L2** which is **L** is equal to, **L** contains string like **x**. How **x** came?

> For all **xy** belong to **L1** and there exists a **y** belongs to **L2**.

* So that **xy and y** are cancelled and **x** is left out.
* This is **quotient operation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fefcb8f5-4554-4bab-bfa9-89a34343a790)

* Whatever answer will come, it should be part of **L1**. **YES**.
* Answer should be **left out** part of **L1**.
* It is not like mathematics where we can go wherever we want and cancel. We cannot **cancel** in the **middle**.
* **Right side** only we can cancel. [**IMPORTANT**]
* Below part should be **completely cancelled**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/35261e45-e691-4f90-af6a-762501524385)

* Yes.

1) abc/b = Phi(Q)
2) abc/bc= a

* From **Right side** onwards we should **cancel**.

3) abc/Epsilon = abc

* In **abc**, by default **Epsilon** is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d1caa27-8713-4380-8cf8-524bc6be946b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/35e0fd64-5acb-4b6f-80d0-a7dfb4f0a025)

* Answer always belongs to **left out** part of **L1**.
* **L2** should be completely cancelled.

4) abc/bac = Phi(Q)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fdfb4413-b52d-4893-a2a8-f882ae4a31dc)

* Above part is **L1** and below part is **L2**.
* **L1** contain **2-string**.
* **L2** contain **3-string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dac0da17-8205-44da-bfcb-67c771424258)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22f3a80f-dc6c-4580-a1ed-1400204b2f0d)

* Every member of **L1** try with every member of **L2**.
* If any cancelation is possible then try.
* **Answer** is whatever is **left out**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4bd7d1f9-2c90-48fc-b1a4-747d113eb3dd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6045df87-5656-4cea-9bcd-3c632ef0c7dc)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1e65dd62-288f-4e0f-ad4b-b96c7054aafe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51d702bf-ac72-458e-840c-a17049eac1f2)

7) ab/ab = (Epsilon * (ab))/ab =  Epsilon.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/58869110-f105-430b-85ef-c5aca80ba1a9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6236929f-06ef-4f14-8b60-b99d7cc071a0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/929a1221-47f6-4a7f-9443-2a4700c5bc6b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5518fd26-b416-43e3-a51d-a221284a9c0a)

8) (a ^ * ) / a -> (a ^ * )
* (a ^ * ) -> It contains everything in terms of a's.
* Above **a** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb6db92a-4b04-4801-a34a-47d60dc5e451)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7859938c-dd8d-4d7d-b787-e41ba343de5e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3be897e6-c3f0-4da1-aa6c-9fb50d13d744)

* Below part we have to eliminate completely.
* phi(Q) + something -> Something.
* We cannot write phi(Q).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/356745aa-9115-48d7-a098-ebf79ce6a6ed)

* **L2** is **infinite**
* L1 is finite.

9) a/(a ^ * ) -> {a, Epsilon}

* a/a -> Epsilon
* a/Epsilon -> a.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a212cdd-eb15-471a-a708-37faea2a1ce2)

* If **L1** is regular and **L2** is also **regular** then **L1/L2** is also **regular**.
* If **above is finite** and **below is finite** then **above/below** result is also **finite**.
* Regular expression means **regular language** is there.

10) (a ^ * ) / (b ^ * ) -> Epsilon/Epsilon -> Epsilon,a,aa,aaa,..... -> (a ^ * )

* **L1 and L2** both are **infinite**.
* Above is giving only a's and below is giving only b's.
* a/Epsilon -> a
* aa/Epsilon -> aa
* aaa/Epsilon -> aaa

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83342e35-df88-4364-a492-545c53faeb9a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb97b758-3816-4db3-b68e-72afb5d9eee0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/24b60cbc-7a9d-4369-93b4-6d9ce064287f)

11) b * (a ^ *)/b = b/b = Epsilon

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5fc51b1f-2d9a-4d76-a42a-2b72e147cdcb)

* The minimal string of **(b * (a ^ * ))** is **b**.

12) L1/Phi(Q) = Phi(Q)

* Below **Epsilon** is not there. What we will **cancel**?
* We can't cancel anything in **L1/Phi(Q)** that's why **phi(Q)**.
* Cancellation should be there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbd93d73-a69a-400e-8f8c-36e3de13ca5c)

* Atleast **Epsilon** should be there.

13) Phi(Q)/L2 = Phi(Q)

* Answer is always coming from **L1** only.
* **L1** is only **Phi(Q)**.
* In **L1** we don't have anything, that's why **Phi(Q)**.

14) ((a ^ *) * b) /(ab) = Epsilon, a,aa,aaa, .... -> (a ^ *) [**IMPORTANT**]

* ((a ^ *) * b) /(ab)
* ab/ab -> Epsilon
* aab/ab -> a
* aaab/ab -> aa

* **L1** is **infinite language**, which is **(((a ^ * ) * b))** as there is **whole star(*)**.

15) Epsilon/a = Phi(Q)

* In **L1**, no **a** is there.
* In **L2**, a is there.
* We have to completely cancel **L2** which we can't here that's why **Phi(Q)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e9c9c9d5-14db-45d1-a67e-cd4922de7c4f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e44303c-2fbf-4f22-bc21-ded8725f8425)

* **NOTE**:-

1) If L2 includes **Epsilon** then **L1/L2** is that we will atleast/minimum get **L1** guranteed.

* **Minimum L1** will come.
* More than **L1** is also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e3b1db6-e4f6-4dd8-8be9-d90d7e79d413)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2da9d870-3954-4182-86b6-7a0b6ca5e757)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74d3e4b7-142f-4adf-95b2-07b4a6c8b045)

2) If **L2** is not empty then (Sigma ^ * )/L2 = (Sigma ^ * )

* **Not empty** means something is there.
* L2 = a then (Sigma ^ * ) contains **a** as well. a/a = Epsilon
* (Sigma ^ * ) = aa, then aa/a = a

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/940c8ef9-7c03-426b-be94-fa5f30a716c7)

* If we take **L2 = ab** then the final answer contains **ab** because **(Sigma ^ * )** contains **ab**.

3) If **L2** is not empty then L2/(Sigma ^ * ) = All prefixes of **L2**.

* Assume that **L2** is one string **ab** then ab/(Sigma ^ * ) = L2, will come.
* L = ((a ^ *) * (b ^ *)) then L2/(Sigma ^ * )  = ((a ^ *) * (b ^ *))/(Sigma ^ *)
* ((a ^ *) * (b ^ *))/(Sigma ^ *) = ((a ^ *) * (b ^ *))/Epsilon = ((a ^ *) * (b ^ *))
* ((a ^ *) * (b ^ *))/(Sigma ^ *) = ((a ^ *) * (b ^ *))/ (b ^ *) = ((a ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd4123c7-64fe-4682-af35-e9acc456f415)

* Assume that **(Sigma ^ * )** is from **A to Z**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/291126c1-a12c-494f-8015-ccb7625fb49c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6fc67a5e-746f-4c6d-8eb3-9eb9e2068e31)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e6223a1d-f02f-422b-bc86-4aa2ae4b4504)

* [**IMPORTANT**]

* **Above** is regular expression, **below** also regular expression, whatever will come is also **regular expression**. Worst case **phi(Q)** will come that is also **regular expression**.
* Above is regular but below is non-regular then what can we comment about overall?

> **Regular/non-regular** -> Result is **regular**.

* ((a ^ *) * (b ^ *))/((a ^ n) * (b ^ n)) -> regular

* **Non-Regular/regular** becomes **Non-Regular**
* ((a ^ n) * (b ^ n))/Epsilon -> ((a ^ n) * (b ^ n)) -> **Non-Regular**
* Regular/Regular -> Regular

4) If L1 and L2 are regular then **L1/L2** is also regular.

* Remaining things maybe regular may not be regular.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8b92432a-c666-4e96-93ff-9346023acf2a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c441874c-8021-47c0-afb2-ac31f47ca102)

* NR -> Non-regular.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0a06267-a65c-4fec-8b98-65322737ba73)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/85730e1d-5e4a-451a-8544-e4e61d8517dd)

## Prefix

* L = {abcd}
* Prefix(L) = Everytime first people is compulsory  = {Epsilon, a, ab, abc, abcd}
* Suffix(L) = Always ending symbols required, everytime last people is compulsory = {Epsilon, d, cd, bcd, abcd}
* Substring(L) = Any part we can take, it has to be a sub-part = {Epsilon, a, b, c, d, ab, bc, cd, bcd, abc, abcd} 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa5dff4b-e162-403a-9562-1edf4744ba1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bba34a80-c5cc-4bf2-a878-2b0e16cbaddd)

* For any set, **empty set** is the **subset**, similar behaviour here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d76ecb09-696a-421c-ae1a-3ca525a13abe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f30cd50-2544-4f3c-8447-1c2c1e364656)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/47b55727-fab0-4776-98fd-603d45d44d2e)

* **Phi(Q) * Epsilon = Phi(Q)**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26505d25-48f9-43bc-bd07-49ef00a4e94c)

* It will accept **abcd**.
* S1 is starting state and S5 is ending state.
* For the language **L**, this is the finite automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3ff1b9b-0b25-4130-a159-235e2dd4005a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a5d89af7-dd2b-405f-b1a8-287f1f97b97e)

* Add remaining all states as **final**. Take/Make every state as **final**.
* Now, the **modified automata** will accept all **prefixes of 'L'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80e9cb06-e436-4410-8857-09c46f6628bb)

* We always have to start from starting state, we cannot start from wherever we want.
* If we start from **starting state** then **Epsilon** is accepted.
* a,ab,abc,abcd -> all accepted.
* Only final state is changing, not starting state.
* **L** is regular then **prefix of 'L'** are also **regular**. **Yes**.
* The modified automata is for **prefix of 'L'**.
* Remove the **blue color circles** then the automata will be for **L**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c30f9b1d-595e-4fcd-a256-bce4436028ef)

* In the original diagram **S1** is starting.
* Now make every state as **initial state**.
* We can start from anywhere.
* Make everything as **final**, make everything as **initial**.
* As everything is initial, we can start from **S4**. Only **d** accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/54751c85-7a84-432f-bed2-bf5ca577b377)

* We want to accept only, **bc** then start from **S2**.
* We want to accept only, **c** then start from **S3**.
* We want to accept only, **a** then start from **S1**.
* For the language **L** if we have **finite automata** then **substring** of **L** also has **finite automata**.
* If **L** is **regular** then **substring** of **L** is also **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/02626464-fdd9-4b60-ab91-a858d1397101)

* If **L** is **regular** then **finite automata** is available.
* In that **finite automata** make every state as final and make every state as initial then it will take **all substrings of 'L'**.
* In that **finite automata** whichever state is **final** keep that state as **final** only, don't make more **final**. Keep that only **final** and make every/all states as **initial**.
* We can start from **S4**, we will get **d**.
* We can start from **S3**, we will get **cd**.
* We can start from **S2**, we will get **bcd**.
* We can start from **S1**, we will get **abcd**.
* It will give all **suffixes**.
* If we want **suffixes** then make every state as **initial**.
* If we want **prefixes** then make every state as **final**.
* If we want **substring** then make every state as **final** and every state as **initial**. [Final and starting]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fcb6e769-6de7-4c73-b1f1-646a256f2722)

* If **L** is regular then **prefixes** of **L** is regular, **suffixes** of **L** is also regular, **substring** of **L** is also regular.
* This is the way of construction **automata**.
* **L** is regular means already **automata** there. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fabe7588-e67b-4f91-8b2b-94aff184fada)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09286dc2-ef1a-411e-bf7f-4b6b7de20bc3)

* [**IMPORTANT**]

## Substitution

* Sigma -> (Delta ^ *)  ['->' means mapped]
* Sigma -> P(Delta ^ *), Power set of **(Delta ^ *)**. [P -> Power set]
* **Star(*)** not there it means it is a **symbol**.
* **Star(*)** is there it means it is a **string**.
* **One symbol** will be mapped to **one string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5dbf6735-9ccd-4607-b4c8-fb2e81e356ad)

* **One symbol** is mapped to **Power set of (Delta ^ *)**, which is nothing but a **regular language(RL)**.
* **Symbol** is mapped to one **regular language(RL)**.
* **Power set of (Delta ^ * )** -> **regular language(RL)** over **Delta**.
* Sigma -> (Delta ^ *) -> String over **Delta**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/173039fd-a020-4f8a-9f76-7b580f3a2c42)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/73420cef-5a57-4971-8ab0-aa7f9e163a19)

* **Substitution** -> It is a mapping from **sigma** to **Power set of (Delta ^ * )** which is a **regular language(RL)**.
* It is a mapping from each symbol of **Sigma** to one of the regular languages over **Delta**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/acd46459-0e44-4a00-bf15-daa24964542d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2289102a-26ce-43e1-909c-ebd9f597570e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29f89115-605b-4ae9-a5ce-303dfcc45618)

* [**IMPORTANT**]
* **Sigma** contains **two symbols** which are **a, b**.
* This problem contains **two alphabet** or **two language** every language contains **one alphabet** which are **Sigma and Delta**.
* S(a) -> Substitution of 'a' -> 'a' is mapped to one of the regular language over delta.
* (0 ^ *) is a **regular** expression over delta.
* Every symbol of **sigma** will be mapped to one of the regular language over the alphabet, **delta**.
* This is **Substitution**.
* ((0 ^ *) * 1) is a **regular** expression over delta.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cda0650-34bd-417f-9284-4063db5894e5)

* Mapping is done.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b45bb93-f9e1-47ed-8e64-f7b0559e57d7)

* How to calculate **S(L)**?

* S(L) -> S(ab) -> S(a) * S(b)
* S(abcd) -> S(a) * S(b) * S(c) * S(d). [Formula] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/54ad2fab-30c5-49ea-9a9b-f64bb6745352)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12a730ab-bbfd-4f57-b4c8-07ff44837820)

* This is the type of questions that come in **substitution**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1302bc64-1f12-4124-bfb9-2f1e2103f650)

* **L** is one language.
* Langauge **L** contains **one string**. It is a **finite language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80e35816-9566-4647-8b52-e71670c8c218)

* We have to do **substitution** for **language** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d4834c3-9982-4eb1-b235-214ceb2a746b)

* Extended substitution [**IMPORTANT**]
* S(a ^ *) = ([S(a)] ^ *) [Formula] [**IMPORTANT**]
* S(a) = (0 ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d6fa4e3-06d2-4c39-a2ac-f640aaf6248c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cae1b2a0-5881-4d9a-b432-2e2e254a1905)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ee7c7da-feda-4d44-ac2b-725cf54b85dd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f33e9216-95a9-4cf7-8f4a-67a3c0f357e9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f78d412c-70f8-4780-853e-e04f96501078)

* S(a + b) -> S(a) + S(b)  [Formula] [**IMPORTANT**]
* Formulas. [**IMPORTANT**]
* To **map** a **language**, the **formulas** are **useful**.

## cfg-and-pda-vii(31) [19th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e94877f-97d0-458a-bfe9-36c25e5702fa)

* Substitution Formula [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30572193-890b-4485-a24a-17e468a7d491)

* Every symbol is mapped to one string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a00d75ba-4b18-4a89-9de9-29b6e53ad3ce)

* Every symbol is mapped to one regular language/expression(RL/RE).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38a578d3-20c8-4d43-a60f-908e9cce1c09)

* Star(*) means **kleen closure** on **Delta**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e3a85a88-685c-447b-bd07-dcc3ce4dec62)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a06de61-da50-459c-857d-86a0aa634291)

* Example
* **Input** should be in-terms of **Sigma**.
* **Output** should be in-terms of **Delta**.
* They will give in terms of **Sigma** and we have to write in terms of **Delta**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f60d95eb-3e7f-41af-a360-9dab8bb0e283)

* Minimal string -> Epsilon.
* After **b's** we can't get any **a's**.
* It looks like **((a ^ * ) * (b ^ * ))**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53991d5d-8c99-48be-8ea8-0b729a30de78)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a63f56ed-7705-4fe0-86fd-60fe26cf962f)

* Meanings cannot change, do whatever way like.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/528873f6-7d8e-4f60-a078-ca413f6cb610)

* Second one is a **superset**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4387506-38a7-49c6-a208-f2661dd80ff1)

* In the given regular expression, every symbol will be replaced by another regular expression. So, overall becomes **regular**.
* **010** finite automata available.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6782f939-2693-4daf-bd47-4c5091c6ac70)

* Finally also, finite automata available.
* For the given regular language, we have a finite automata and we replace every **symbol** by another regular expression, we got another finite automata.
* If we replace every symbol of a regular language by another regular language overall also becomes **regular**.
* So, **regular language** are **closed** under **substitution**.
* After **substitution** also, it became **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c831f343-7331-41cf-acde-e186f08214eb)

* **NOTE**:- [**IMPORTANT**]

1) In the given regular language(RL) if every symbol substituted by another regular language(RL) then result is also regular language(RL).
2) So regular language(RL) are closed under **substitution** operation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98bddb51-f7fc-4ee1-853c-7b370e04110d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/777c81eb-7216-44b0-98ff-2a9e5434e718)

* Example
* Sigma = {0}, Delta = {a,b}, substitution 'f' is defined as f(0) = (a+b)(a+b) = (a+b) ^ 2
* find, f(00) and f(0 ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc29d6a3-a1fa-4629-8f07-992c5219e88f)

* Everytime **2** is coming, so **even length**.
* **even length** followed by **1** is **odd length**.
* ([(a+b) ^ 2] ^ *)(a+b) **OR** (a+b)([(a+b) ^ 2] ^ *) -> odd length
* To the **left or right** side of **([(a+b) ^ 2] ^ *)**, keep **(a + b)**, **a** or **b**. It will become **1-length**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/433d8867-5c07-43d8-a420-0769c5d58e27)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/708c37ba-8413-4012-a25d-6cd9edfac538)

## Homomorphism

* It is a special type of **substitution** where every symbol in **sigma** is mapped to one of the **string** over **Delta**.
* It is a **mapping** from **sigma** to **(Delta ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66a2cf8d-591d-48c7-8adb-888b6ba5325e)

* Regular expression contain **string**.
* Regular expression sometimes contain more string also.
* A symbol replaced by more strings is nothing but **regular expression**.
* A symbol replaced by one regular language because a regular language may contain so many strings.
* Here, in **Homomorphism**, a symbol is replaced by **one string** only.
* In **substitution**, a symbol is replaced by regular language which may contain many string. 
* (Delta ^ *) -> String
* Power set of Delta ^ *), P(Delta ^ *)) -> Substitution
* If replaced by **string only** then **Homomorphism** and if replaced by **regular language/expression** then **substitution**.
* **Substitution** is the **superset**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2a2bf280-5aa1-4527-b8a2-c6557ac38ea8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/788ec98a-f2e6-4f0e-97fe-49dbb36757f9)

* **Homomorphism formulas** [**IMPORTANT**]
* Sigma = {0,1}
* Delta = {a,b,c} and **h** is defined as h(0) = ab, h(1)=bbc.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8dd693ae-4217-4670-818c-4668c9761006)

* Example
* On the **right side** of the **equal(=)** sign we don't see any **operators** in **Homomorphism** as we are only replacing **strings**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d1c3777-1aa5-402a-a110-463576791a78)

## Inverse Homomorphism

* h(0) = w [Homomorphism]
* h ^ (-1) (w) = 0 [Inverse Homomorphism]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51f778de-206f-45f8-9223-15beb482c06c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6df76a3b-f494-4197-87ed-619dc65b8b85)

* In **Homomorphism**, **symbol** is mapped to a **string**.
* In **Inverse Homomorphism**, for every **string** we will map **symbol**.
* **Homomorphism** in the **reverse order** is **Inverse Homomorphism**.
* Inverse function.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a0c66398-5223-4362-a67a-706e06975341)

* Until now it is **Homomorphism**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9f5a450-52e4-41e2-a9d9-50288ea3df8d)

* **L** is given in terms of **a and b** which is **Delta**.
* So, it should be h^(-1) (L).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c4b860d-77ff-45df-a932-21edbf13d2b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89898cb1-2c7f-4e30-805d-747282466778)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/14dc086b-bb8f-49de-9c1c-9080dad10a9a)

* We don't know **h ^ (-1) (ab)**, **h ^ (-1) (ba)** and **h ^ (-1) (a)**.
* We are unable to **map** it.
* It is **not possible**.
* For the **total language** we cannot give.
* Atleast for **few strings**, we can give.
* For the **given language**, **aba** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31d03b04-dc9a-45e7-a5bc-0283010a3797)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/759e092a-d76e-4743-8099-59cf57e57b64)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac0e9ad3-a3f1-41aa-87c2-0b33c088abef)

* When **total** is not possible then **atleast** give whatever is **possible**. [**IMPORTANT**]
* From the **given language** there is no change of **aa**. Not possible.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32a1d88f-f828-44e8-b1d0-ef4dfb89ce3c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/095712b9-fdab-4322-be66-e549b7c64b0d)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4226431-0bcc-4549-8b24-f688546fd77f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d730eb8-9670-466a-a685-fc1932006bbf)

* **One answer** we got.
* Many possible combinations.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c62dfd34-d93d-4279-afb2-a3578d8db222)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d407bba3-968c-408a-873c-7e5296c54a3d)

* [**IMPORTANT**]
* All three are the answer or anyone of the three is the answer.
* **MSQ** also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef58692d-d698-4a37-8bf7-903bda096216)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fdeb30f7-93bb-42fe-85c1-56de492509fa)

* In the given **question** there is **no inverse** story. **NO**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12ba0744-5e7f-4482-991c-78b27586177d)

* Part of **above question** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/906f61fd-6bc6-44c5-966a-ac511b717427)

* 0 * (2 ^ *).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf21cd62-e500-4015-8eb4-87066a0e8833)

* (1 ^ *) * 0.
* Anyone of them is the **answer**.
* Whichever given in **options** choose that one only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/233c9cf0-bf8c-4994-a114-930c94a63d0b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38002b66-8bff-404b-a339-3261b18c4a5f)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6300bf7f-8795-4c4c-b123-ad7353735892)

* Two answers will be there.
* Both are **a** only, we can write **0 or 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9616a9b4-0ea4-47b9-b21e-a43b856ab9c7)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb3fbf36-aff3-4833-a32b-8374470c49a1)

* In **L**, whatever strings are there we can **divide** every string into **two equal** parts.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dabd9b5c-367d-40b1-86f1-74e60f6fe9bb)

* Everywhere write the **first part**.
* This is called as **(1/2) * L** or called as **first half** or **half L**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56c6856c-6056-4db3-8ad9-662c68fbcf9d)

* This is called as **second half**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b362d5ca-7bf9-4c73-a229-7146276263f5)

* For more clarity.
* If **L** is regular then **1/2 * L** also regular.
* So the **regular language** is closed under **1/2 * L**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/268d0965-d22d-43e5-8466-47d3825d431f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2cc6343c-4b89-47e4-89a3-f585cb3d49b7)

* We can **divide** every string into **three parts**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1d35e11-4b6d-4d81-b31f-2d86284c72ea)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2c22fb9-ee8a-49a6-b07c-211cc6232b19)

* If **L** is regular then **1/3 * L** also regular.
* So the **regular language** is closed under **1/3 * L**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08cb55af-a6a7-48b3-a5bc-da825405c6c0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88aa79de-34d2-48cb-bca8-2a9c293024f6)

* **Regular language** is closed under:-

1) Union
2) intersection
3) Kleen closure
4) concatenation
5) prefix
6) Suffix
7) Subtring
8) substitution
9) Homomorphism
10) Inverse Homomorphism
11) Complement
12) Difference
13) Reversal
14) Quotient Operation
15) Symmetric difference [Not required]
16) 1/2 * L
17) 1/3 * L

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fea62bd4-ca8b-4817-9d3a-10d26b3fecf2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9017e44a-875b-47f9-99cc-4c8402bfaf3e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d813c26d-5dd8-4a65-89c5-eeaee6e8508a)

* **Subset** is not closed over **any language**.
* [**IMPORTANT**]
* **Finite subset** which is **regular**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce7adbaf-bca5-48f2-b91b-1d664ec46d1c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2cfe0f0-769b-4fa5-a0ed-881bd71b8c60)

* Every **finite** language is **regular**? Why?

> We can write regular expression by keeping **plus symbol(+)**.

* regular expression possible means **finite automata** is possible.
* If some strings are not possible to **divide** then **leave them**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34ebbb31-7e8f-4ed5-a291-0a45076849d3)

* Need not be.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26e08675-07c1-49aa-bec0-768c1628e336)

* Example of above question.
* Every **even length** string we can write into **two parts**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d3531f4-2860-43c2-997a-6535ce08a150)

* Mostly everything is **closed**.
* **Subset** is **not closed**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42897e66-6faa-4ce6-916a-328ea91f4e9b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/005be2c7-dd7f-4fac-8bb8-c63bf500ebf8)

* Wherever possible **divide**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eac389bf-d3b8-404d-8a40-388c3a85d496)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83044547-0498-4f1b-97b7-7d0298f00637)

* Actual **automata** is this **only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/480cf960-63cb-45cc-843e-55b507ec1316)

## Context Free Language and Push Down Automata

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9375d47-a850-45de-a7ef-7aebd933a518)

* Next Class

## closure-properties-of-cfl-i (32) [19th Sept 2023]

## CFL and PDA

* PDA -> 1-stack is there
* In **Automata** with the help of **state**, we can remember or remembering.
* PDA is nothing but **finite automata plus(+) stack**
* **Finite automata** we are remembering something and in **stack** also we are **remembering** something.
* Combinedly we are **remembering more**.
* So **more power**.
* **CFL and PDA** and we need **Grammer**.
* G -> Grammer
* G(V, T, P, S)
* V -> Set of variables
* T -> Set of terminals
* P -> Set of productions
* S -> Start symbol.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/268a0a16-f056-43a3-997a-ac346ac483d7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5145d34-5b63-43fd-ad93-07d2589ccd49)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9d81884e-eb3e-4fbd-b013-7bd8b8a3d40a)

* VTPS.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2aa045c-8e81-4cca-92f0-112f2f67a3d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e448ec7-c7ef-4ca9-a843-61ca70e61393)

* **B** going to **b** and **B** also goes to **Epsilon**.
* **B** contains **two** things.
* **B** derives **b** or **B** derives **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e52bff77-0274-4d25-8964-be6cb47e5cb5)

* We can write like this as well.
* **/**, **slash** is the **OR** operator.
* **B** going to **b** or **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0fbe86c1-2c1d-4bdc-b26d-436f091107b1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3af410c0-b8b4-43ba-bbb7-77e5afd39792)

* **Grammer** means **4-things** should be **given**.
* Till now in the **Grammer** only **productions** are given.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1e6a011-698c-486f-9705-cf051bea27f0)

* We have **4-productions** here.
* **B** contains **2-productions**.
* **A** contains **1-productions**.
* **S** contains **1-productions**.
* Variables(V) = {S, A, B}
* Terminal(T) = {a,b}
* Start Symbol(S) = S
* **Epsilon** is left out and we know that **Epsilon** is a **special person**.
* **Epsilon** is neither a **variable** nor a **terminal**. [**IMPORTANT**]
* Whatever mentioned in the **question** are **variables, start symbol and terminals**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/300d9af4-379f-4fff-9c96-6d7e14c75342)

* **4-things** are given then only we can say that **Grammer** is given.
* **Grammer** means **4-things** are given.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d6c6fcf-ddc5-4fae-a428-712f03c0bae0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f24c359-65f2-4e40-88fc-379316109f55)

* Only **productions** are given.
* If others are not given then **capital letters** are **variables(V)**, **small letters** are **terminals(T)** and **first person** is **start symbol(S)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f4824e0e-5504-4810-99f3-3096c90a4742)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abff8584-a774-4db4-b63b-62b3024196b3)

* Whatever way it is given in the **question** take accordingly. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18fdaa01-e4a5-417d-aae6-fc83d1f20a3e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e4c375d-e077-4337-aebc-da3717204afc)

* Only **productions** are given.
* **capital letters** are **variables(V)**, **small letters** are **terminals(T)** and **first person** is **start symbol(S)**.
* How many **productions** now?

> 1 + 5 + 5 => 11.

* By default **start symbol** is **s**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4eaaedd-0427-4af6-95e6-7e4afbdb9f88)

* **Leftmost** one we replaced **first**.
* This is leftmost derivationn.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea77c28f-8230-4c98-8a3d-6ed726f60128)

* This is **Right Most Derivation Tree(RMDT)**.
* **Left Most Derivation Tree(LMDT)**.
* **S** is replaced by **AB**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/94eaf8bc-5585-4872-929b-8574e82b823c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2a1822c3-445c-439a-8475-131927a498d6)

* In the tree who are the last people?

> Terminals.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/43b685ed-5e6b-41ad-b9cc-1b99ba674d4a)

* **Expansion** -> Small symbol becomes **big symbol**.
* Initialy in the **tree**, **S** is the **one symbol**. **One** in the **next level** becomes **two**.
* It is **expanding**.
* In a particular level, more than **one** variable, we have **dilemma**. **YES**.
* Which variable we have to **replace** first?

> **Left one** we are replacing everytime.

* This is **left most derivation tree(LMDT)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44718cdf-d227-4845-bd0b-27f6b66f36aa)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/470f0b68-4e13-4614-a951-e19210551841)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abde5ff4-8714-4d76-b9b6-7d27ed997466)

* Finally the tree is generating, **Epsilon * Epsion -> Epsilon**.
* The **third tree** is generating **one string(Epsilon)**. The length is **0**. Empty string.
* **Empty String** -> One person is there whose length is **0**.
* **Empty language** -> One person also is not there. No string at all.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f97c586c-7b7d-4570-a098-4ccd5e49ea7e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23299e78-0afa-4516-998b-eccb9e885299)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97e8505e-efc7-4601-8f25-63ea74f4fca6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e4c33d1-5636-49ce-8e8e-22b3b074ff5a)

* We are in **dilemma** which variable to **replace**.
* We are replacing **A**.
* So, we are doing **LMD**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/321e5684-6333-4e70-b6be-5f344027157b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dfd625e2-7850-4edc-bd24-55893e26e7ec)

* RMD.
* **A** is replaced by **a**.
* **B** is replaced by **b**.
* **Left one** we replaced **first**.
* **LMDT**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78810ed-d4ed-478d-ad76-9d1ef21e6bb5)

* **Right one** we replaced **first**.
* **RMDT**.
* Only **numbers** will **differ**.
* To generate a **particular string**, **LMD** possible means **RMD** is also possible.
* To generate a **particular string**, **LMDT** possible means **RMDT** is also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e80efc76-3fac-4c25-920d-9ae23dd9b6f6)

* [**IMPORTANT**]
* **LMDT** possible means **RMDT** is also possible, both are **exactly** same piece.
* No difference at all.
* At the end of the day, both the trees are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8b9c26e4-96d9-4a80-a901-806d699ad06a)

* **Derivations** we are talking.
* First level both are **S**.
* Second level both are **AB**.
* Fourth level both are **ab**.
* At the **third level**, they **differ**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/370c190c-f5f1-4e47-bec7-e41a3866fa28)

* LMD and RMD need not be **same** but **Derivation trees** are **same**.
* **Derivations** are not same but **Derivation trees** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23ecfa18-4f3c-40b1-8854-14e22b04fe9c)

* Purpose of **grammer** is generating **strings**.
* Process of generating **string** is known as **derivation**.
* **Derivation** is of **two types**, **LMD** and **RMD**.
* **LMD** and **RMD** need not be **same**. In some levels they might **differ**.
* **Derivation trees** are every level is **Same**.
* Programming language follow **LMD**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1347a56-6374-482e-a638-034d6039337c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/488890fd-69dd-422f-bbae-b6095886f518)

* Here, we are covering **every model**.
* We are covering **every possibility**.
* First **A** came then **B** came and then **C** came. We are doing **LMD**. Who will be done first?

> A -> B -> C

* If following **RMD** then **C -> B -> A**.
* We cannot go to **middle(B)** directly. Some random answer will come.
* If no dependency then we can do **A,B and C** in any order.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6992361-4ec1-47d8-9b4a-0112cf35f52d)

* LMDT and RMDT are **same**.
* LMD and RMD need not be **same**.
* **Derivation** need not be **same**.
* **Derivation trees** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e12a98d0-3372-472a-82e5-305542f76486)

* We have **3-productions**.
* Variable(V) -> S
* Terminals(T) -> a
* From the grammer we want to generate **aaa**.
* Grammer purpose is generating **strings**.
* **S** having **3-choices**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/64137a28-fede-4399-83e2-5e826afcb89a)

* **S** calling **S** is called as **recursion**.
* Same story will repeat further.
* When we say **recursion**, **termination** condition is **required**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96aa6910-0fc1-4802-a559-38e93692853a)

* **Left and right** side **same** variable is there, this is **recursion**.
* **recursion** is there in the **grammer**, so the **grammer** can generate **infinite strings**.
* We can call **infinite** time.
* **Recursion** not there then it is **finite** string.
* **Recursion** -> Same person should call itself.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/35965bf9-31d4-46ff-86f2-bb360723f9b8)

* In the **first** level we have **1-variable** only.
* In the **second** level we have **1-variable** only as **a** is the **terminal**.
* In any level, more than **one variable** then we are in **dilemma**.
* In the **second** level, we don't have any **dilemma**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db25e648-6938-45a2-a0c8-8cdd46af3234)

* Read all of the **leaf nodes** from **left to right**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9cc8a636-fee9-434c-a411-668eb8de7c99)

* This tree is generating string **aaa**.
* It is **both**(LMDT or RMDT), as we don't have any choice.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1fcf261-4f32-43d5-863b-ebfff0837961)

* left there means right there.
* Sometimes atleast **numbers** will **differ** but sometimes **no numbers** also differ.
* That itself is (LMDT and RMDT).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f25099f0-94a8-41af-9073-e9d745ef4952)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8793a0b7-1b77-4ac3-9d86-79173d4f8833)

* On the **first level** we took **as** and in **second level** we took **sa**.
* Read all of the **leaf nodes** from **left to right**.
* We got **aaa**.
* It is **both**(LMDT or RMDT), as we don't have any choice.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff2f2df8-51e4-4593-81f7-e672070b97aa)

* From the given grammer to generate **aaa** we got **2-LMDT**
* **2-LMDT** means **2-RMDT** are also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac899f99-f014-4981-844f-f638dd4ca3f1)

* From the given grammer to generate **aaa**, we got more than **1-tree**.
* From the given grammer to generate a particular string, if we find out **more than 1-tree** then the **given grammer** is **ambigious grammer**.
* These are **two-different** trees.
* Don't worry about **left and right**.
* From the given grammer to generate a particular string, **more than 1-derivation tree** then the **given grammer** is **ambigious grammer**. [**IMPORTANT**]
* To generate **aaa** we have more than 1-derivation tree so, the given grammer is **ambigious grammer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ed58daf-5673-46a5-bb7a-d94916fd93f6)

* [**IMPORTANT**]
* We want **different trees**.
* If we can find out two **different trees** then the given grammer is **ambigious grammer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42ae1f0e-2dc8-4bc3-8c29-ed6476ca7595)

* The given grammer is **unambigious grammer**.
* The numbers are for us only.
* We will see **final tree** only.
* Left most possible means right most is also possible.
* **Ambigious grammer** -> There exists atleast one string to which **more than one(1) parse tree** is possible.
* From the **given grammer** to generate a particular string if we can find out **more than one(1) parse tree** then it is an **Ambigious grammer** otherwise **unambigious grammer**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bd0e2e68-46c6-4ce0-af4c-e0892afc33dc)

* In **compiler**, every program should be **compiled**.
* We have created a **program** that is giving **ambiguity**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce20085e-9751-4aa5-89d7-8166fca0295b)

* 1 to n or n to 1 -> Types of loops.
* 1 to n -> LMD
* n to 1 -> RMD

## closure-properties-of-cfl-ii (33) [20th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec90654d-860e-4c27-8b13-4e778b25f5c3)

* The grammer contains **3-productions**.
* At the end of the day we have to replace **2-variables**.
* We are doing **left one** first.
* Read all **leaf nodes** from **left to right**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/226be33a-0ba4-4760-a15e-4e67cf54463c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ddab2f8f-5ada-48db-828a-8b315ba2e0aa)

* The trees are **both**, **LMDT and RMDT**.
* Only numbering will differ.
* Some people will expand **left side** first, some people will expand **right side** first.
* At the end of the day, we have to expand **left also and right also** which is **both sides**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d1fb1d0-4889-416d-8567-34cc92863cff)

* For a grammer to be **ambigious grammer** we have to show **two-different trees**.
* There exists atleast 1-string to which more than 1-parse tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63e18491-e1e5-4c5f-979a-d72a6e179466)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d44e06fd-4973-42e7-81fb-4cdab93dfb6c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/564f9684-26ae-4080-b1a7-029afdc1e9f0)

* Example
* This is **recursive grammer** so it will generate **infinite strings**.
* **NOTE**:-

1) To check if a given grammer is ambigious or not is **undecidable**.

* To solve a particular problem, time complexity is **infinite**. It means that it is **undecidable**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6df01b42-1ef7-4562-8f69-b041d40b7719)

* LMDT is there means that RMDT is also there and vice-versa.
* Find different **parse trees** -> It means that find different LMDTs and find different RMDTs.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16143d83-8ac9-4b46-a2b0-749a61b90ace)

## According to Chomsky, Types of Grammer

* There are **4-types** -> Type-0, Type-1, Type-2, Type-3.
* Type-0, Type-1, Type-2, Type-3 -> They are all **grammers**.
* Type-3 -> Another name is **Regular grammer**.
* Type-3 or **Regular grammer** will generate **Regular language** which is nothing but **finite automata(FA)** is also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ac2e118-3936-412f-865b-e33152c1409d)

* When we say **automata** is there means that **grammer** is also there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2cf7c67-de9b-443a-b1dc-32af25173f64)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4fa495a9-7cfa-43b7-aa30-851d73f5efc8)

* Regular Expression(RE)
* Every **regular grammer** will generate **regular language**.
* **Regular language** means **finite automata(FA)** is also possible.

* Depending on **grammer**, it will generate **one string** or **many strings**.
* **One grammer** will generate **one language**.
* **One automata** will generate **one language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92d847b4-5e24-42e5-ad35-fcadf3ce3a49)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df9bf45d-8f63-43a3-a22a-ef47afe227ab)

* **One grammer** will generate **one language**.
* **One grammer** cannot generate **miltiple languages**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30f729ca-bd9a-4707-b33d-6215ac91113a)

* The grammer generated one language which is **a ^ +**.
* **One grammer** will generate **one language** but **One language** having **multiple grammers**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51d2cfbb-91e3-4321-a2d1-59639f02a6dd)

* This will also generate **a ^ +**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc647a1e-d91f-45c3-9336-6b59979c80b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f869c73-59ae-442a-a92d-c7b3b0566fca)

* Type-3 grammer.
* Type-2 -> Context Free Grammer(CFG) -> It generates **Context Free Languages(CFL)**.
* **Context Free Languages(CFL)** means **Context Free Grammer(CFG)** should be there.

* Type-1 -> Context Sensitive Grammer(CSG) -> It generates **Context Sensitive Languages(CSL)**.
* **Context Sensitive Languages(CSL)** means **Context Sensitive Grammer(CSG)** should be there.

* Type-0 -> Unrestricted Grammer(URG) -> It generates **Recursive Ennumerable Languages(REL)**.
* **Recursive Ennumerable Languages(REL)** means **Unrestricted Grammer(URG)** should be there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dd26b43a-177b-4d28-a315-986f577a35dc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/188f3271-1cff-4847-92c0-c69ef9f7d174)

* **One grammer** will generate **one language**
* **One language** contains **multiple grammers**.

* **Type-0** has very less conditions.
* **Type-0** another name is **unrestricted grammer**.
* grammer normally means **productions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1147c6ef-ccfb-44aa-b609-ff792baee24b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/daba2a7b-2344-4334-adeb-79b1182fd14a)

* Keep anything on the **right hand side** of the **production**.
* **right hand side** of the **production** we can keep **variables only, terminals only, variables-terminals combination, epsilon**.
* On the **left hand side** as well keep **anything** but jut don't keep **Epsilon**.
* **Left** generating **right one**.
* **Plus(+) operator** -> Go inside atleast one time.
* In **Type-0** grammer **no condition** at all.
* If any grammer is **Type-3** then that grammer is **Type-0** also.
* If we give any grammer then that grammer should be **Type-0**.
* By default every grammer is **Type-0**.
* So, don't do any research on **Type-0**.
* In **Type-0**, **left is anything except 'Epsilon'** and **right is anything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/379322be-1156-4d16-9061-eaaef6d2afc1)

* Yes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4c08f72-fca8-4cdd-8c00-8d9fd981e628)

* Type-0

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/592d917c-90c3-4d2d-bdc6-13ce1b0e94d2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4bcc6e27-b57c-43fc-8886-f0420c84430d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/884ece30-f49e-4c7e-9352-7f9e8c8bf333)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/808cdb8f-bcd0-4121-a963-e36a0338a19d)

* Type-1
* Here, on both the sides(Left and right), **Epsilon** is not allowed.
*  **Epsilon** is not allowed on both the sides.
*  **Left** is **alpha** and **right** is **Beta**.
*  **Size of 'alpha'** is **less than equal to** the **size of 'beta'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51696c91-6bed-43da-8aac-b2efe94462a7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16515b69-4960-4c4a-b0e5-1120bca6d707)

*  **Alpha** deriving **beta**.
*  **Derived** should be **bigger**.
*  **Beta** is the **final product**.
*  **final product** should be **bigger**.
*  **Beta** should be **bigger**.
*  **Equal** also no problem but it(Beta) should not be **smaller**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8612cc3-eb0c-4bee-8729-34c9b5d21ced)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50e8238b-8f80-4a4a-bbaf-11c88db0f3a5)

* Type-2
* In the **Type-2** grammer on the **left hand side** only **single variable** is allowed.
* Normally we will use **CFG** only.
* At a time, **very big condition** is kept.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3257f104-af33-434d-9baa-63a501371752)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2180fc19-627f-4bbc-9906-814c8e043dfa)

* On the **right hand side** mostly there is **no condition**. Except **Epsilon** there is **no condition**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb07c113-5a5e-42c7-b8c7-733d096fa0fc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d9e80be-5871-4c2c-a5b1-177b25cd10ab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6bcfec8d-6e14-4b0a-83b3-f3c15958caec)

* **Type-3** is subset to **Type-2**.
* Conditions are **more** on **Type-3**.
* In the case of **Type-3**, What is allowed on the **right side**?

> Two models are allowed.

* Single Variable(V) followed by **set of terminal/terminals** which is **(V * (T ^ * ))** or only **terminals(T)** which is **(T ^ * )**.
* **Set of terminal/terminals** followed by Variable(V) which is **(T ^ * )) * V** or only **terminals(T)** which is **(T ^ * )**.
* In the first model **V** is on the **left side** and on the second model, the **V** is on the **right side**.
* **RLG** -> Right Linear Grammer.
* **LLG** -> Left Linear Grammer.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77aaacb2-6132-457f-865c-d5e158da31b9)

* In the given grammer, **every production** is either **Left Linear** or **Right Linear**.
* **Every production** should satisfy either **Left Linear** or **Right Linear**.
* In a grammer, few are **Left Linear** and few are **Right Linear**. Not allowed. Mixed is not allowed.
* Every **Left Linear** or **right linear**.
* Then that grammer is called as **Regular grammer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc4cb3d9-cab8-4b79-89c7-18b73c170bf2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/825b66dc-5ee9-4661-84fe-b5a42d0e0269)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3762cb1-23c7-4a5d-bcb9-0595768cc161)

* Example.
* Which type of grammer is this?

> Arrow symbol, go left side.

* Everywhere single variable? **NO**.
* If on the **left side**, everywhere **single variable** then the answer is either **Type 2 or Type 3**.
* Here, more than **single variable** is there. So the condition is **False** here.
* On the **left side**, we have **multiple variable** then the **answer** we have is either **Type 0 or Type 1**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f3834992-9d00-4a83-87e7-e3752e5ff8ed)

* By default it is **Type-0**.
* We have to **verify**, if it is **Type-1** or not.
* Condition in **Type-1**, **Size of alpha** is **less than equal to** the size of **beta**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37927193-d025-49b2-a85c-6a41e400f43f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b25d53d7-f563-4eae-8297-18ed31989a13)

* Condition of **Type-1** failed.
* So, it is **Type-0**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8957d9e5-b2ae-4ba4-8ce3-193519068ffa)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea756bc1-e710-4913-b74b-6d5f000d1425)

* Example
* We want to find the **type** of grammer.
* **Find Type** means we have to give **highest type number**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98db9bf3-d50e-434a-8af1-315de4c1b68d)

* **STEPS**:-

1) Frist go to the **left side** of the arrow.
2) Check if they all are **single or multiple variables**?

* If **single variable** then they are either **Type-2 or Type-3**.
* If **multiple variables** then they are either **Type-0 or Type-1**.

3) If it is  **multiple variables**, then it is by default **Type-1**. Check the **condition** for **Type-1**.

* Size of **alpha** is **less than equal to** the size of **beta**.
* From this we can say if it is **Type-1** or not.

4) If it is **single variable**,  then it is by default **Type-2**. Check the **condition** for **Type-3**.

* **Condition** for **Type-3**:-
* Left is **single variable** but on the **right side** it is **variable** followed by set of **terminals** or **only terminals**.
* In **Type-3** grammer, on the  **right side** multiple variables are **not allowed**. Single variable only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29dd8d88-1716-4033-831d-b6a5ef85fe7a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2308158-2360-419a-8440-d18c35776798)

* So, **Type-3** failed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c176239-a2c6-49f9-a43c-a55494cc7b67)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b1b5afa-d3d9-4a2b-9aa0-d236de84580c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4cac30fe-f0f7-4159-8240-fbbaa3804566)

* [**IMPORTANT**]
* We have to give **highest type number**.
* By default it is **Type-2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4a2d57d-3ea4-41b8-b3ba-7b77212ae4dc)

* Type-3 condition is satisfied as it is satisfying the condition of **Left Linear Grammer(LLG)**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93c453f1-b877-470f-8029-2ce27d684cb8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecf13adf-5a5e-4459-93e9-104baa64fd23)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/339fee95-0167-48ee-9ccf-0d33994f7da0)

* Satisfying **half LLG and half RLG**. It is not allowed.
* Wrong.
* It is not **Type-3**.
* It is **Type-2**.
* [**IMPORTANT**]
* Everyone should be either **left linear** or everyone should be **right linear**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f970b555-af6e-40eb-a0e0-d238f97bf3ed)

* So, **Type-3** is satisfied.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f373b385-b984-4936-a7db-e0fe54ed126a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d145244-f4fc-46f6-b0ce-5af9ca556316)

* Type-3 satisfied means **Type-2** also satisfied.
* **Type-2** is superset and **Type-3** is subset.
* When **subset** is satisfied then **superset** is also satisfied.
* **Type-2** satisfied means **Type-1** is satisfied.
* **Type-1** is satisfied means taht **Type-0** is satisfied.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5130e8ee-12df-4f9b-bce9-841236e14f58)

* We have to give **highest type number**.
* Type-3 satisfied means before all satisfied.
* We are giving **subset** means that **before all** are satisfied.
* Superset means we cannot subset.
* Subset means we can say Superset.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de768592-bac6-43b4-b39c-4c51de1a2180)

* Type-3 means Type-0 also. Exactly. **YES**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b0fa2f1-b547-4be4-96bf-fca405eecb6f)

* Exactly.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1ea459fa-b263-4c81-b643-bc633495d044)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/00864929-a055-493a-bffe-afab1b46f746)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83fa2fab-f935-4d6e-b01f-07951f7c15e4)

* Type-3 failed
* It is **Type-2**.
* **Type-2** means **Type-0 and Type-1** also.
*  Condition of **Type-1** is that both the side **Epsilon** is not allowed.
*  We have **Epsilon** on the **right side** so, **Type-1** is not **satisfied** here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e9cd4c2-e428-40f1-a093-c152e80fcccb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e463d0c1-8da5-49f4-adec-69409731b556)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/58b76364-7a10-4b52-8655-022d2b752e52)

* It is in violation of the **subset** property.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fa5e8043-5a3e-4f05-9e3f-736086615787)

* The **subset** property is **True** for **Epsilon-free** grammers. [**IMPORTANT**]
* If **Epsilon** there then the **property** may **fail**.
* Except **null production or Epsilon** it is fine.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f790a418-a2c9-42d0-a6a1-25fd9982f4bb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3dbab0c6-30b5-4828-b7a7-853a451c4780)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18f20958-9f65-4a49-844d-cbbe513d0224)

* Remove **Epsilon** and then try.
* **Epsilon-Free** then only **subset** property.
* **subset** property don't hold good because **null productions** are there.
* Except **null productions** then only **subset** property. [**IMPORTANT**]

## Context Free Grammer(CFG)

* It is **Type-2**.
* **Left side** is **single variable** and on the **right side** anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c63622a9-ed94-47f9-9eef-04f4ba7e2303)

* No relation between **a's and b's**.
* Only thing is that **a's should come first** then afterwards **b's** should come. Other than that there is **no relation**.
* Minimal string -> ab.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9a89e136-65db-4291-a94e-cd4461738b24)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18bd2be5-c054-43a4-8000-35e2ba0e55cd)

* The grammer will generate **any no. of a's**. **min. of 1-a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3b639b7f-3ef8-4f46-be75-cb32a5abb5df)

* Any no. of a's are coming and any no. of b's are coming.
* According to the **above** language, **a's** should come **first**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2de08957-548d-4c31-8926-d1a8fdc59ec7)

* Now, a's followed by b's will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/174f3cef-87e7-404c-8cf6-91ca662b4d94)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/04ab227a-66be-4eb0-9f77-6827a566ef83)

* Left side is **single variable** and **right side** we don't care.
* Our goal is **Context Free Grammer(CFG)** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f813438-d49e-49df-97af-f92dc7502cc8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dd4abaae-ae60-42aa-bd90-7d45f90e63b1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c7038a75-d432-4b23-8afb-3317aece97b0)

* [**IMPORTANT**]
* For any language, **CFG** possible then that language is **Context Free Language(CFL)** is also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6221bad8-4005-4264-9b8a-6de23cd49bc5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34d3f9b2-183d-402b-ae93-de11ad0fb9ae)

* Our target is **CFL and CFG** only.
* We are not talking about **regular language or regular grammer** here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32544fcc-bc60-4bda-b75d-9afe010abeb4)

* We are not interested in that here.
* Our target is **CFL and CFG** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d55ff99c-5fb0-4275-8ef2-c8f61d1257eb)

* Our goal is for **given language** write **CFG**.

## turing-machine-i(34) [20th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e3669f6f-1cb2-4488-ba03-0f291a16b343)

* Minimal String -> abb
* Before and after **abb** anything can come.
* anything means any no. of a's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8714fe59-09eb-459c-9979-eaf5f106c47d)

* Using this we will get **10 a's**.
* Repeat it 10-times and we will get **10 a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c449afbe-9ffe-4bde-b88e-e190985a7933)

* **A** replaced by **b** and we will get **b's** now. We will get so many b's.
* This is a **recursion** and every recursive program should have a **Termination condition**.
* **Epsilon** -> **Termination condition**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/422a143c-9ca1-4df6-a209-5cc323d8c2c4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70da987f-2f58-488c-8ae5-967c7320d52e)

* The **A** is generating **((a + b) ^ * )**.
* If we want only **b's** then start with **bA**.
* If we want only **a's** then start with **aA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6c6bb49-f17c-4a96-b205-9d7fe133de1a)

* **Order** is not important here.
* Anyone we can **start**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38e5871f-046a-48d8-ae69-e39ea7f77c51)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31aaec03-2b5e-492a-b2ad-3e21f1f61121)

* We are interested in **CFG**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/add743c0-80cf-4476-b98b-265065795878)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/94bf358a-8470-4901-87f7-08a508f40a84)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3e873d0-7068-4599-8f15-5950889b31b0)

* Correct.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8900acc-9d9d-45cc-bb5f-fcb80414b49b)

* **Grammer** will start from **start symbol** which is **S**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc1d25b1-4424-48ba-bbfc-bf322a1f91a6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/91d0a28d-7407-4360-b8f1-3be2f3e839f0)

* We cannot say **unique**.
* In **grammer** there is no **unique** concept.
* For all **Epsilon-free** things the **subset concept** works.
* For all **Epsilon-free**, **chomsky's heirarchy** will work out. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec61b2be-58b2-4590-b96e-98e80a4f4bcf)

* Example
* Minimal String -> Epsilon.
* It is something like **((a + b) ^ * )**.
* It is exactly like the **previous question**.
* We can repeat **baa** and **abb** any no. of times.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12cca71e-08d4-434f-83e0-6c3c6bfa0e50)

* **FA and PDA** both are possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9c30453-7a39-41e8-bd49-ca8ec1bcca6b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a038f163-17f8-46ba-8531-c3bfeae86c20)

* It is not regular but it is **CFL**.
* **CFL** means **CFG** should be there.
* **Every regular language** is **CFL** [**IMPORTANT**]
* Every **CFL** maybe regular and may not be regular.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cecaa6bd-5c68-4ec8-9fd3-0746a64babc8)

* Not only order is important but the no. of a's and b's are also important as there is a **relation** between the **a's and the b's**. [**IMPORTANT**]
* Some **equality** relation is there between the **a's and the b's**.
* If between two people **some relation** is there then **don't divide**.
* Without **division** only, we have to **generate them**.
* If **relation** is there we cannot **divide**.
* With one variable only we are able to **generate** both of them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17d7077e-4970-4677-be79-4f5a2ca37097)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9622f1fc-1ff5-4eb3-abe3-999c6d34837c)

* **S** replaced by **termination condition**.
* **Termination condition** is decided by what is the **minimal string** there.
* The minimal string -> ab
* So, the **termination condition** is **ab** only.
* Don't write **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b9d1a757-66a1-4c41-a2da-e9c434adfc48)

* [**IMPORTANT**]
* As there is **some relation** between **a and b**, as **one 'a'** came and along with that **one 'b'** also came. This is the meaning of **relation**.
* As **2-a's** came so **2-b's** should come. This is the meaning of **relation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae0af806-029a-47a3-9a27-6fcbed81e83b)

* [**IMPORTANT**]
* When we **divided** the **relation** is gone.
* **Relation** there means **we cannot divide**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34eae3eb-9697-43c4-b642-1f47b383dea0)

* Order is important but the no. of a's and b's are not important as there is **no relation between a and b**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d9fe8d3-7ff6-436a-99e4-2744ea89decd)

* Other than **order** there is no relation between **a's and b's**.
* **A** alone is generating **a's**.
* With the **A** we are generating **a's**.
* **B** alone is generating **b's**.
* With the **B** we are generating **b's**.
* As there is **no relation** we are able to **divide** them very easily.
* Whenever **no relation**, we can **divide**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c7a0224-e285-4c06-8856-7a08008ac13c)

* If a **relation** is there between **two people** then don't try to **divide** it. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1fb71dd1-738b-4327-9a37-7bd03f9caef2)

* [**IMPORTANT**]
* **Conclusion**:-
* If **relation** is there then **don't divide**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db63f79a-151c-4ddb-bb1f-ebbd59ebc5f0)

* Example
* Order is important and there is a **relation** between **a and b**.
* If **1-b** comes then **2-a's** will come.
* Minimal string -> baa [n=1]
* So, **baa** is the **termination condition**.
* As there is **relation**, so **don't divide**.
* The language is ending with **a's**.
* **Don't divide** means use **single variable** for them.
* Do everything with **single variable**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dfe7e15-e260-45db-ace2-d705630eba9d)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4579405-5656-4def-b3c4-7acb4bef4ffd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c852dcd8-28e2-4a3b-a73f-5be18daf8a7c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a07d237-36e8-4352-b664-fcffa907dea9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/301b6837-8b46-4132-b8de-63354928fe94)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/410beb3f-860a-4a8a-89e4-6b0ac84768ba)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36f31fa3-d3a1-4581-866c-e7ef25226327)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38a116d9-e17c-411c-b00a-d12fad5123ee)

* Order is important.
* There is no relation between **a and (b and c)**.
* There is a relation between **b and c**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1c27163-ce09-481c-a953-e44a07c77e07)

* It is **CFL** as **CFG** is possible.
* Left is **one variable**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb1e8e79-e554-4e86-9b00-8ecaab0a8178)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19defe40-3e0d-4a8d-8e0e-b2459e584881)

* We are able to write **CFG** so it is **CFL**.
* **a and b** are in **relation** but **(a and b) together and c** are not in any relation.
* Order is important.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6288b970-161c-4d38-9a2e-976ae1bf2871)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f553c0a2-0bdc-4b60-9da2-ffc84157cfbc)

* CFL.
* We are able to write **CFG** so it is **CFL**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2304a59e-70b6-4231-a79b-a6b6864da0d5)

* **S1** generating **L1**.
* **S2** generating **L2**.
* If **L1** is **CFL** and **L2** is also **CFL** then the **union** of two **CFLs** which are **L1 and L2** is also **CFL**.
* For **union** also **CFG** available.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65980032-cef5-461e-8bd6-dd0919d83923)

* This is the **union** language.
* Either **a and b** are **equal** or **b and c** are **same**.
* It is the **union** of two languages
* **m = n** means **a and b** are **equal**.
* **n = K** means **b and c** are **equal**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5831d8c3-a407-4990-8260-2f2927e5f753)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae3be57c-a625-404f-a852-2b2870ef6f2e)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bcbb90e8-9a61-458a-9b1f-a75e6652084b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bbdacb05-64b6-4119-bffe-8b6e9b9b4607)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/beeb9a68-6209-46d8-a60c-d52b31ee23ff)

* [**IMPORTANT**].
* If L1 and L2 are CFL's then **L1 U L2** is also **CFL**.
* **L1 intersection L2** need not be **CFL**.
* **a and b** are friends, **b and c** are also friends.
* The **intersection** part is that all three(a,b,c) are friends.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aeda5933-722e-4e43-bbf4-5fce0292701e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ba18fe7-36c3-47ff-ae66-bf4cff9e9a5f)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/27d01c81-4b92-47df-b3e4-253a5891bbb8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1633acf8-d914-4966-8aaa-a8caacace30e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/063f0cfe-9dab-4134-ab9a-6fcb5fba86c8)

* We have **OR** operator here.
* Which means **union**.
* Either **S1** or **S2**.
* Anyone.
* Two comparisons there but at a time both are not required.
*  At a time we don't have to **satisfy** both.
*  No relation
*  If first is satisfied then we have don't have to do the **second one**.
*  It is like **if-else** statements.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53b734aa-a39a-4490-af68-5b9d79a59d63)

* Either **if** or **else**.
* We don't need to do both.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d24682a-069a-490f-9c3d-763f8981aaaf)

* AND operator.
* Two comparisons and we have to satisfy **both** at the **same time**.
* We have two inner **for loops**.
* Both we have to do at a time.
* Two stacks are required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e4ba042-b098-4f0a-a952-c25a5576e16a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8b7e6a1-34ec-4a4e-b612-a1591e7b3c01)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/928f4ef2-aa86-42b5-9a64-fd561fccc82a)

* Relation is there.
* We have written, **CFG**.
* It is also **CFL**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f36c33a1-0bf4-4c0d-9286-a642fc985e94)

* Inside **ab** is not there, **(a ^ n) * (b ^ n)** is there.
* Inside **5a's and 5b's** are possible.
* Inside **10a's and 10b's** are possible.
* Because of **Star( * )** operator we can go inside any no. of times.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5fb3b2f-c2f7-4f08-9b4f-9daa4edaf50b)

* It is possible, we have to go inside **3-times**.
* **(a ^ n) * (b ^ n)** will give no. of a's **equal to** no. of b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71039f5e-2297-4a91-9b56-3595694711cd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40824f22-2952-444f-aff7-7476cf12368f)

* Please **add** the **SS** and **Epsilon**, we will get the behaviour of **(L ^ * )**.
* **SS** -> For many no. of times.
* **Epsilon** -> For **zero(0)** times also.
* **S** replaced by **SS**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09ff1dff-4689-402f-a209-fa0a8777ac79)

* If **L** is **CFL** then **(L ^ * )** is also **CFL** by adding the **two productions** extra which are **SS** and **Epsilon**.
* **SS** will give **repeatation**.
* **SS** will give **Klean Closure**.
* For the language **L** we have **CFG** and by adding **two productions** extra, we can get **(L ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ce09001-9b04-4826-bee6-e2e74c5cd642)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d5bf715-de29-456b-86ae-b6e8a6e524f7)

* If **L** is **CFL** then **(L ^ * )** is also **CFL**.
* If we just want **L ^ +** then don't write **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06e3dfdf-819a-4926-9ba6-63374b38c81b)

* Given CFG,
* L = {Set of all palindrome over alphabets {a,b}}
* palindrome -> Starting and last letter should be **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da79434d-f0a6-41d6-a6e8-e425233aff0a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de501262-7273-469c-9db7-42c344f41bff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/120806ac-d0ab-4406-a11c-4b4c73aefd8d)

* Termination time if we keep **Epsilon** then it is **Even length** palindrome.
* Termination time if we keep **a or b** then it is **odd length** palindrome.
* [**IMPORTANT**]
* At a time **two symbols** are coming. So, it is **even**.
* **Even + Even -> Even** palindrome.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/73a058ee-5d06-4bdb-9d76-9aeaaf8f4cb0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/04e26c15-a989-4f5e-b8f2-86e08188d511)

* **Even + Odd -> Odd** palindrome.
* First and last symbol are **related**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7843d347-b2e7-4aed-834e-1ce738460036)

* First and last symbol should be **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a1a474e-2288-400f-a87b-7fb27b7fad4b)

* Minimal String -> Epsilon, a, b
* Epsilon -> Zero(0) length palindrome.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83686b8c-f56d-4d0d-9ace-bc9c6980ae62)

## doubt-clearing-session (35) [20th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/deefabbb-2b35-4bce-93c0-80abf5787cfe)

* Example.
* a's will come **first** and then **b's** will come.
* If **no comparison** is there then how we will say that **a and b** are **not equal**. So, **comparison** is there. It is **equal or not**, we have to **comparison**.
* **Relation** is there otherwise how we will say who is **smaller** and who is **bigger**?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff0a878b-4277-4f90-b8b5-56cb91e07c6a)

* Yes.
* **a's and b's** are not equal.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/237f178a-99a4-440a-b88d-2842c5aad07d)

* Order is satisfied.
* Minimal string -> ab
* Termination condition -> ab.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7fc1c2e8-d061-46f9-9fcf-1abcb55e3f3b)

* Atleast **one 'b' more**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d186954-b275-49d4-867c-8139b77cbe19)

* If we want **a's** more then go for **second one**.
* If we want **b's** more then go for **first one**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7fb20060-047e-4264-9ee8-b75785af341a)

* There is a **relation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8820718-4156-4824-ad2c-24cf8aa44b1d)

* **m !=n** means either **m > n** or **m < n**. That's what we have to prove.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e0723d48-be52-4cf2-bd57-5f4048988128)

* Both the directions they can asy.
* Language to Grammer.
* Grammer to Language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b12dc70-cef1-4bf8-b9a3-367235f159c7)

* If we want to complete, what is the language for the given grammer?
* In the **language and grammer**, **minimal strings** find out.
* If **two options** match then for every variable, write the **language**.
* When **relation** is there, don't **divide**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/accfcc7b-0fcc-4fd5-a2fe-cc38ab49b3e6)

* [**IMPORTANT**]

* Given CFG, L = {Set of all valid balanced parenthesis}
* Opening coming means closed should come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5731e78b-2a58-4b33-821c-306641c41894)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/caa058f6-51fb-44b8-9946-22526a84d5ee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a1cf0e4-a9e3-4084-a515-e510437aa86e)

* In every valid program, **open brackets** will come first.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bca2fb1d-fd07-4657-a0f5-009c55109e70)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32564438-0483-471c-85a5-8d24e5c466c7)

* [**IMPORTANT**]
* Give CFG, L = {Set of all string of a's and b's where number of a's and b's are equal}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff863901-fed4-42c0-933c-b5db631b5442)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a910b1f-f715-428d-afb5-51247e4bd16e)

* Possible Combinations.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/375bfe0a-bed2-4eb0-96ef-ed3dae138752)

* Order doesn't matter
* No. of a's and no. of b's matter.
* There is **relation**.
* **a and b** should come at a time.
* If we write only **a's** coming then gone and if we write about only **b's** coming then they are gone.
* **a** came means b-should also come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5da3d59a-a826-4dfa-8c25-94960ee27516)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06691b45-f70c-4e42-872b-bb0f0a442ec6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b36f919-bb21-4ee6-9b81-edc3e88d6d44)

* [**IMPORTANT**]
* na -> No. of a's in the string 'w'.
* nb -> No. of b's in the string 'w'.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf37ef4d-18cc-491a-83f0-61cac00b78c2)

* It will accept all the string of 'w'.
* 'w' -> It is a combination of a's and b's.
* If there are **2-b's** then we have **2 * 2 -> 4-a's** in the string 'w'. 
* If there are **7-b's** then we have **2 * 7 -> 14-a's** in the string 'w'.
* If we write **((a + b) ^ * )** then **Epsilon** is allowed.
* **Epsilon** means we have **zero(0) b's** so, **2 * 0 -> 0-a's** we will have.
* 0-b's means 0-a's, so **Epsilon** is allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4054304f-b8cc-4bb3-a139-3fa13f78d4b1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/108722bb-e390-439b-ba10-db07390c1247)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9a914f5-7586-4e9f-a88b-39d49c5600b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d2afc91-0762-4b63-99b5-fc7d8be0a42c)

* Instead of **Star(*)**, we have **plus(+)**.
* Inplace of **Epsilon** write **aab|baa|aba**.
* Minimal String-> aab,baa,aba.
* That's why that's the **termination condition**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea6573ef-adab-414a-923a-9adefe67f02a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc96a534-eeb3-429c-a2a7-61c1797a6f97)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1b3be599-7ec1-4c86-86de-58a3c083d625)

* Very difficult to write **manually**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1004229c-3dd3-47b8-9c6a-f6c77d630538)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/811687c2-be77-4adf-8660-3e2a5edb5e2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b26fb07-2b1b-4142-b90c-aa3587d8afaa)

* Yes.
* Need to remember the **logics**.
* [**IMPORTANT**]
* Give CFG, L = {Set of all Arithmetic Expressions(AE) over the operands = {a, b, c} and operators = {+,-*,/}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7106067a-4b77-4c49-a848-297accefc12d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/175a67fb-7cf2-4284-b943-4113100a4e34)

* In the grammer terminology, **operands and operators** all are **terminals(T)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ba099659-39b9-4b7c-9f2b-383f7f614986)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/010d99cf-0d63-407f-ae3d-2c85ae22e37f)

* In **a + b * c**, the **star(*)** is done first.
* But we want **plus first** so **brackets** are required, which is **(a + b) * c**.
* If we want to make anyone **highest priority** then **brackets** are required.
* Keep **bracket** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/856af5d9-83de-43bd-bd06-da763aa177b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cf3b23f4-7cbd-45d2-9fac-5abec80746fa)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/014fdac7-722b-4685-9ec1-81ecbb5a03be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c982e402-198b-4fc5-a333-8541e48cf654)

* **Bracket** is an **operator**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e211416-ba6d-461d-a890-158444ce21f8)

* It is a **CFG** to generate all **Arithmetic Expressions** over the given **operators and operands**.
* Variable -> E
* Terminals -> Other than 'E', others are **terminals**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32bf98b4-f8c0-4bac-bc8b-125d70e168fe)

## turing-machine-ii(36) [21st Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/392082cb-a752-4311-b139-5112476baef1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/acf15518-3022-42c4-9760-a8edb82bd7b0)

* w = ab
* ww = abab
* (ww)' = Everything else except **ww(abab)**.
* We have to take care about **ww** pattern things.
* We don't want to see in the language, the behaviour of **ww**. Other than that everything should come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd0560e6-3e5b-4dc4-afd6-0985d238a026)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e575b4f-ab56-46b0-99b3-672e5923a4d7)

* Our language contains the strings that are **not in 'ww'** form.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/85b65aea-302e-496c-b45a-ab06de6fc37a)

* **Epsilon** can be written in **ww** form.
* So **Epsilon** cannot be in our language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f71a9f9c-1ec7-485e-a34f-dc87112ff4e8)

* **Odd length** strings are satisfying our language, as they are not in **ww** format.
* **Odd length** cannot be in **ww** format.
* **Odd lengths** cannot be divided into two **parts**.
* Our language contains **all odd lengths**.
* **Even length** people **maybe part of our language**, we have to **check**.
* **Odd lengths** we don't have to check also as we cannot make **two parts**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bbb408fa-b0cb-4541-8734-a57ae3c7bac2)

* **Odd lengths** directly say **YES** and **even lengths** first verify.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/48551d30-caa5-4034-973b-d4e7a322013d)

* Minimal string for our language -> a|b, a or b.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e575e844-a862-4e54-9037-746be11c088d)

* **A** will generate **odd length**.
* Every **odd length** string can be written as **((2 * x) + 1)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cad06bb1-23c8-4e05-b871-47bf744f253d)

* That **+1** is the **middle 'a'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62858125-9582-4b1b-8b75-d0e89eb15363)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/79a38793-0338-423f-90df-86d618b97573)

* Middle person is **a**.
* Middle is fixed
* **B** will generate all **odd length** strings where **middle** is **b**.
* **A** will generate all **odd length** strings where **middle** is **a**.
* If we **add 'a' and 'b'** then all **odd lengths** will be covered.     

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8329e97-0beb-4007-8eb4-55cffb08ac92)

* **C** will generate all **odd length** strings.
* Middle person can be **anything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/832f4177-ac42-43f6-a16a-77f631ac51e7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/542da8eb-4898-4b6c-9467-c0332446c821)

* It is actually **(2 ^ 4)** because the **middle 'a'** is fixed.
* Every **odd length** string can be written as **((2 * x) + 1)**.
* **((2 * x) + 1) + ((2 * x) + 1) -> 4x + 2 -> Even**
* Even(E) + Even(E) -> Even(E)
* Odd(O) + Odd(O) -> Even(E)
* **+1 + 1 -> +2** becomes **even number**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4129fd90-3b85-4140-ad9d-333f958d9864)

* Our language contains all **odd length**.
* **odd length** cannot be **ww** form.
* **C** will take care about **odd length**.
* Our language contains **some even lengths** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81707f08-7f06-4177-b602-10a248819e2a)

* **A and B** will generate **odd length**.
* Odd(O) + Odd(O) becomes Even(E) but even though it is **even** they will not be in **ww** format because in **A**, the middle is **a** and in **B** the middle is **b**. This two cannot be **equal**.
* The **middle** of both **A and B** are not **equal** so they are not in **ww** format.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25a92ad0-3ff8-4f26-9fe2-cdc350fac9b8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee847220-8cc0-45b2-b86e-5de47a5ff8f7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8befc77-5ac1-4bb0-ba01-0461945282bb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5197129f-b3d6-4320-94c6-4e0ab88fe7b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ee45b5e-68ab-4283-946e-c657f731a71d)

* **AB and BA** are covering all **even length** strings that are not in **ww** format.
* **C** is covering all **odd length** that cannot be in **ww** format.
* B -> Odd length where mid is **b**.
* A -> Odd length where mid is **a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80aa07c1-c553-4a1e-94db-fd62762ddedb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b418395d-3133-487b-afe5-ff4f7be8f966)

* **(ww)'** is **CFL** because **CFG** is possible but **ww** is not **CFL**. It is **CSL**.
* Example of a language where the **L** if **CFL** and **L'** is not **CFL** -> **ww** question.
* So, **CFL's** are not closed under **complementation**. 
* **ww** is **even length**. Not all **even lengths** are coming, they are not in **ww** form.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7c5c708c-b307-4fab-8069-9b5f30665eb9)

* If it is in **ww** form, then we can **divide** it into **two parts** as **ww** are **even lengths**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb388d5a-f033-4953-9f17-72a3f0f6d51e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1135031-10eb-4989-9cc2-2a75ee151284)

* 2-stacks.
* Check the people in the two divided strings.
* We can't do the **comparision** with **only one stack**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32378352-c2e4-4504-9ce8-fa504b4325e6)

* Stack contain **only 'top'**.
* In the **ww**, we want to compare **two w's**. We want to compare the **first and the second w's.**
* Keep the **first 'w'** in the **stack**. Second stack is in **input buffer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ebe1560d-e7c3-47ca-940a-5dbdcfb2cebc)

* We can't compare now as **first 'w'** in the **stack** and the second stack is in **input buffer**.
* If we want to do **comparison** then both the **w's first symbol** is required but the **stack** is giving the **last symbol** and the **input buffer** is giving **first symbol**.
* Indirectly, with **one-stack** we cannot do.
* In place of **stack** if we take **queue** then it will **work out**.
* Queue is **FIFO** property.
* Queue is giving the **first symbol** which we want and the **input buffer** is giving **first symbol**. Now, we can do the **comparision**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7049ada2-ab41-421e-b3a7-1ba12627ee38)

* PDA -> FA + 1-stack only
* 1-stack only and not **queue**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd50db87-7a73-48ec-8379-42023df935d9)

* PDA.
* We can implement **queue** with **two stacks**.
* **Queue** is nothing but **two stacks** we are taking.
* **Queue** property can be implmented with **two stacks**.
* We are taking **queue** means, **two stacks** we are taking.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/feb5f3bc-387b-4073-85a3-4f435dd04895)

* **S1 ans S2** are **stack**.
* Pop the symbols from **S1** and push them into **S2** and now the **two stacks** are acting/working like a **queue** which we want.
* In **S1**, **C** was the **last symbol** and it was at the **top** of the stack(S1)**.
* Also **a** is the **first symbol** and it is at the **top** of the stack(S2)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/43c748db-809b-4970-a228-3bfb97051790)

* CSL(Context Sensitive Language).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f273c260-cbe7-4e08-bb00-9885c4cf67c7)

* How many **symbols**?

> Total is **2n** symbols. (a * n) * (b ^ n)

* Turing machine contains **2-stacks**.
* LBA contains **2-stacks**.
* The size of the stacks we are taking in **LBA** is **limited** in the form of **input size**.
* If the **input size** is **2n** then we have to take **LBA** where the stack size is limited to **input size** only.
* LBA stack is restricted by **input size**. This is a **limitation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3b818acd-8d64-4125-9ea2-c5ee44a5b785)

* The size of the stacks we are taking in **tuning machine** is **unlimited**. We can take the **stack size** as **infinite size**.
* No **limitation** in  **tuning machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0d07646-07f4-4e4b-9e27-53fee1788c62)

* If the **input** is **n** and we are taking the **stack size** as **n** then it is **linear**.
* If the **input** is **n** and we are taking the **stack size** as **n ^ 2** then it is **quadratic**.
* If the **input** is **n** and we are taking the **stack size** as **n ^ 10** then it is **polynomial**.
* If the **input** is **n** and we are taking the **stack size** as **2 ^ n** then it is **exponential**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a4f69b0-1087-4a62-bdc9-56f202905c4b)

* **LBA** stack is also **infinite** and **tuning machine** stack is also **infinite**. Both are having a lot of space. But **LBA** stack space is **restricted by input size**. Based on the **input** it is restricted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b28db52f-ef70-496e-afc1-cfd8b8805ace)

* Either both there or both not there.
* L and L' both are regular.
* L and L' both are not regular.
* One is regular and one is not regular, it is not possible.
* L is **CFL** and L' is **not CFL**, it is possible.
* That's why it is **not closed**.
* L is **CFL** and L' is also**CFL**, it is possible atleast sometime.
* **Closed** means everytime, it should be possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c6ea837-8757-4a64-b637-e61eaf21543f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f55da34a-7ea6-408b-8168-6aae35d4e426)

* It is **palindrome**.
* All the thing that are in **w and w ^ R**, they are **palindromes**.
* Any string/thing we can write or is in the form of **w * (w^R)** then they are **palindrome**.
* PDA contains **1-stack**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f917b903-1802-433d-ade3-93c9296e842f)

* **w** is in the **stack**.
* In **stack**, we can access the **last symbol**.
* **w ^ R** is in the **input buffer**.
* If the string is at all **palindrome** then **'w' last symbol** and **'w^R' first symbol** should be **same**.
* It is **palindrome propert**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c36a1bb-a901-435e-8db2-01024df4f55a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c9a8da2-8502-48eb-86a9-6b911f092df9)

* **Palindrome propert** checking.
* We can verify if some string is **palindrome** using **1-stack**. **YES**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8373715-8e3c-4c8b-81ad-b2ac18edf390)

* If **CFG** is there then **PDA** is also there.
* We have done **CFG** till now.
* Palindrome ->  w * (w ^ R)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff463d0a-95e2-4cf4-85f0-2cd5f743a95b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e0fe611-e93b-4fb5-891e-4ae0d70c8355)

* **(w * (w ^ R))**.
* If the string is at all **palindrome** then **'w' last symbol** and **'w^R' first symbol** should be **same**.
* **(w * (w ^ R))** -> Palindrome, CFG, CFL, PDA -> All there.
* ww -> CFG not there, so **PDA** also not there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88c32025-58da-41a5-a41d-fd773c28e75a)

* **(ww)'** -> CFL
* **ww** -> Not CFL
* **L** is **CFL**, **L'** maybe **CFL**.
* **CFL** are not closed under **complementation, intersection**, remaining things are **closed**.
* Regular means **CFL**.
* **Every regular** is **CFL** but **every CFL** need not be **regular**.
* **CFL** is **superset**, **regular** is **subset**.
* If **smaller machine** is **satisfied** then the **bigger machine** is also **satisfied**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b391129-fb05-4d93-b89c-ff22e1ad481b)

* Problem. [**IMPORTANT**] 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb5d8b25-bbd9-44b3-b39a-c21c0e748d5d)

* Example
* i=3, k=2
* j = 3 + 2 =5.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f478c1da-aa00-4806-903d-d0e0f90f9d5b)

* **b** having **two friends(a, c)**.
* 'a' coming then 'b' also coming.
* 5-a's then 5-b's there.
* 15-a's then 15-b's there.

* 'b' coming then 'c' also coming.
* 5-b's then 5-c's there.
* 15-b's then 15-c's there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66c9494b-35a8-42b2-b521-b2381053c500)

* We are getting, **(a ^ n) * (b ^ (n + m)) * (c ^ m)**.
* We are getting **b's two times or twice** when **a and b, b and c** are coming. So **b** coming **two times**. As **b** is linked to both **a and c**.
* **b** coming **two times**, once with **a** and once with **c**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b2c0a6dc-340b-49c1-86ac-819ce9dc71f6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f7f3183-d82d-4ee2-8912-7a415c463785)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e11989e-fdd7-45e5-854b-fad7b712ce29)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77b82493-d9fb-4372-9da6-063918cad686)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e8da4cf-5578-41df-bf86-f0256ceee96c)

* They are **everything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23296792-2c2a-4667-8b03-7cdba6cf739a)

* There are **two conditions**.
* We have **OR** operator between the **conditions**.
* So, we don't have to satisfy **both the conditions**, satisfy **anyone of the conditions**.
* **Anyone** means **CFL** is possible.
* **OR** operator means **anyone** satisfied is **OK**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6fdcfcc2-07a6-48c4-b39f-6a39af967f6b)

* Comparision is going on between **a's and b's** that's why we kept some **relation** between **a's and b's**.
* Comparision is going on between **b's and c's** that's why we kept some **relation** between **b's and c's**.
* If we use **A** at a time then **a's and b's** are **equal** will come.
* If we use **B** at a time then **b's and c's** are **equal** will come.
* **C** will generate any no. of **c's**.
* **D** will generate any no. of **b's**.
* **E** will generate any no. of **a's**.
* If we take **C** then we will get **min. of 1-c**.
* If we take **D** then we will get **min. of 1-b**.
* If we take **E** then we will get **min. of 1-a**.
* If we take **A** then we will get **min. of 'ab'**.
* If we take **B** then we will get **min. of 'bc'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98c52c95-7c56-4af0-8b04-c9d6cfa7dcd1)

* We ware satisfying **first condition(i < j)** then **a's** are **less** than **b's** or **b's** are **more**. **c's** can be anything, we don't need to bother about **c's**.
* In **first condition(i < j)** bother about **a's and b's** only and **b's** is **more** which we also have to bother about.

* **A** will generate **a's and b's** equally. But according to **first condition(i < j)**, **b's** should be **more**.
* Who will generate **only b's**?

> **D**.

* Just add **D** after **A**.
* Definitely **1-b** extra.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e9e54a1b-9dd4-468f-aeff-d09ee3078182)

* First condition is satisfied and any no. of **c's** can come afterwards so put **C** at the end.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef0676f2-8e71-4b32-9b54-56c80331109b)

* We ware satisfying **second condition(i > j)** then **a's** are **more**. **c's** can be anything, we don't need to bother about **c's**.
* So take **A** first which will generate **a's and b's** equally. We want **more a's** according to the condition so add **E** at the **starting only** before **A**, which will give **only a's** and at the end for any no. **c's** add **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/029fc601-9578-47e7-8004-abdab68708f7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/458eb8ea-e0e7-4d6b-8b8e-025eb3e2f235)

* We ware satisfying **third condition(j < k)** which is between **b's and c's**. **c's** are **more**. **a's** can be anything, we don't need to bother about **a's**.
* So take **B** first which will generate **b's and c's** equally. We want **more c's** according to the condition so add **C** after **B**, which will give **only c's** and we want any no. **a's** so add **E** at the **starting only** before **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0d9f9c2-ddb0-4da8-ba96-8134bbac1724)

* EBC

* We ware satisfying **fourth condition(j > k)** which is between **b's and c's**. **b's** are **more**. **a's** can be anything, we don't need to bother about **a's**.
* So take **B** first which will generate **b's and c's** equally. We want **more b's** according to the condition so add **D** before **B**, which will give **only b's** and we want any no. **a's** so add **E** at the **starting only** before **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cda90e59-56d6-4de0-be85-522b4ab648b6)

* EDB

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1574364-627d-42a6-bd34-9a8379c32ab5)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f50bc06-65c3-4f87-83e1-ee3a09697e73)

* [**IMPORTANT**]
* For **AND** operation, we need **two-stacks**. **1-stack** won't work.
* For **AND** operation, all are **required**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82479763-bc8f-43f4-886f-4e133894c19b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f870736-8ad3-4d07-bd07-298ea273a9a8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/658911b5-3de9-461b-8c94-31196cb18d0e)

* If **OR** operator then **1-stack** is **enough**.
* For **AND** operation, we need **two-stacks**. **1-stack** won't work.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5cbc371-0720-496d-889a-64a9c0a1d448)

* [**IMPORTANT**]

## turing-machine-iii (37) [21st Sept 2023]

* LHSP -> Left Hand Side Production.
* CFG -> **Single variable(SV)** on the Left Hand Side of Production
* Right is **anything**
* For every **CFL** there is a **CFG**.
* For every **CFL** there is a **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d8bb70a-c3b3-44d7-90c0-7948ba9083c5)

* If anything is **CFG** then it is **CSG** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/370d081a-16e2-492b-9af2-da1df68adcc3)

* Every **regular** is **CFL**.
* Every **CFL** is **CSL**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e810e02a-e90f-452f-9a95-ef6f49589e55)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c39d49fb-665f-4f69-87f9-d8abc94c81b3)

* C-CGF -> Conplicated-CFG
* any **Conplicated-CFG** is given. What is the language(L) it is generating?

> Check minimal strings(first, second and third). Check in the **options** which are matching. **options** contain **languages**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/72436ed6-e2fe-4636-bb65-a412c124be9a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e1959dd-9363-4f3c-82f1-292004cd34f8)

* MSQ.
* Sometimes **one option** is **correct** also there in **MSQ**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f571977-2399-4ae0-af57-befb68fcbff7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/60597bd6-d6e5-4bd2-874a-a7df0c397882)

* Any combination they can ask.

## PDA construction

* PDA -> FA + 1-stack.
* **FA + 1-stack** where the **stack** can accomodate only **100 symbols** which is nothing but **finite automata(FA)**.
* There is no use for the **stack**.
* **Finite things** can be remembered by **finite automata(FA)** not only **stack**.
* The **stack** can remember **infinite things**.
* With the help of **finite automata(FA)**, we can anyhow remember the **Finite things**.
* In the **PDA**, the stack can accomodate only **1-lakh symbols** then what is the language of the **PDA**?

> **Regular language**. It can only do **finite things**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fdeb92c-a7f2-4218-b44d-e4a3439b7707)

* **LBA** stacks is **infinite** only but the only problem is that it is with respect to the **input size**. It is **linear** to the **input size**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96b12a82-6e79-41c1-97f1-d6ddef2a34c3)

* 100 a's.
* To the particular language **finite automata** is possible.
* **PDA** is both **FA and stack**.
* **PDA** is also possible.
* To solve the above language, **FA** is **enough**.
* **PDA** contain **FA + stack**.
* If we want we can use **stack**. If we don't want to use, it is ok.
* Given **two(FA + stack)** doesn't mean that we have **two**.
* If we want we can use **both**.
* If we want we can use **one**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31f69fd0-6109-4077-b768-b39ca4d265bc)

* Language is accepted by **PDA**.
* Language is accepted by **finite automata** itself.
* **PDA** means **finite automata + 1-stack**.
* We will use **finite automata** only.
* It is **regular(RL)**.
* **regular(RL)** means it is **CFL, CSL, REL**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dadc5014-a167-46ae-a064-fb634abb70c8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb2a2859-bbdb-40cc-8756-c8ff37d1054b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f8afbc9-b013-4b34-86c0-9155278d94b4)

* It is an **infinite language** and **no condition** also.
* **No condition** means **no comparision**.
* As there is **no comparision** so with **finite automata** we can handle.
* For the language **L2**, **finite automata** is possible.
* In case of **PDA**, **finite automata + 1-stack**.
* We don't want to do anything in the **stack** because whatever we wanted to do has been done by the **finite automata** only.
* When will **stack** start?

> When **comparisions** are starting then **stack** will start until that time **stack** is relaxing.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1a7deee-1f2b-4c8f-ad62-fa9d4edd01be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5437800e-3bfe-4b7c-a892-21bddbfcc279)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3cc0977-c7ae-45da-ae2f-8b6b2234ab47)

* When **(a ^ n) * (b ^ n)** comes then **stack** will start working as **comparisions** are coming.
* **PDA** can do whatever **FA** can do **plus(+)** extra also.
* **FA** is called as **5-tuple** machine.
* Because of **stack**, some **stack** related things will come.
* **PDA** is nothing but **push, pop and skip** operations only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5cfd262-9133-4f0b-9800-e328e5a2399d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2941c68-9b23-4429-a8c9-c5bea50ca9d6)

* We don't want comparisions.
* So, **stack** not required, **FA** can do it.
* So, **push, pop and skip** operations are not required here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ee49c88-399a-4ad7-9dfd-d8feb1631585)

* Suppose on **S1** stae 'a' as input and top of the stack is **Z0** then go to **S2** state and **push(x)** in stack.
* Before **push** operation, the **automata** is at the **S1** state.
* On **S1** state, **a** input symbol came.
* Top of stack is **Z0**.
* After **push** operation is over then the **automata** is at the **S2** state.
* Previously at the top of stack is **Z0** and after **push** operation is over, the top of stack is **X**.
* In **stack operation**, the **last symbol** is always visible.
* It is going from **one state** to **another state**. This is called as **transition function**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/20cd1a4c-41af-47b0-a576-7872d1f511bd)

* Only **Z0** is there doesn't mean **top of the stack** is empty, only one variable is there which is **Z0**. I wrote it wrong in the image above.
* By looking at the **top of the stack**, we have to understand that **push operation** is performed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a91630f1-c6a7-42fd-bffa-4ef1c6b8608d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3283b3d-6ba9-4149-9903-e9aa6d24e39c)

* [**IMPORTANT**]
* Before **push** top of the stack is **Z0** which is **1** symbol.
* After **push** top of the stack is **Z0, X** which is **2** symbols.
* **1** became **2**, so it is **push** operation only.
* **Push** means **1** extra symbol coming.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecebc624-fede-4650-9ab7-d378cb220214)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae7fece8-798f-4007-806f-6fbbd73533e4)

* Before **push** top of the stack is **Z0** and now also **Z0**. Symbol not increasing or decreasing, **Skip operation**.
* This is exactly **skip operation**.
* In the stack, we are not doing anything.
* In the **input** we read **a** and we went to **S2** but in the stack, we are not doing anything. This is **skip operation**.
* At **S1** state, top of the stack is **Z0** and at **S2** state, top of the stack is **Z0**.
* We have already read **input 'a'** but in the stack, no change.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/033b8e5f-ab00-443c-85ec-96fc52e3b742)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d434c7a-6350-4b06-9f4e-e5909bc75ddc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82d75faf-25b9-4d46-937d-7fbac9cb4773)

* Push operation.
* 1-symbol became 2-symbol, **push operation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62ed75de-d3e8-4a57-afeb-15fc776b73a9)

* Skip operation.
* 1-symbol became 1-symbol, **Skip operation**.
* **X** is the **Stack alphabet**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a73087c6-57d4-4421-915a-63ecb50db3b4)

* Only the **top of the stack** matters.
* Stack means **top of the stack** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d053f0ad-3037-41c3-9d6b-a60c9575026a)

* Previously the **top of the stack** is **x**, the **top of the stack** is **deleted** and we have **Epsilon** now.
* Previously **1-length** is the **top of the stack** and now **0-length** is the **top of the stack**.
* **1-length** becomes **0-length** means **pop** operation happened.
* **x** is **1-length**.
* **Epsilon** is **0-length**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2cc8b543-8bf3-4e5e-b624-0ceafb66790a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/508fb8d9-491a-466f-999a-15e75ffe14d7)

* **Epsilon** is saying that whatever the previous **top of the stack** was there, that one we **deleted**.
* It doesn't mean that **stack doesn't have anything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e9c5a8d-e852-4e0b-9547-51c9402bd1e2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c69847c-2de7-4982-9a79-aa8d07b71c3e)

* Pop operation.
* 1-length top of the stack becomes 0-length top of the stack then it is **pop operation**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19c90959-ee70-47e3-ad7f-bbbb3d6a6ba7)

* Stack can only see **top of the stack**. It cannot see **below**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ed44a1f-14d4-4c00-97f4-c94b427a40e0)

* Nothing to do in the **stack**.
* This can be done by **FA**.
* In the entire **diagram**, the **top of the stack** is **Z0** only. Nothing changed.
* Entire problem the **top of the stack** is **Z0** only.
* If we don't want then **don't push**.
* If we don't want then **don't pop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/85a30ea0-966a-46c1-b5e2-11753d8495d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9933f9b6-73d8-4da9-bc89-eeec4fad50b9)

## doubt-clearing-session(38) [22nd Sept 2023]

* Transition Function for **PDA**.
* Any state within the **Q** and applying anyone of the input symbols that are present in **Sigma** and by seing anyone of the symbols which are in **top of the stack(K)** then we are going to anyone of the states that are in **Q**. In the stack we are doing some operation. One of the symbols that are on **top of the stack(K)**, we may keep **more than 1-symbol**, we may remove the existing **symbol**, we may keep the existing **symbol**. It is like **(K ^ *)**. One of the combinations will happen. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fff9a7d8-d939-4825-b0e0-f982ec6e7f5c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/399a3f96-2f5f-4f4c-838d-4604c633feb3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05f062db-c317-4e22-9b6c-2bd46a980689)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b35cd3d-c031-46f2-aed2-24345b36d1ac)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a48964c5-299e-4dbe-b152-5b05fa5ccc99)

* [**IMPORTANT**]

* When we know **string** is over. **Dollar($)** is coming which means **string** is over.
* The person who is doing **pop** he is doing **push** as well.
* When we see **Dollar($)**, **b's** are over.
* Stck is celebrating **a's** are over.
* For **every b's**, **a's** is cancelled.
* So, **no. of a's** is **equal to** the **no. of b's**.

 ![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96994d81-63f0-4cbd-ae04-fac065654962)

* **1-a** and **1-b** are popped or 
* For **every b's**, **1-a** is popped.
* **b's and a's** are over means that **no. of a's** is **equal to** the **no. of b's**.
* Next symbol is **Dollar($)** is coming and the top of the stack is **Z0**. It inducates that **successful completion**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad0ad350-3ce5-4bac-91c2-d656d1ae97bd)

* If **Dollar($)** is not there then **Epsilon** is the **marker**.
* Some **end marker** required.
* By default marker is **Dollar($)**.
* **Input bugger** -> Place where people can give input.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2d755bc-a02f-406f-82dc-a611f73a81e8)

* Initial marker, i = 1.
* **PDA** also having **stack**.
* Stack is initially **Z0**.
* **PDA** uses **FA** also.
* Initial **automata** is at **S1** state.
* For **S1** state, **a** is coming and the top of the stack is **Z0**. By seeing **a** we will go to **S2** ok. In the **stack**, what we want to do?
* Whatever is the **input**, we are keeping it with **Z0**.
* The **top of the stack** is **a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ad3eee4-69a0-4c45-a538-cbb941569df4)

* On **S1** state, **a** is coming. Top of the stack is **zero(0)**.
* We will go to **S2** state and on **ZO** we will keep **a**.
* **S2** state means **1-state** is over.
* In **S2** state, we can push any no. of a's.
* **S2** state indicates that atleast **1-a** is pushed.
* Loop may come or may not come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a0e71ca-6e37-4ead-8648-7238893ca2c2)

* We don't want to accept **Epsilon**.
* On **S2** state **b** is coming, next symbol expected is **b** and symbol **a** is at the top of the stack.
* Previously, top of the stack was **a** and now it is **Epsilon**.
* Came to **S3** states means that we have seen atleas **1-b**.
* For the **b**, we have popped **1-a** also.
* We are in **S3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5762416c-7445-4834-86dd-e99ec29c435f)

* We want to **pop** every **a**.
* On **S2** state **pop** is going on that is **first pop**.
* On **S3** state **pop** is going on that is **remaining pop**.
* In **PDA**, we never see **min. no. of states**, how many.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c982ca9-d3ad-45a6-b21a-d835b90daea1)

* For **every 'b', 'a' is popped**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fabda08-89dc-4085-a501-ea1a896dc691)

* **S3** means for **every b's** there is an **a** pop.
* At the end of the diagram we are at **S4** state.
* **S4** state is also **final state**.
* At the end of the string we are in **final state** then it(string) is **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/452ad50b-43f3-42b8-83f0-48e6376dc237)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/defca0d7-b4a5-451b-976d-6ec201a4a9b8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/618de884-608b-47e9-8406-b6e6193a7776)

* That is the reason it is **(a ^ n) * (b ^ n)**.
* There is **relation** between **(a ^ n) and (b ^ n)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38fbba72-c00d-4b96-ba2b-eb5a644c1866)

* Which state we are in, which input symbol we are getting, what is on top of the stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/683c1276-1c5f-4c62-a0e4-e23f5a457bf4)

* For taking decision, these things are required.
* **PDA** construction is **not unique**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2b5c21a9-83f4-4311-b582-88aa9a2d3903)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1228017-bf4f-40bf-a128-a88746613aa9)

* On **S2**, **b** is coming and **a** is at the top of the stack.
* For **every 'b'** pop.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/90499d5e-4b35-4bea-a31b-a489cc4dd89b)

* **Epsilon** means **b's** over.
* **a's** is also over, so the top of the stack is **Z0**.
* We will remove the **Z0** also and go to **S4**.
* We haven't kept any **final state** in this.
* No **final state** but still the string is accepted.
* In the stack, no symbols are left out including **Z0**.
* At the end of the story if we can make **stack** completely empty including **Z0** also not there then we can say that the **string is accepted** by **empty stack**.

* In **PDA** string is accepted in **two ways**:-

1) **Empty stack** -> This is **PDA** acceptance by **final state**. At the end we are in **final state** or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25ca4f72-8534-4cc9-a93a-59170423a6fb)

2) Final State.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7fb2aee2-8c45-4b02-9511-b961b412a6b9)

* **Final State** possible means **Empty stack** is also possible.
* **Empty stack** possible means ** Final State** is also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/addc83b7-423c-4e83-bbef-00ad5eb2ff35)

* PDA acceptance.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37d7e213-bb59-4e25-864a-c4e17429d595)

* Minimal string accepted is **ab**.
* Take care about all **valids** are accepted. **Invalid** cannot be accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b5346c4-e8b3-4f4a-842f-7a420e42ed90)

* Two ways are there.
* [**IMPORTANT**]
* First decide which way we want to **construct** and then accordingly decide what to do next.
* When we are constructing **final state** don't worry about **empty stack**.
* One is possible means other one is also possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1ff82b4-7daa-41fc-8447-8b24aba3d7ab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/310afc10-4bec-4d3a-97a0-7d25afe5e9fc)

* So many **a's** we want to push.
* On **S2**, **b** is coming and on top of the stack it is **a** and **pop 'a'**. We are going to **S3**.
* For **every 'b'**, pop **1-a**.
* So many **b's** are coming.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae4a2bf0-2423-4d4a-8a6a-c428c8eed520)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d599fe3e-68dd-4c73-afa7-17aee64e0fec)

* **Epsilon** is coming as **b's** are over, still **a's** are there.
* **a's** are more.
* **m** is more/greater as **a's** are more.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d7f4f6eb-1aa9-4dc4-a124-5dd37490e03b)

* m > n
* [**IMPORTANT**]
* Still **b's** are coming and at the top of the stack it is **Z0** then **a's** are over and **b's** are coming.
* **b's** are more.
* **m** is less as **b's** are more. So, **n** is more/greater.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a620a8ca-dab5-4559-a9f6-2c3bb5879d33)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/33380b22-ea39-42ac-a341-83702986d861)

* m < n.
* [**IMPORTANT**]
* It is accepting for **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77778f2b-4275-48cd-913e-ec04ae2dd847)

* Two problems.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5a916a1-f29d-4155-8a6c-a27dfb519ad7)

* May not be.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2201feaf-90b0-4efd-9700-e48f0936691a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6bfeec77-f157-4beb-afbb-c2ea40c072cc)

* **Epsilon** is coming still and at the top of the stack it is **Z0**, pop **Z0** as well. Why going to another state. We want empty stack.

* **b's** are over and still **a's** are coming.
* **b's** are over and top of the stack is **Z0**. Remove **Z0** also.
* At the end of the story, **stack** is empty.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5bdf595-ed4c-499f-90f1-0f0f891f68b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c2e5920-429a-43a7-94f8-b1a59393b812)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac9cba34-814f-4f31-ae85-0983f4547eff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfb11ab7-eab1-4360-ac25-2e354202ac4a)

* We are able to cover everything in the **stack**.
* Our goal is **a's more**.
* Don't worry that much about **states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b0030ac-0413-4cbb-8f8e-956ada2fd9a0)

* **(a ^ m) * (b * n)** is accepting.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c3aa3ba-4b19-44b5-8cfe-311d89498f86)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b22c636-d486-47cd-a137-24b49b3ab76c)

* Example
* Minimal string -> Epsilon
* We are trying to do with the **PDA acceptance** of **final state**.
* First **a** is pushed and afterwards any no. of a's are pushed.
* In **S2**, **b** came and **a** is in the top of the stack**, so for **every 'b'** pop **1-a**.
* Any no. of **b's** also pop.
* **S4** is **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3b3a5c92-4b8f-4e1c-9388-12812a964832)

* It will cover **(a ^ n) * (b ^ n)** where **n >= 1**.
* **Epsilon** is missing.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b95e519-6a0a-43f6-910b-b3a20e1cd3e2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e6be1e83-9e63-43e2-943b-dfe09c8aba50)

* Starting itself **Epsilon** coming and at the top of the stack we have **Z0**.
* Some marker needed.
* At the end of the string, we are in **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f66c997-4b09-4779-8c33-f9c73f7295bb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bdf7b4ba-2fd6-4ded-a3d2-9003fc32cad8)

* Either **'a' more or 'b' more**, we are stuck at **S3** state.
* **PDA** construction is **not unique**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b735417-df93-4fd4-b90d-4a61b51ac4b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/163d01ca-3ede-44a2-a71b-32b0a806f1ea)

* Everything should be **accepted**.
* We don't want to remember anyone in the **stack**.
* We can solving the **above problem** without **stack** only.
* In the stack, we are not doing anything.
* Everytime **skip** means we are not using stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ef4b870-1193-42fe-aad4-0719252fd40a)

* [**IMPORTANT**]
* na(w) -> No. of a's in the string **w**.
* nb(w) -> No. of b's in the string **w**.
* Out of all the strings, we are accepting those string which have **a's and b's** as **equal**.
* Order is not important here, **a's and b's** only required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e12c7a83-48b6-4e89-843e-80bf54bad5a6)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ac4166e-554f-42e2-aa89-082cc094baab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc5872df-055b-4dbb-84ad-7c76dcf2638a)

* [**IMPORTANT**]

## uncountable-and-countable(39) [22nd Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1beebbde-504e-418f-b861-6d576050342e)

* Example
* Order is not important.
* Stack contents are important.
* **Relation** is there, **no. of a's** is **equal** to the **no. of b's**.
* **Relation** is there but **order** is not there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e95f997-4184-4f3d-9294-c83598e24d03)

* String is starting with **a** and the top of the stack is **Z0**.
* First **a** is coming in the **stack** so **push** the **a** into the stack which is **Z0a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9572728f-c656-45f5-9afc-67637132aecc)

* **a** is coming and at the top of the stack is **a**.
* On **a** once again **a** is coming.
* If string is starting with **a** and so many **a's** are coming **push** all of the **a's** in the **stack**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a58049d-b590-4c92-81e8-af67c9f2fffc)

* String is starting with **b** and the top of the stack is **Z0**.
* First **b** is coming in the **stack** so **push** the **b** into the stack which is **Z0b**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0be0073d-8b36-4e4c-a150-32af098c206c)

* **b** is coming and at the top of the stack is **b**.
* On **b** once again **b** is coming.
* If string is starting with **b** and so many **b's** are coming **push** all of the **b's** in the **stack**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50268144-b4af-4a7c-9482-e48d518df3f0)

* String may start with **a** followed by many **a's**.
* String may start with **b** followed by many **b's**.
* As **order** is not importanat, so we have kept them in the **same state** only.
* We want to count the **no. of a's** is **equal** to the **no. of b's**. 
* **a** is coming and the top of the stack is **b**, so for **every-a**, cancel **1-b**.
* **a** is coming then cancel the **b** from the top of the stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9831751f-7751-4e5d-88b5-cc9ef208a0d4)

* **b** is coming and the top of the stack is **a**, so for **every-b**, cancel **1-a**.
* **b** is coming then cancel the **a** from the top of the stack.
* Opposite **symbol pop**.
* Same symbol **push**.
* String can start with **any symbol**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/633eb7fc-0759-42d2-9294-f2013d35cff7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21b4136b-8294-4dd1-b1eb-6d8a635ec2c9)

* No. of a's and no. of b's **cancel**.
* String is over, **Epsilon** came and the top of the stack is **Z0**.
* Top of the stack is **Z0** means **no one extra**. Both are cancelled.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d971347f-d5ca-4ed3-9d2e-51d5a1f182c4)

* [**IMPORTANT**]
* We kept/managed everything in **S1** state as there is **no order**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/24124c05-4315-4fae-8900-4b85c3b789c8)

* We are not concentrating if stack is empty or not.
* PDA acceptance by **final state** we have done.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26e9d068-5565-4b1c-af8b-ded4de0ecac0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74a5c904-bdae-4d0c-9596-2cc33b5f2183)

* By cancelling **opposite things**, **top of the stack** is **Z0**, which means **no. of a's** is **equal** to the **no. of b's** guranteed.
* Next symbol is **Epsilon** and **top of the stack** is **Z0** then remove **Z0** also.
* String is completed means no more comparisions needed, **top of the stack** is **Z0** means everything has **cancelled** each other and we have removed **Z0**, so we are in **s1** state.
* In the stack, we are able to **eliminate 'Z0'** as well.
* So string is **accepted**.
* PDA acceptance by **empty stack** we have done.
* **Epsilon** is considered as **ending marker**. [**IMPORTANT**]
* **No. of states** are not **asked** in **questions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/520aa5ea-cb2b-4b7c-a09f-05910d419a3c)

* In case of **PDA**, **3-things** matter:-

1) What is the **Input symbol coming**.
2) What is the **Top of the stack**.
3) Which **state** we are in.

* In case of **FA**, **2-things** matter:-

1) What is the **Input symbol coming**.
2) Which **state** we are in.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9fd599c0-7302-408d-99a1-5c0215680a9a)

* Only **10 a's**, it will be stuck at **S1** state only.
* All **a's** are over and then **Epsilon** is coming, top of the stack is **a**, there is **no transition**.
* The string is automatically **rejected**.
* Automatically they will go to **dead state**.
* In **PDA** covering every possibility is **difficult** as many combinations are there.
* One invalid also cannot be **accepted** and one valid also cannot be **neglected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c6664ace-167d-492e-b09c-b232bbfcb02e)

* Example.
* Opposite things are **cancelled**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b4cb68d-c39c-4a96-bf03-87f53e24f1ef)

* String is completed and the top of the stack is **a**, what is the meaning?

> **Extra or more a's** are there.

* Two different symbols we never see in the **stack**. They cancel. Either a's there or b's there. When either things are coming, we are **popping**. [**IMPORTANT**]
* **Epsilon** is coming and the top of the stack is **a**, the gurantee is that **a's** are more. Go to **S2** state which is **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef75087d-e239-4b85-adbf-20e6f90e42cd)

* String is over, which means **Epsilon** is coming and the top of the stack is **b**, keep **b** as it is. Guranteed **b's** are more. Go to **S2** state which is **final state**.
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2cf55d8b-b7fb-4227-b9d3-722c86393156)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cd967aa-6b0d-4d1b-9e08-328be4039edf)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db29284c-c8c8-4159-af96-177bccd9898f)

* **Dollar or Epsilon** is the **end marker** they are the **same** thing.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8532c2e1-9ba6-4d58-aa8a-06df0918ab41)

* We verified **more only**.
* We didn't verify how much more.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42ffae12-50a3-4fc2-be5d-3f1d17823844)

* Example
* **a's** are more by **1**.
* **a** is more. It is **more** by **1**.
* Who is more?

> **a**

* How much more?

> **By 1** or **+1** only.

* Order is not important.
* **Epsilon** coming means **string** is over.
* Both **a's and b's** are cancelled and **string** is over, in the stack, who should be there, as the valid string? **a's** are more, so **a** should be there at the **top of the stack**. 
* Pop that **a** as well and come to **S2** state.
* We got to know that **a** is more and we have popped that **a**.
* If at all **a** is **exactly 1-more** than **b** so, still **Epsion** is coming and at the **top of the stack** we have **Z0**. So keep **Z0** and go to **S3** which is the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23b3da73-53cf-4f37-acf0-a4213b85262b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6de40fea-d90b-4ae0-a19a-162b5c7714d7)

* After popping **1-time** we got to know that **a's** are extra and after popping **1-time** we got to know that **stack** is **empty**.
* Without **popping** the symbol at the top of the stack, we cannot go to **next symbol** in the **stack**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/734cd815-4e36-4146-9bda-968f86d8c0e3)

* Example.
* L = {W * C * (W ^ R) | W belongs to ((a + b) ^ * )}
* **C** is there in **sigma**.
* **sigma** contain **a,b,c**.
* **W** will take **a's and b's** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7c4f931-2cb0-41fb-99c7-4bd870600083)

* It is **palindrome**.
* If we **add**, **W * (W ^ R)** then **even palindrome** comes.
* Here, in-between **W * (W ^ R)** we are keeping **one symbol(C)**, so **even + 1 -> Odd**, so we are getting **odd length palindrome** here.
* If **W** is **2-symbol** then **(W ^ R)** is also **2-symbol**.
* If **W** is **3-symbol** then **(W ^ R)** is also **3-symbol**.
* Even + Even -> Even
* Odd + Odd -> Even
* **L** will generate all **odd length palindrome**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4e054b7-e71c-4b91-8f05-dd5ef240a9e0)

* In the **input string** until which place **W**?

> Until **C**. **C** is the marker between **W** and **(W ^ R)**.

* Whatever symbol is there **before 'C'** that is the **last symbol** of **W**. 
* Whatever symbol is there **after 'C'** that is the **first symbol** of **(W ^ R)**.
* **C** came means **W** is over.
* **After 'C'**, **(W ^ R)** is starting.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e0976094-811d-4d5a-a976-f0844a62489e)

* Every **palindrome** can be **divided into two parts**, which are **W** and **(W ^ R)**.
* Every **palindrome** can be written in some form of **W** and **(W ^ R)**.
* In-between **1 more symbol** is there, that is going to be **odd length palindrome**.
* In-between **no symbol** is there, that is going to be **even length palindrome**.
* What is the gurantee that the **palindrome** is in the form of **W** and **(W ^ R)**?

> For that we have to **check** if the **last symbol of 'W'** and the **first symbol of 'W ^ R'** are **same/equal** or not. If they are **same** then they are **palindromes** and they are **reverse** to each other.

* Indirectly we are checking the **first and the last** symbol.
* Same thing only, but we are **starting** from the **middle**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37d896d6-dd74-4cf2-86f9-da835bf29f9d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e00e856-bf1e-4064-a78e-a62e76bb36d0)

* How we will know which is the last symbol of **W** and the first symbol of **(W ^ R)**?

> **C** is going to help in finding them.

* We have to compare **W** and **(W ^ R)** symbols.
* **W** coming **push**. **W** is there in the **stack**.
* **(W ^ R)** is coming then start **comparing**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d148e0a-8a13-40d0-a929-a2b0cc66aa05)

* Every **odd thing** can be written as **((2 * X) + 1)**.
* At the end of the **W**, at the **input string**, **W** is over, so it is kept at the **stack**.
* Only **top of the stack** we can access which means only the **last symbol** of **W** we can access from the **stack**.
* We want **last symbol** only of **W**.
* **Last symbol** of **W** should be compared with the **first symbol** of **(W ^ R)**.
* Within **W**, cannot do **pop**.
* **Pop** means **comparisions** are happening.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/417de152-31b5-46d3-9fcb-c06bdc7bf9d0)

* It is not **no. of a's** is **equal** to the **no. of b's**. That's why we are **not popping** when **opposite symbols** are there.
* As **W** is going on we will **push**.
* **W** is combination of **a's and b's** only.
* If **anything comes** then **push only**.
* String starts with **a** followed by **anything**.
* String starts with **b** followed by **anything**.
* Strings can be combination of **a, b** anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8b89319-d048-4d69-9ad0-788ba7073766)

* Any combination can come in **W** of **a and b**.
* Before **C** everything is **W**.
* When we see **C** or when **C** is coming, it means that **W** is over and **(W ^ R)** is going to start.
* Ending of the string(W) can be anything either **a** or **b**.
* Don't **push or pop**, just **skip**.
* By seeing **marker(C)** don't do **push or pop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42f51ba0-1ce2-4495-b375-eb6edad9e7f8)

* Total **W** is pushed into the **stack**.
* **S2** means that **W** is over and it is in the **stack** and **(W ^ R)** is **starting**.
* Next symbol we are going to **read** is part of **(W ^ R)**.
* **(W ^ R)** first symbol is **b** and the **top of the stack** is also **b**. The **last symbol** of **W** which is at the **top of the stack** must **match** with the **first symbol** of **(W ^ R)** otherwise the string is **not palindrome**.
* We have to **pop**.
* Again **pop**.
* Again **pop**.
* If at all **not matching** then it is **not palindrome**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3590a35d-c1c2-4751-aad5-9445c25badd4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1fe83837-b5ea-4428-8e5d-fdd2245d7ebc)

* **Palindrome** means if we see any side then both should be **equal**.
* Everything else going to **dead state**.
* String over means **(W ^ R)** is also over.
* * **Epsilon** means **(W ^ R)** is over/completed.
* **Z0** means **W** is also over/completed.
* When **(W ^ R)** is over, **W** is also over, it means that **both are equal** and that's why they have **cancelled** each other.
* It means that **W** and **(W ^ R)** have **cancelled** each other. 
* **Epsilon** is coming and top of stack is **Z0**, keep **Z0** as it is. So we will go to **S3** which is the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1da30e6-de63-4b97-adb4-0e1a8ef1b3a5)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c3c495d-5a1c-46e2-b14a-d91f03ec32d9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/79769990-31ac-4032-9446-83cba15a4f2e)

* In **S1** push everything as until now we haven't seen **C**.
* It is **W** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1288920-0119-42e4-b511-ec05ab3e4700)

* Afterwards **C** came so we are in **S2** state.
* In the **input buffer** we are in **after 'C'**.
* It means **(W ^ R)** is going to start.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b98add63-d7a3-4414-b507-d91443739599)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecbb2eb3-f24c-43db-b829-01bcc7aeae07)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a686508-f9a2-49f0-b784-85e84cc6b15b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b8570a17-fc25-4e9f-b1e3-b03724a3b9cf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ef13d26-4eb0-4aec-a042-1d304a72e97b)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff8d53d1-c497-455e-83c8-e4f535c749bc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be7c5cd6-9dab-4a04-8eee-f560664947a2)

* Overall becomes **C**.
* W -> Epsilon
* W ^ R -> Epsilon
* Epsilon * C *  Epsilon -> C.
* **C** is coming and top of the stack is **Z0** means that **W** is **empty/epsilon**. So, we came to **S2**.
* After **C**, **epsilon** is coming and top of the stack is **Z0**, keep **Z0** and go to **S3** state.
* This will take care about **Epsilon** also.
* This will take care about **Epsilon**, **w** ending with **a** and **w** ending with **b**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5961ce9b-e8d7-45d8-8d5f-452a2b519af8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee165a2b-e631-4c35-88e6-492ac8085eb8)

* **C** is always **skip** only.
* Starting state itself directly **C** came so the top of the stack is **Z0** only, so **W =  Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c9e9412-7c33-44ab-8c5b-fc70573c99a8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18fda4f7-74f3-49a6-b876-a0d7dab11bdc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a039799a-0624-47c3-89f7-1a7a0111b0c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/802d2cc3-c7e0-4030-a71a-bd2be814a7c9)

* [**IMPORTANT**]

## doubt-clearing-session(40) [22Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19fe230f-fa79-486a-8d3f-89b80b74b02a)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4229f8ce-a9d3-48a6-8179-7dede1b51d9c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83970ea8-a2be-4a69-9739-3323bb24474f)

* The marker is **C**. We cannot take whatever **marker** they want.
* In this problem **marker** required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0bbeb018-47c9-47c9-abc9-a06801b10738)

* In the place of **C**, we cannot take **a** also.
* In the place of **C**, we cannot take **b** also.
* In the place of **C**, we cannot take **Epsilon** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3627b6d8-18c8-4621-b230-8f73906dca34)

* Anything came come.
* Only a's will come, Only b's will come. a's maybe more. b's maybe more.
* Anything can happen.
* No condition, **W** can be anything.
* In the last question, **marker(C)** was there. **Marker** means who can clearly differentiate between **W and (W ^ R)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f388c40f-5ff1-4811-9f91-36f238451648)

* This problem is **Without marker**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06455901-3e34-4135-8a8a-2dcefeae0118)

* Everything thing **same** except marker is not there.
* w -> (a + b) ^ *
* Any combination of **a and b** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da93baa4-f3a0-482a-bc7a-cd479f5b2ddf)

* **w** is **pushing** in the **stack**.
* **Stack** contains **w**.
* Assume, w -> ab
* So, **ab** is pushed in the **stack**.
* (W ^ R) -> ba

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ef94a01-afd6-4899-b4b0-a10d58ab6d85)

* The **only problem** is **marker** is not there.
* Logic is **same**.
* When we are reading the string at any point of time, two consecutive symbols are **same** then we can say one symbol belongs to **W** and other symbol belongs to **(W ^ R)** because of lack of marker.
* As in **palindrome** the last symbol of **W** and the first symbol of **(W ^ R)** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a570ce9a-7729-466a-91a0-1235ba8bf769)

* **b** coming and the top of the stack is **b**. We should **pop** and go to **S2** state.
* The **b** which is coming belongs to **(W ^ R)** which is the **first symbol** of **(W ^ R)** and the **b** that is already there at the top of the stack is **W's last symbol**.
* The way to verify is if it is a **palindrome** then the last symbol of **W** and the first symbol of **(W ^ R)** should be the **same**. It means that if two consecutive symbols are same then one belongs to **(W ^ R)** and the other belongs to **W**.
* If both symbols are **same** then **pop** and go to **S2** state.
* In **S2** state means that **(W ^ R)** is started and **W** has ended.
* We have to go further as **(W ^ R)** is already started.
* In the stack already **W** there.
* So, if **a, a** then **pop** and if **b,b** then **pop** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fec8c42-f4aa-4901-869a-20eccef30dac)

* If **a** coming and the top of the stack is **a** then **pop** and go to **S2**.
* The only problem is that marker is not there.
* The solution is that if it is a **palindrome**, if two consecutive symbols are same then one belongs to the first symbol of **(W ^ R)** and the other belongs to the first symbol of **W**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e288af4-de93-4136-a853-3d77f8b9ccb7)

* If two symbols are same then start **popping**.
* String is over and **epsilon** is coming and the top of the stack is **Z0**. Keep **Z0** as it is and we will go to **S3** state which is **final** state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/85cc3a50-2f38-4203-a27f-eb338ebd5c00)

* Final state pda acceptance.
* If **W** itself having two consecutive same symbols, we have already written those combinations which are **a,a |aa** and **b, b | bb**.
* If two symbols are **same**, next symbol and the top of the stack symbols are **same** and if they belong to **W** only then **push**.
* If the two symbols and one belong to **W** and the other belong to **(W ^ R)** then **pop**.
* Same state, same input symbol and same on the top of the stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/04e4be49-206a-4508-b51d-c703ce10a8d5)

* **3 and 6** are **same**.
* To apply the **3rd and 6th** production, we are in **S1** state, the input symbol we are applying is **a** and **a** is at the top of the stack.
* Same state, same input symbol and same on the top of the stack also. One person is saying **push** and the other is saying **pop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/547b469d-be93-4af7-a7f0-3f50e7fa2920)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c02b03f2-e402-4e64-98db-557ab0b277bd)

* In the case of **PDA** this is called as **non-determinism**. [Above thing]
* It is like **NFA** in **FA**.
* In case of **FA** because it is a **small machine**, no possibilities should be missed.
* In case of **PDA** because it is a **larger machine**, some possibilities are missed.
* Machine is having **some problem**, it don't know for the state **S1**, we have the input as **a** and the top of the stack is also **a**, the machine don't know if it should do **push** or **pop** operation.
* The machine is **confused**.
* The machine is in **dilemma**, whether it should do **push** or **pop**.

> If both the symbols are from the **same machine** then do **push**. If one symbol is from **W** and the other symbol is from **(W ^ R)** then do **pop**. The confusion is how will we know? We don't know. We have written both. Machine will select correspondingly. That is a **non-deterministic** machine.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cb2b95a5-06ea-4f79-8c82-69c0ee471556)

* [**IMPORTANT**]
* This can be solved with **right guess**.
* If we give valid **W * (W ^ R)** then it will go to **final state**?

> We need to accept all valid things. There is a **chance**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/793f0656-82c6-4cd8-9320-b43e270101b7)

* **Non-determinism** means **guessing** is required.
* If we are **lucky** means that we have do **right** guess then it will work out.
* **Non-determinism** means nothing but with **right** guess we can solve further or not.
* We are unable to avoid the **guess**. We have to do **guess** that the meaning of **Non-determinism**.
* If we do **right** guess then it will work out. **YES**.
* Can we solve the **above** problem without guess?

> Guess is the only way that is also **right/correct** guess. Guess also **right** guess.

* Guess can be right or wrong also.
* **Non-determinism** is always like **right** guess.
* **W * (W ^ R)** is a deterministic PDA or non-deterministic PDA?

> Non-deterministic PDA

* Can we solve the **above** problem without guess?

> **DPDA** not possible. Only **NPDA** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/35b52a65-02af-4d18-82de-5f65169ed043)

* We cannot solve the **above** problem, without guess.
* We can solve the **above** problem, with the **right guess**.
* If we solve a problem without **any guess** then the problem is called as **determinism or DPDA**.
* If we solve the **above problem** atleast with **guess** then the problem is called as **NPDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b002add1-ae4f-42f9-b232-5c2becb9cf78)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f5228fe-8679-467f-9fa7-1bae70541c72)

* We have **3-states**.
* Guessing needed but **right guess**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/968694f0-c830-452e-82ed-e2ef0f1837dd)

* Yes.
* Take the **right guess**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c09b2892-68e8-4465-a350-52cb9d611719)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b6ae77f-2da0-4c91-9001-03f84d691ef2)

* Many possibilities, think about **right guess**.
* **NPDA** means we have choices. **YES**.
* Our string is accepted or not, how we will know?

> By taking right guess, we can go to **final state** or not.

* **DPDA** is not possible
* **NPDA** is possible.
* Expressive power of **NPDA**, E(NPDA) > Expressive power of **DPDA**, E(DPDA)
* Expressive power of **NPDA** is **more(>)**.
* **NPDA** accepting some languages which **DPDA** doesn't have any clue.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc6c2bae-ef87-495e-a721-da22c06ea87c)

* [**IMPORTANT**]

* Expressive power of **DFA**, E(DFA) = Expressive power of **NFA**, E(NFA).
* They are **equal**.
* For every NFA, DFA is possible.
* For every DFA, NFA is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b882f08c-7a1c-455b-abf4-11d7275fb2cb)

* Expressive power -> No. of languages accepting.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc25940f-0028-449c-9d4d-9489e64ffb20)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d871363-fe01-4d2b-b931-911be78d8567)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/388df0c0-9a9d-42c8-b722-28ef313c52df)

* **DPDA** can do means **NPDA** can also do.
* Whatever **DPDA** can do, **NPDA** can also do.
* Whatever **NPDA** can do, **DPDA** cannot do.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/14d92368-f8e4-44de-9a67-8a1723e0f0ab)

* Example
* **CFG** possible means **PDA** also possible.
* For every **CFG**, **PDA** is possible.
* For every **PDA**, **CFG** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e9696ea-6609-4ef5-b21a-198600cd5020)

* We want to compare **b's and c's**, why **push a's**.
* Best idea is to skip all **a's**.
* **b** coming then **push**.
* **c** coming then **pop**.
* There is **no dilemma**, it is **DPDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ed57241-0f58-4f26-b81a-48cedff5e42b)

* If we say **PDA** then who will come?

> **PDA** maybe **NPDA**, **PDA** maybe **DPDA**.

* Two possibilities are there **NPDA and DPDA**.

* If **PDA** then all will come.
* Normally if they say **PDA** then we can take **NPDA** as it is **more powerful** than **DPDA**.
* **PDA** means **NPDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9a2482a-ab4d-48d5-9229-32dce91767ca)

* The language accepted by **NPDA** or **DPDA** is **CFL**. Both are **CFL**.
* For **DPDA**, it is **DCFL** which is **Deterministic-CFL**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b2adb1ba-171d-448b-ad4c-5c69fdf134cf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a16309b9-8707-47d2-8287-790d3c051132)

* **NPDA** possible means **DPDA** is also possible, we cannot give gurantee.
* **DPDA** possible means **NPDA** is also possible, we cannot give gurantee.
* Bacha possible then papa guranteed possible.
* Papa -> NPDA.
* Bacha -> DPDA.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1440ec34-cbbe-4d00-90c2-86ccba57b7da)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23045b70-de4b-4de8-814b-324a1d4e5bd3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/677e8b4c-2b8e-4e01-aa87-7c2c6e88cc09)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d4befce-648d-45e5-b178-83c677a1b805)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f25ec75-3f9a-4ed1-a2fa-eae136ece527)

* This is **CFL** and not **DCFL**.
* As it is not **DCFL**, it is **not regular** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f3022bd7-99da-4d53-b1fc-1073d2ae012f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f8b46c8-5994-4142-a29b-30bb056df8fc)

* This is **DCFL** and it means that **CFL** also.
* If **subset** satisfied then **superset** guranteed satisfied.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8a872f0-fbb3-41fe-8a87-c7ea6720a91d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97f13561-f2a3-4cb9-931f-61623f6e22cf)

* It is **regular**, it means **DCFL** also. **DCFL** means **CFL** also.
* We can do it without **stack**.
* So, we can do it with **stack** also which is we don't use the **stack**.
* **CFL** is providing **guess**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2812c862-585a-4f02-a2e1-dec9b2e2cbc7)

* DPDA means **guess** not possible. We cannot take **guess**.
* In **NPDA**, we can take **guess**. If we don't want to take **guess**, it is ok.
* That's the reason, every **DPDA** is **NPDA** but **every NPDA** need not be **DPDA**.
* In **PDA**, we have **stack**, we don't have to use **stack** everytime. If needed then only use **stack**.
* In **NPDA**, guess is there, if really needed then use the guess. If not needed then don't use.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/180190d6-9c78-4a57-a83c-53439105f450)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55d3373c-97e9-4da6-ba0a-897e9ab9e2a1)

* Minimal string -> abc.
* We have to compare **b's and c's**.
* **a** coming **skip**.
* **b** coming **push**.
* **c** coming **pop**.
* Nowhere **dilemma**, so it is **DCFL**.
* We are going by **final state**. So what is in stack, who bother. It is unnecessary.
* We are unnecessarily pushing **a's**.
* So instead **skip a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad715a07-377e-49a2-a2d1-8b3fb101056c)

* **a's** and **b's** cannot come alternatively because if after **b's**, at all **a** comes then the top of the stack is **b** and not **Z0**. So **no problem**.
* According to the language, **minimal string** is **abc**. If **no 'a'** also then we will go to **final state**. Minimum **1-a** required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56fa40de-4ed8-4d72-8523-89d9df3a05c6)

* To change the state, we have to remember **single 'a'**.
* One Invalid thing we cannot accept.
* To the problem, **deterministic** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a947933-4ad7-4c71-8461-d680b6b31ae4)

* we came to **S2** means **one 'a'** is guranteed.
* According to language we have to remember **abc**. Minimum is **abc**. **1-a** required. We want to see **atleast 1-a**.
* First **a** skip and remaining **a's** also **skip**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a7982f7-e8bc-4165-801c-365fc12d1a30)

* **S2** will give gurantee **minimum** of **one 'a'**.
* **S2** will not give gurantee of **minimum one 'b'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8b205dba-7b67-46fa-80b6-953e7768bcf9)

* Whenever **C** is coming and the top of the stack is **b**, it means that **minimum/atleast 1-b** is there.
* We can remember something by **state** and we can remember something by **stack**, depending on **requirement**.
* Epsilon is coming, means string is over.
* Top of the stack is **Z0** means that **b and c** cancelled each other or are cancelled. Keep **Z0** as it is and go to **S4** state which is the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be46c412-1736-43fb-8c8d-86f3445f9af8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe4397c3-d3fa-4acb-ad90-109584069ebb)

* If we give only **a's** then we are stuck at **S2** state.
* Every valid thing should go to **final state**.
* Every **invalid** thing should be stuck somewhere.
* If we give only **b's** then we are stuck at **S1** state.
* If we give to **abc** then we will go to **S4** state which is **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d7abd20-89c6-488b-9a7c-7cd8bb8d3aee)

* Skip **a's**, we are in **S2** state.
* **b** are coming so **push**. We are in **S2** state.
* **b** are coming and the top of the stack is **b**. So, **pop**. For every **c**, pop **b**.
* **3-b's and 3-c's** are cancelled.
* **2-c's** are still left.
* Still **c's** are coming.
* Top of the stack is **Z0**.
* **c** coming and the top of the stack is **Z0**, this combination is not there. We will get **stuck**.
* It will be stuck at **S3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a804171-3b7f-49c7-b6a5-c360cec1e87c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df47048f-61d7-4c6b-9ebb-da5e6ae68a39)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d2040f8-aed7-43cf-b2cd-61720b560863)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4c696d8c-f7d9-48a3-aad7-3c52f394d29d)

* (a ^ * ) -> Regular, DCFL, CFL

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aafb41d1-433f-4cff-930b-a8be945b0afe)

* [**IMPORTANT**]
* Placed games in **options** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/896da70b-6b4b-499d-abde-d5f807e9fe3c)

* Example
* **a and b** are **equal**.
* Minimum one **c** is required.
* Don't go wherever we want to **final**.
* End of the string we have to decide.
* End of the string means **Epsilon** is coming.
* **a's** coming push.
* **b's** coming pop.
* **c's** coming skip.
* It is a **DCFL**. No dilemma.
* Minimum **1-a** gurantee required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0f3a69da-41a1-4ad7-a869-b6daf4fb7777)

* All **a's** are **pushed**.
* What is the gurantee that **min/alteast 1-a** came?

> **b** coming and the top of the stack is **a**, which means **minimum/atleast 1-a** came.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de64dbe7-15cb-4545-932c-549ea7c6ac1c)

* **Minimum/atleast 1-a** came.
* Otherwise how the top of the stack is **a**.
* We change the state also with the help of **stack**.
* When we came to **S2** means that **min. 1-a and 1-b** came.
* When we came to **S2** means that **min. 1-a, 1-b and 1-c** came.
* Skip all the **c's** and **a's and b's** are **equal**.
* Whenever **c's** came stack is empty.  So, **a's and b's** are cancelled or cancelled each other.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5c87eee-cb1b-4698-8714-be87d7e721ae)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a41891d1-fd3a-429e-82f9-76f8c5f8197c)

* After skipping all the **c's** we are in **S3**.
* We can make **S3** as the **final state** with **Epsilon, Z0 | Z0**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6592349a-d207-4dfa-b2a1-286c09873c37)

* At the end of the string, we are in **S3** which is the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfd7ac5d-f622-4971-af39-e23bb1249da7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5828d05d-c146-4c0d-b529-ce1eba0d475a)

* [**IMPORTANT**]
* At the end where are we.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bd011546-473d-42b4-b56a-2eba0134ff6a)

* In the middle maybe we are in **non-final**. In the middle maybe we are in **final**. It doesn't matter. At the end where are we.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/48a07eb3-e05c-4d92-9157-742a0c97adef)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/54383c79-aea1-445a-a62e-0850a63bf88d)

* That's the reason why we are skipping.
* Skipping reason is because they are **useless**.
* At the end of the **production** we are in **S3** which is the **final state** or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/035ec38a-d4e4-448c-b5a2-a5a1712128b5)

* One way

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ef5a0c5-3b2e-4628-ac59-c60bbec6ecf8)

* Another way
* Both are **correct**.
* Accepted or now, how we will know?

> At the end of the string, are we in **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a20488e-7122-4ac2-a3c7-854562edb95e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9314ec6e-6c0e-4040-8816-3b56a54a650b)

* Stuck means it will go to **dead state**.
* Some possibilities are not there means they are **stuck** there. Indication that by default they will go to **dead/trap state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e24fb01e-e3ea-44eb-83a0-1a346864f5a5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/35d33acd-a0b4-4fa2-85e4-f879013fd8b2)

* [**IMPORTANT**]
















![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/427d512c-1e27-4af4-8f2e-1c7bfcdbec0c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7be804c-ae46-4383-8dbb-f6da68cee4fc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b27e138a-2639-44d0-beb2-ecfa301d9788)

* Minimal string -> Epsilon.
* Epsilon should be accepted.






































































## Misplaced Images

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db87f3f9-4670-43db-9fe5-644c00632aed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bef6f5d8-9532-4788-a4fe-07b0c733ca7b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d43f8ed-d24f-413a-9b1a-dddcb37f6f9b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97f0067c-0503-45b8-b37e-ba734b7274e6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d3305e7-c0f2-4edd-891f-6d0daec3f01b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8710bd0a-4e34-4905-8be5-0215477fb53d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5c73504-3fd9-4ec7-8462-2c46fd0052c8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/faf6e69f-a9a3-42cd-9f39-7303dfc1b8fe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/444bff3c-64b8-454d-b2de-a3947f43b964)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d89f987-edae-410d-9706-92463a2378c3)
