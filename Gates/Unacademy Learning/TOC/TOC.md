# TOC

## Motivation

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dfb4fce-5b66-4a58-8260-3591eb6708bc)

## Syllabus

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/67e960e4-abc6-4c11-bb0f-615be22d1258)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbc0f3a7-9e89-4a70-a93f-4f3a4806dd78)

* Link -> https://unacademy.com/course/complete-course-on-theory-of-computation/ON3TCUN5?_branch_referrer=H4sIAAAAAAAAA8soKSkottLXL81LTE5MSc2t1EssKNDLyczL1jepdM%2F1SQ0t83FOAgAdZnNEJgAAAA%3D%3D

## Practice Class

1) -> https://unacademy.com/class/toc-practice-class-1/XCUW1FGE
2) -> https://unacademy.com/class/toc-practice-class-2/G37UT7VH

## introduction-to-theory-of-computation (1) [3rd Sept 2023]

* TOC is nothing but mathematical representation/study of computing machine and it's capabilities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/746564f6-4f2a-4faf-8788-fd12ef5418e7)

* First mathematical model is ready and then the model is sent to algorithms(Close to programming language).
* Model -> Algorithm -> Coding
* Language -> Collection of string.
* String -> It is nothing but collection of characters.
* aabb -> It is a string. There is no meaning of it in the english language.
* Formal language -> It is also collection of strings only but meaning of the string is not important but format of the string is important.
* aabb -> Two a's followed by two b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d264ad18-54fd-4584-8b97-753a1dfecfd8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95df5916-4e93-4a3f-bba1-633a45df3eb3)

* In this subject, meaning is not important but the **format is important**.
* a ^ 2 -> Two a's
* b ^ 2 -> Two b's
* a ^ 10 * b ^ 10 -> 10 a's followed by 10 b's

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70630489-07c3-428e-9063-319ed54022b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3038f041-4f0f-4a30-bc87-26b34939f30b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ad4880b-7b17-415e-9399-cbf4fe3413a0)

* Meaning is not there but format is there.
* In machine language, format is important.
* In human language, meaning is important.
* **W** is one string.
* '*' -> Combination.
* **W** is one of the strings which is a **combination(*)** of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ed863f7-7467-4a28-81a7-aecc983743a9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d729926b-bc67-43ed-8c97-e2989121a3b6)

* **W** is combination of a's and b's.
* Reverse of **W** is **W ^ R**.
* **L** -> Palindrome.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/194dd818-3441-452a-941a-fa0228474b81)

* Order is **important**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a04a3851-a540-4997-bf0f-b79583963354)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/94f1873d-1e31-4a0a-8631-48f4a83470e3)

* Formal Language -> Set of palindromes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0dd66a2d-9b8b-454e-a8f7-29e916a711d3)

* One of the formal languages where there are infinite no. of strings.
* 'n' number of a's followed by n-number of b's.
* **W** -> We can take any combinations of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78ec184-fc4b-4038-b49b-da28a258be32)

* a's should come first and then b's should come
* Infinite language as no boundaries.
* How many a's and how many b's, no relation
* 'm'-no. of a's followed by 'n'-no. of b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9bfc043b-6c9e-404c-a2fd-61c398263adb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f16d7f6-18db-4914-baa9-46fdf565277e)

* Like these many formal languages

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13edd8d6-8fb3-4671-a66d-1872c15e5ce9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab7487ee-b304-4498-a7e7-feeca0b7e4d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d710f226-4e31-41d4-87f7-c8b1c088347f)

* L = {WW} -> String Copy.
* Exact matching.
* Whatever we see **first** that same thing should be there in the **second** as well.
* No. of actual parameters = No. of formal parameters.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8429b54a-3cc8-4cf7-b7d6-571f414afca4)

* Examples.
* There are **four types** of formal languages:- [According to Chomsky]

1) Type3(T3) formal language
2) Type2(T2) formal language
3) Type1(T1) formal language
4) Type0(T0) formal language

* **Type0** is the superset among all of them.
* **Type3** is the subset among all of them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ddddb1b-8268-411b-a4fb-125fec4e992e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cac07f41-807e-4138-97f4-7ddf905c0b56)

* R3 -> Smaller -> Regular Language
* T0 -> Bigger.
* Our computer program maximum can be **Type0(T0)**. No chance of more than that. It is the limitation of the computer.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e290a64c-c906-46bf-9a17-5823dd96b7b4)

* To accept smaller language(T3), smaller machine is enough.
* The smaller machine is called as **Finite Automata(Machine)**.
* Automata means **machine**.
* Finite Automata means finite machine
* Finite Automata also called as **Finite State Machine(FSM)**
* Which one is the smaller formal language?

> **T3**.
* Other name of **T3** is **regular language**.
* **Regular language** is accepted by a machine called as the **Finite Automata(Machine)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaa5d6ab-6780-47d2-949b-56dfdaaf04eb)

* Other name of **T2** is **context free language(CFL)**.
* The machines that accept **context free language(CFL)** are called as **Push Down Automata(PDA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b863c99-6c93-4138-889b-278605bbd17d)

* Other name of **T1** is **context sensitive language(CFL)**.
* The machines that accept **context sensitive language(CFL)** are called as **Linear bounded Automata(LBA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f72166d-552e-446f-ab98-4e6803a9d5ac)

* All computer programs are **T0**.
* Other name of **T0** is **Recursive Enumerable languages(REL)**.
* The machines that accept **Recursive Enumerable languages(REL)** are called as **Turing Machine(TM)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74f6bda0-a63c-4e57-80fc-bf6efbb8eca4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0fbb9888-93fe-41b1-a868-856e35bd07fd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aca784a8-83ee-4308-8361-7936a9b363b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74569991-dd48-4dfb-a964-ca0ffc0722c0)

* Turing Machine is equal to computer.
* Regular language accepted by a machine called as **Finite Automata**.
* Formal languages and Automata theory(FLAT).
* Computing machine and it's capabalities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eedbb788-cc01-4c55-be70-0723778c85bc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e06c5c53-99f5-49d3-9854-ceb2fd3bd142)

* In general,
* T3 is the **subset(C)** of **T2**.
* T_i+1 is the **subset(C)** of **T_i**.
* Type3 means Type0 also.
* By default, every/all formal languages are **Type0**.
* Every machine is a subset of **Turing machine**.
* **Circle** indicates **state**.
* Two states are **S1 and S2**.
* State -> State is nothing but the thing which can remember something. [Remembering Capability]
* State is nothing  but **Remembering Capability**
* State is changing and remembering capability is also changing.
* Nothing knows/known -> Starting State.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c116a8e0-169a-4599-854d-46dc717c4388)

* Remembering capability is **increasing** so our state is **increasing**.
* Empty State -> S1 [Initial days]
* 'a' -> Mama's name
* **S2** means **a** completed
* **S1** means nothing completed.
* Same State
* If something new happened, then we may go to **other state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a9b1f25-f11a-4e7a-a802-dad45eca1ad5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9c6eb1e-f007-4530-908a-d902603117a8)

* Double Circuit(Double circle) means **final state**.
* After accepting **a**, the automata is in **final state**.
* After completing **aa**, the automata is in **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e620dab2-4763-4708-9bf8-317f3b53d776)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0251b251-09b4-447e-bebe-b8332c900f27)

* The **automata** will accept the **above language**.
* In the automata, there are **two(2) states**.
* That's why it is called as **Finite state machine(FSM)**, it it called as **finite automata**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83aa4eae-7daa-4346-8e74-e66ff8dfc28f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee57ac3c-a5e8-4697-aa4b-38bdddf13887)

* The finite automata is accepting **L1** formal language.
* Finite automata is accepting some formal language means the formal language is a **regular language**.
* Finite automata will accept **regular language** only.
* This formal language(L1) is a regular language.
* For the formal language(L1), finite automata(FA) is available so the formal language(L1) is a regular language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a868e695-5c0c-4e69-9f63-9e95b02c6abf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30b15c92-1ff7-4a5f-a0ae-9daf46c931b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e5e8914-a32c-42d2-899e-f45773136625)

## difference-between-nfa-dfa(2) [4th Sept 2023]

* Why these many Automata's?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fcb26a7-2fe7-4711-9027-9597e109140a)

* Between a's and b's there is a **relation**.
* How many a's will come, those many b's should come.
* What is the minimal string?

> 'ab'.

* If the minimal string is 'ab', then the length of the minimal string is **2**.
* Minimal string is 'ab' of length **2** then **start automata** is of **three states**.
* States -> Minimal string length  + 1 -> 2 + 1 -> 3
* With **three states** start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87e54840-82ee-4c97-a229-ddfd6bb6d5af)

* **Every circle** indicate **state**.
* **Double circle** indicate **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39fc7de4-d639-44e4-b23e-0bb06f9bbb38)

* Starting state is **S1**.
* Final state is **S3**.
* Initial or initially arrow to whom, that's the **starting state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/670988fb-7cdf-442e-96e1-a5435105df25)

* After reading **ab** from starting state we can go to **final state*** then **ab** is accepted.
* Minimal string **ab** is accepted.
* With the **three states**, start the story.
* When can we say that a machine is a correct one?

> One valid think cannot be rejected. One invalid think cannot be accepted.

* All valids are accepted.
* One invalid cannot be accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbbfc3b9-7604-4f74-8cec-e19ff01a6a2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1671c305-6f61-4e82-a182-d82e207ccbb2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96f44ef5-f907-44f2-964b-cb24dbc59d0e)

* The automata we have constructed is **wrong**. As it is accepting **invalids** as well.
* To this language, finite automata not possible.
* a's and b's are always equal in the language.
* **Loops** means it may come and it may not come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/001e5520-1f4c-471f-bf13-9344323f3191)

* This is called as finite automata or finite state machine.
* Finite state machine has failed to accept the **above language**.
* As **Finite state machine has failed**, we are going to the **next automata**.
* The **next automata** is **PDA(Push Down Automata)**.
* **Push and Pop** operations come in **stack** data structure.
* FA(finite automata) fails to accept above language, so we are going to **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d2e0bf7-3087-4a0e-adee-c6aa3dbd3a71)

* In the above diagram, we are not keeping any relation between **a's and b's**, a's are coming any no. of times, b's are also coming any no. of times. This is a **problem**.
* a's loop can be repeated **infinite** no. of times. So, b's loop also repeat **infinite** no. of times.
* If a's loop is repeating 10 times then b's loop should also repeat 10 times.
* But unfortunately there is **no relation**.
* **a** repeating whatever way it want, **b** also repeating whatever way it want.
* **a** repeating 10 time and **b** repeating **1 lakh** time.
* We didn't keep any **condition**.
* **PDA** is nothing but **finite automata(FA)** only including **one(1) stack**.
* In **PDA**, **stack** also there.
* Just add one more stack to **finite automata(FA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e07ad5c-b803-4d8f-a6cf-f91093c0b433)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c019b9a2-3470-460a-90c8-86933ed72fb1)

* **#(Hash)** indicates(marker) -> **Stack empty** -> Nothing there in the stack.
* Top of the stack, **#** means that the stack is **empty** now.
* How do we know string is over?

> There is a **marker**, which is the **dollar($)**.

* **Dollar($)** indicates -> **String is over**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ad6328d-a1c3-4eca-86d7-d73be4fd549c)

* Every **a** is pushed into the stack. As **three a's**, so **three push** operations.
* When **b** is coming, then start **pop operation**.
* It is because we have to count the **no. of a's and no. of b's**. [**IMPORTANT**]
* We have to count that **no. of a's** =(equals) **no. of b's**.
* For every **b**, pop **'a'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10e352ad-8dcf-4f03-a262-f3f7937e0d04)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32a543f7-7e73-413c-91d9-bf2593b16e70)

* Next symbol coming in the input is **$**, which means **string is over**.
* **$** means **String is over** and **String is over**  means **b's** are over.
* Now, at the top of the stack, we have **#** which means **stack is empty**.
* **Stack is empty** means **a's** are over.
* When we got to know that **b's are over** and **a's also over**, it indicates that **no. of a's** are **equal(=)** to the **no. of b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/520afa32-74fd-4ed3-9c45-fb24664bacd0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/798db7be-749c-402e-9bc2-703334a8e62f)

* Yes.
* No. of a's == No. of b's.
* Now, **String is accepted**.
* **$** -> String is over -> b's are over.   [**IMPORTANT**]
* **#** -> Stack empty -> a's are over.      [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd9cb26e-69a1-45d7-95e1-740b395a6bff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1cc2ecb-57af-4940-ad39-e945cd71794b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4d47c15-2c54-452b-be1b-cc81a69fbbbf)

* aaab$
* Top of the stack should be **Hash** but unfortunately still **a** are there.
* So a's are **more**.
* It is **invalid**.
* In **PDA**, when is the string accepted?

> At the end of the story, **stack** should be **empty**.

* If **stack empty** then only **string is accepted**.
* String is over($) but still stack is not empty.
* So **string rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/430aeeab-34aa-47fb-8690-34b92d5007ba)

* **Stack** is taking care about **how many a's came** and afterwards b's will come.
* In **finite automata**, we do not have any track of **how many a's came**. We don't have **stack**.
* If we want to compare a's and b's then until b's comes, we should store a's somewhere(stack).
* We have to keep track of a's, **how many a's came**. We have to store somewhere.
* **Finite automata** don't have **stack**.
* Comparison minimally requires **two people**.
* So, until **b's come**, we cannot do **comparison**.
* Until **b's come**, **a's** have to wait.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb809f5a-e046-4c07-9af7-356d7e99f189)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/100cbb97-7c52-4b42-b3a7-7e10d6307b46)

* a's more
* At the end stack should be empty then only **accepted**, otherwise **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5817a5b-a5db-4811-8eba-ae214923fb5c)

* In the **stack**.
* Stack not empty, that's why **rejected**.
* My language, a's = b's.
* Finite automata fails to recognize those languages where comparison is **involved**.
* When comparison is involved, finite automata fails we need **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d209403-2293-4232-9223-4f1d91e109e0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e0a9bd3-7033-447a-8f2e-0bd06584e74a)

* Every valid thing should be **accepted**.
* No invalid thing should be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d6952b7-fd0b-4de0-b51b-5a90a7b3946b)

* In these language, we have to compare, a's = b's = c's.
* Two comparisons are involved over here.
* When **a** is coming, push in both the stacks(S1 and S2).
* When **b** is coming, pop only in **S1** stack. For every **b**, pop 'a'.
* When **c** is coming, pop only in **S2** stack. For every **c**, pop 'a'.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d8ed4e8-9fc0-422e-9015-b556749ff33f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a46014a2-1ec2-42ab-b211-c05b16a99f91)

* When we saw the first **c**, **b's** is over which means that **a's** also over.
* It indicates that **a's = b's**.
* Whenever b's over, then a's also over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51779c8c-63bb-43e8-a973-0aab990d57e1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f188c39-40b8-48a8-8dc4-68142e7dd42f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a35e6b65-ab6c-4cfa-b02f-998c3950ac8f)

* **$** means **c's** is over.
* **c's** is over means that **a's** also over.
* It indicates that **a's = c's**.
* We also proved that **a's = b's**.
* So, indirectly we have proved that **b's = c's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/687f43e4-5e8c-4ec4-bda7-9683cf42186a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22aa49bc-c917-4981-a0f3-9cc2e75a03b3)

* When two comparisons are there, this is the story. 
* Now, using **one stack**.
* Because of two comparisons, we have done **two stacks**.
* With **one stack**, can we do this?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aeb89b79-7352-4ef7-a02f-79970392d6db)

* Suggestion
* **one a** for 'b' and **one a** for 'c'.
* For every b, pop 'a'.
* For every c, pop 'a'.
* Finally stack is empty.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad0584d5-d179-4f4a-a362-f3d7175f9cb2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c32c956d-98af-4ae4-9d77-c354d44a1760)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3dc6664-c88e-4a38-a22f-9b0d7554400a)

* No invalid ones should be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c7ba6be5-5cf8-43a3-80dd-57fa28ace195)

* Another suggestion.
* Nonsense going on.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2301e938-3b6c-4145-bd84-7643fe8066cf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66e21007-a55e-4278-b6a1-8b23315dadb0)

* More than **one comparison**, **PDA** fails.
* One stack, we cannot do.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da0f6785-ae38-4a62-a4c4-6e499a3d1d31)

* When comparison required -> Finite automata fails -> PDA says, it can.
* Only one comparison -> PDA.
* More than one comparison -> PDA fails -> With one stack we cannot do.
* Here, two comparisons needed, so **PDA** fails because it(PDA) can handle max. of 1-comparison.
* For these reason, we are going to **Turing machine(TM)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e564cb54-c1a8-4aa3-a122-1db11ae3b9d8)

* **Turing machine(TM)** -> For the existing PDA, add one more stack, so total of **two stacks** now.
* PDA already contains one stack.
* **Turing machine(TM)** -> Finite automata(FA) + 2-stacks.
* PDA -> Finite automata(FA) + 1-stack

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3796003c-ab94-48c2-9ec0-8615f6464f14)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d322e07-5d8b-4c6a-99cd-7f3e5cbc8235)

* **LBA** is theoritically present. Practically not there.
* LBA only for name sake.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc59591f-d492-4882-b7c8-53442a216756)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7124302c-013a-49cb-9812-05e8566ba61d)

* Exam -> 4 Automatas
* Outside of Exam -> 3 Automatas(FA, PDA, TM) [Since **LBA** is only theoritical]
* More than one comparison -> Turing Machine.
* Turing Machine means **two stacks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b37b661-a47c-447e-9306-1b9d461903e3)

* When 'b' coming, pop 'a' and push 'b' into the other(seecond) stack.
* For every 'b', pop 'a'.
* When **b's** are over, stack is empty, so **a's = b's**.
* For every 'b', pop from first stack and push in the second stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ade51065-ccf1-4809-9d2b-7d7fc4650600)

* For every 'c', pop 'b' and push 'c'.
* When **c's** is over, stack is empty, so **b's = c's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b33836a-6a03-4800-bda2-20ff07459900)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7da2ebc-18bf-48dd-8956-be2d9f99eef3)

* Again one stack is empty.
* For every 'd', pop 'c' and push 'd'.
* When **d's** is over, stack is empty, so **c's = d's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/346b2ab6-41ce-4853-8366-fe4ac2a41b99)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ccdd282-6465-4798-8cfd-3835f2744aa2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fea6d77f-d20d-43f8-8440-7b623420f6b0)

* Using **Turing machine**, we can do anything.
* With **two stack**, we can do anything.
* Computer is nothing but **finite automata with/plus 2-stacks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0e87046-62ed-493c-8990-da126ccd7c89)

* At the end of the string, stack is empty then **string is accepted**.
* First all a's should come, then all b's should come and so on.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0fa9647-a062-4ec5-92cc-75b6627cba5b)

* Inside the computer many programs.
* For every logic, there is **turing machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ece7a79-f14c-4758-b654-6276d0bedd8e)

* FA + 1-stack -> PDA
* PDA + 1-stack -> Turing machine
* Power of **turing machine**, **equals to** the power of the **computer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/78e219bf-6e27-4c03-9cd5-3de93f2fed55)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/537598ee-4d21-4bc2-8c8d-451b54b18ee2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c838ade4-7c98-437f-9e39-7c01652ad863)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d67a728-62ff-4ae7-97d2-ad0de3181d5b)

* Alphabet -> It is **finite** non-empty set of symbols.
* Any language where the **alpha bit size** is **infinite**, no way.
* Language -> Atleast one letter/symbol required.
* **Alpha bit** is changing from machine to machine.
* Machine changes -> Language changes -> Automatically Alpha bit changes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38d01a94-a4ad-4636-93a6-29032696c6f9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42ca96a1-a19d-4af3-9fe5-a461b475f5de)

## dfa-construction-i(3) [4th Sept 2023]

* Alphabet(sigma) -> Finite non-empty set of symbols.
* String -> Collection of symbols over the given alphabet.
* abbc -> It is not a string because 'c' is not there in the **alphabet**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b220616d-7f78-468d-9f08-b2473effa4b6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9034b3e3-2128-4673-8acc-1f7d66cf6043)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e9279c21-2025-44da-9f55-fcf05a52da1f)

* One length strings, two length strings, three length strings possible.
* Epsilon(E) -> It is a string, whose length is zero(0). It is a zero(0) length string.
* That's why it is called as **empty string/Null string**.
* When we write **one symbol**, atleast **one length required**.
* Total TOC going on with **Epsilon(E)** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f41742b-3bba-4b31-9a24-752bb463dba5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7c588ed5-ad13-43d0-8071-4d60e19816d2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/649a9482-23f4-44e1-a20e-a4c623d08c36)

* Sigma = {a,b,c}, what is the minimal string possible over this alphabet?

> **Epsilon(E)**

* It is the **special person**.
* Epsilon(E) Length -> Zero(0).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71976527-d320-44dc-80fd-ed7ed8a23e3b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81209bf4-f776-4666-90e2-18533d6ff4e4)

* When we **concatinate** anyone with **Epsilon(E)**, we get the length of the **anyone string**.
* At the end of the day, we are concatinating **two string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b53152f9-c24c-4cf9-af13-2dc9c7b2a12e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75cf7ef1-e6e9-4117-9729-c81cfdc4a026)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cf671a2-cf64-4735-b220-a0a219178bc7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25af01b1-d4b6-4ca5-82ed-9e237e2ef8c5)

* String length -> Modulo operator.

### Power of a alphabet

* Sigma -> {a,b}
* Sigma ^ 1 -> Over the alphabets(a,b), what are the **1-length strings** possible.
* Sigma ^ 2 -> Over the alphabets(a,b), what are the **2-length strings** possible -> **Inside the sigma, we have to go **twice or two** times**.
* When we go inside **sigma**, take anything.
* Sigma ^ 3 -> Over the alphabets(a,b), what are the **3-length strings** possible -> **Inside the sigma, we have to go **thrice or three** time**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01d1eb92-a16b-49d4-9e10-3f86b1318927)

* Sigma ^ 100 -> **Inside the sigma, we have to go 100 times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4fd496a-49b9-45d7-8253-f739941980e4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a4b259a-dda7-4c81-8c1c-9f1b534f3931)

* Sigma ^ 0 -> **Inside the sigma, we have to go '0' times or don't go inside**. We don't get anything. We will get **Epsilon** only.
* Sigma ^ 5 -> **Inside the sigma, we have to go '5' times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1d7e6e4-dabe-4e7f-a727-941713b02d87)

* Sigma ^ * (sigma to the power of star) -> It will give every possible string over the given alphabet.
* It is also called as **complete language**.
* In set theory it is called as **universal set**.
* Set of all strings over the given alphabet including **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3be222d4-0df5-4c26-8b6d-768a56539439)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0876eab9-3744-4ceb-a03a-4c499ffde246)

* N -> Set of natural numbers.
* It is **Countably Infinite(CI)**.
* Something we can list out, it is **Countably Infinite(CI)**.
* {1,2,3,4} -> **Countably Finite(CF)**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f67a8c95-1f0e-4ad2-ad76-56ec5f9ace92)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06ed0ce6-601f-4b52-b5c1-aac33283ccf2)

* Uncountable.
* Set of real numbers.

* Sigma ^ * -> Means everything including Epsilon.
* '*' -> Kleen closure
* Sigma ^ + (sigma to the power of plus(+)) -> Only Epsilon missing.
* '+' -> Positive Closure.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e913695-f30b-476d-9259-da52e1073d79)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9aa8c5b9-c181-4100-9f83-cbc489990cc7)

### Language

* Language -> Collection of strings over the given alphabet is known as **language**.
* In the language, infinite no. of strings are here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c014480-ebbf-428d-bace-816eedb49f7d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f5c3658-e6a9-4cb3-9a36-1f402c2d8d1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81a06104-6b08-440a-8338-84cb6d87ab64)

* Example
* In general, **language(L)** is **subset or equal to (sigma ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77c6b719-d3a2-4d8a-8e16-059dde51fc84)

* More than **(sigma ^ * )** is not possible. Not possible, no concept there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5aeb8821-55ff-424d-b99f-291d5281a267)

* From everything take a **subset**.
* We can take **infinite as well as finite** subsets.
* Don't go beyong **(sigma ^ * )**.
* Empty set is subset to every set.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc5b66ec-5f52-4e82-9ea2-7f77102f497f)

* **L5 and L6** are **language** because they both are **subset** of **(sigma ^ * )**.
* In **L5 language**, the language is **not empty** but the string accepting is **empty** string.
* In **L5 language**, **one string** is there whose length is **zero(0)**.
* In **L6 language**, the language itself **empty**. No one is there. One string is also not accepting.
* We can take **everything** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3bd6146e-9e74-4267-96b2-b6a932de527c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f4cb14e-20fa-45bc-9bb6-da5509b670ed)

* Countable Language

1) Countably finite -> Set of all Indians.
2) Countably infinite -> Set of all natural numbers, Set of all computer programs, Set of all Turing Machine.

* Uncountable language -> Set of all real numbers

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d3c1226-de64-478f-9f5f-e9968da02418)

* Computer program is nothing but Turing Machine.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2ef958c-7015-4696-ae62-2ac9d39066cc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/231894ff-907d-4305-a4c4-48d189bc792b)

## doubt-clearing-session(4) [4th Sept 2023]

## Finite Automata and Regular Languages [**IMPORTANT**]

* Finite Automata:- [Types]

1) Without output

* DFA
* NFA

2) With Output

* Moore Machine
* Mealy Machine

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92ee9b63-70f2-4810-8100-99149e2ab340)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/957efb2d-3d57-48b1-a560-534a429db5c3)

* Finite automata without output means if we give **string**, it will say **string** accepted or rejected.
* This is finite automata as a **language accepter or rejecter**.
* Finite automata accepting the language or not.
* This is finite automata as a **language recognizer**.

* Finite automata with output, it will give **output**.
* If we give two binary numbers, it will give **sum** as the outut.
* This is finite automata as a **output generator**.
* Incrementation, **2** becomes **3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/740510ea-2e11-4e56-988b-96bcc5a6c2e1)

* When can we say that a language is regular?

> For that particular language, if we can construct a finite automata.

* If we can do that then the **language** is a **regular language**.
* **W** can be anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b0cd5df-c266-4cf7-9755-4cb3dc18e14b)

* In the **a ^ n**, except the **first 'a'** and in **b ^ n**, excet the **last b**, remaining definitely will be taken care off.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/680a2515-9030-48e4-a591-83f655ce9474)

* If **finite automata** is possible then the **language is regular**.
* **Finite automata** as a language recognizer
* **Finite automata** as a **output generator**.

### Finite Automata without output.

* Finite Automata without output -> DFA and NFA.
* By default **NFA**.
* Deterministic means very less people know clearly.
* Until and unless mentioned about **DFA**, we will not go for **DFA**.
* Finite Automata(M) is a **machine**.
* It(FA) is also having some story.
* Every machine is having some story.
* Inside **FA**, some states are there.
* **'Q'** -> Finite and non-empty Set of states.
* Every machine accepts some language. When we say it is accepting some language, every language is in need of some alphabets.
* Every machine has some purpose.
* **Sigma** -> Alphabet, used for input purpose. **Input alphabet**.
* Until and unless the total diagram is available, we cannot tell what is the **language**.
* Total machine should be available.
* Until and unless we see the total machine, we cannot say what it will do.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/872375db-1009-4d60-92b2-6d056265931a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ba12bfb-7c9c-4b31-851e-2fdbc31bfe18)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c0e92d4-0085-4f0d-8809-c6ce1e31ef86)

* Until and unless we see the total machine, we cannot say what it is going to do.
* If we **combine**, then that is **our sigma**. That is our **input alphabet**.
* Union of all language we know, that is **our sigma**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a19f253-50d3-4514-8a7d-92e5ffed8c3b)

* Sigma = {a}
* It means that the language contain one letter which is **a**.
* All combinations of **a** are allowed, which are the **strings**.
* Alphabet is indirectly deciding what should be there in the **language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7683ab9-34cb-4a7a-9cdd-290ab2489f1a)

* Finite automata given -> States are given and Input alphabet also given.
* **Sigma(Input alphabet)** for ATM is **0 to 9**.
* Every machine having some **Sigma(Input alphabet)**.
* Every maching having some **language**. Every maching will accept some **language**, in that language what symbols are allowed that is called **input alphabet**.
* Output maybe something else.
* In the **output** some symbols are allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/91c00137-dd6f-4630-a53e-f23cd79b50e2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d343a3dc-5d9c-486e-978e-7ad04b854f23)

* We cannot write **output** here as we are designing **FA without output**.
* When we are designing **FA with output** then the **output alphabet** will also come.
* **Without output** -> Language recognizer.
* It will finally say **string accepted or rejected**.
* At the end of the input string if we are in the **final state** then **string is accepted**.
* At the end of the input string if we are in the **non-final state** then **string is rejected**.
* **F** -> Set of final states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0e1d5c8-518d-48db-8d75-b9fb80481f01)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77d19ce8-aa65-4f99-b462-39ac53e303c2)

* Finite set's **subset** is **finite** only.
* **F** is the **subset or equal to 'Q'**.
* From one machine to another machine, some changes are there.
* In some **automatas**, **two states** maybe final.
* In some **automatas**, **every state** is final state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/664b1e62-ddf3-4233-a7a8-bfa7631a24b9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/913e2d27-7c25-4a6e-b580-f6a26940f90d)

* Finite automata **without final state or no final state**, it will accept **phi**.
* Language of that automata is empty language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f5b91fb-f97a-4951-b910-801f1a7c657a)

* Alphabet maybe many, but no final state.
* Delta -> Transition Function.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5519788-6b2c-436a-b902-ad1016cbcb81)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80d6f265-1843-4ab0-826e-597c4da1095a)

* Transition Function -> We are going from one state to another.
* We can write the function or draw the diagram.
* They are same.
* **q0** -> Only one start State or initial state. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f4824ee-b129-4cc5-bf76-2819b9be7afd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed54e804-3443-408d-bfb3-f667ed9fb8ae)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55f92203-2500-4ddb-9f49-b939284019ca)

* [**IMPORTANT**]
* All these 5 things are there.

1) Set of states
2) Input alphabet
3) Set of final states 
4) Transition function
5) Start state

* If finite automata is given then these **5 things(above)** are given.
* These finite automatas are without output.
* These finite automatas are for **language recognizer** purpose.
* Lastly **yes or no**, did we reach **final state** or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f041157f-a77c-49ec-9cd6-2604e6bc3677)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c89ed602-fbf2-4610-b14d-ec6942bd4333)

* This is why finite automata is called as **5-Tuple machine**.
* This is for **NFA and DFA** both.

 ![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd540da7-6414-45c9-ab62-b3866af1925a)

* Initial arrow indicate **starting state**.
* Double circle indicate **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8be2b638-8a89-4b2f-94c0-7a32b9bedc8f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31ff63fa-f68c-432b-b81e-c531d424e8d8)

* Q = {S1, S2}
* Sigma = {a, b}
* F = {S2}
* q0 = S1
* Transition Function

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/783e2874-6298-4393-98fd-a8158c670f15)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/156f1976-f2bc-43df-9a6b-501a9d23aa5d)

* By looking at the table, we can say that we have **two states** in the automata.
* '*' -> Final State
* '->' -> Initial state.
* Automata can be represented in the **transition diagram** or in the form of **transition table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e922ac68-522f-40ec-92f4-ec33b787d2c8)

* Representation of FA:-

 1) Transition diagram
 2) Transition table

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aee2be0d-ae02-45ad-a876-f9d619549e2f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39920f66-3131-4b6f-956a-9752adf8dfdf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18c5b1ec-e24e-4139-8a93-96e3b65f2b6a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59078eeb-0ee8-4e97-9538-481b3e832c67)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/537abe13-ec00-46d5-9c17-bfecf6b00f08)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88980c7e-96b9-4ad0-b1ab-401755398e68)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e3aee15-c0be-4bcf-b049-b62b50bf0b3a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b55e0741-d944-43ff-8de1-eb3995933385)

* Two diagrams
* First diagram, from each and every state for every input symbol, we are exactly going **one state**. Not more nor less.
* This is **DFA(Deterministic Finite Automata)**.
* Exactly having one single behaviour. Deterministic behaviour

* In the **second diagram**, **S1** on **input 'a'** is not going anywhere. **S2** on **input 'a'** is going many places(S1 and S2).
* This is **NFA(Non-deterministic Finite Automata)**.
* Different plans are going on. Confusing family.
* No Clarity.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bba8df00-ad48-4609-8946-1a32255d1762)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62d3ac48-c39b-4b0e-a5b9-c751fe0e9f62)

* [**IMPORTANT**]
* DFA -> In the case of **DFA** from each and every state and for every input symbol, exactly **one transition**. Not more nor less.

* All **algorithms** are **deterministic algorithms**.
* Each and every state -> Rows are covered.
* Each and every input symbol -> Columns are covered. 

* NFA -> In the case of **NFA** from each and every state and for every input symbol, we have zero transition, one transition or more than one(1) no. of transitions(zero or more than one(1) no. of transitions).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c907d56c-c507-4db3-b4c4-11ae1f6bbdf6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05bb5fc9-7ca0-4836-8323-6a431c58c7fb)

* **NFA** having many possibilities.
* **NFA** is more flexible or a lot of flexibility.
* **DFA** construction is **difficult**. Everywhere **1** only.

* While construction **NFA**, luckily everywhere **1** possibility is there. This is also **NFA** and it is a **special NFA**, called as **DFA**.
* A special type of **NFA** is called as **DFA** where, everywhere **1** possibility only.

* Every **NFA** is **DFA** -> **NO**.
* Every **DFA** is **NFA** -> **YES**.
* **Superset** is **NFA**.
* **Subset** is **DFA**.
* **DFA** having **less possibilities**.
* **NFA** having **more possibilities**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63988f0b-4982-4a12-9e08-ccc6db053fde)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a82e2550-5b97-4458-986d-2c7ed5c3d7d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07914c9a-823f-4f90-899d-276465aa13d3)

* Every DFA is NFA but every NFA need not be DFA
* **DFA** is a **subset** of **NFA**. [Will be confusing]

## dfa-construction-ii (5) [5th Sept 2023]

* Construct minimal DFA that accepts all strings of a's and b's where in every string, where the starting letter should be **a**.

1) First the language first.

* Minimal String to be accepted -> aa
* Sigma -> {a, b} -> a or b
* Can also be written as, (a + b) -> a or b.
* Both are **same**.
* Anything -> (a + b) ^ * -> (a, b) ^ *.
* Whole Star('*') -> We can go inside any no. of times. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a626bcc-4101-4585-8e0f-9485cb20d1ae)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d034028f-b7f1-45f9-ae67-2a06189e926b)

* 'a' followed by **anything**.
* (a, b) ^ * -> (a + b) ^ * -> (a OR b) ^ *.
* They are **same**.
* These **automata** will accept all strings of **a's and b's**.
* Sigma -> {a, b}
* All strings -> Sigma ^ * -> {a, b} ^ *.
* Starting letter is **a**.
* **a** followed by **anything** is ok.
* **(a * (sigma ^ * )) -> (a * (a, b) ^ * )** 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5ad985a-bda2-4ebd-9963-b662245e5704)

* a * b -> ab -> We cannot write this as (a, b). It is **one people only** -> Concatenation -> 'a' followed by 'b' -> Two strings became one string only.
* Followed By -> Dot(.) -> Concatenation.
* a + b -> a or b -> It is **two people**, either 'a' or 'b' -> **OR or union** operation -> 'a' or 'b'.

* If we want to make **two strings** as **one string** then we will use **Concatenation**.
* If we want to make **two strings** as **two strings** only then we will use **Union**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc0fa6e7-6244-4853-a108-e765f020e7c2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f67e1b30-c54b-4748-89e8-dceb90e1db20)

* 'a' followed by anything -> a.(sigma ^ *) -> a.(a+b) ^ * -> a(a+b) ^ *.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa1a29c1-8a1e-48c7-8484-b8ec237d07d9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6136af1-ec50-4be3-88bb-cfd8ac5eb180)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f458211c-37c3-4538-84f8-a115b9d4dd27)

* As whole star(*) is not there, by default power is **1**.
* We can go inside **once only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b4c87c7-854e-4cf8-8392-43ac06cc3a8f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed970a5b-e528-495b-ae48-6d7ad020409c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82295f28-bf5b-438e-a817-ca8bf8181bbf)

* Three operators:-

1) Plus('+') -> Union
2) Dot('.') -> Concatenation
3) Star('*') -> Kleene closure.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65e90ab3-adc4-46b5-bb26-7ae22f4efd8a)

* Minimal String -> **a**.
* Minimal Length -> **1**.
* Without minimal string, don't try to create a **DFA**.
* If the **Minimal Length** is **1** then with **1 + 1 -> 2** states, start constructing the **DFA(Automata)**.
* On the **transitional line** also keep the **minimal string** symbol.
* Make the **last state** as **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c4b8dce-3d04-4d0e-9b88-3edb3e6e085e)

* Starting from **S0** by reading **a**, it will go to **final state(S1)**. **a** is **accepted**.
* The purpose of **states** is that every **state** will **remember something**.
* (a + b) ^ * -> Minimal is **epsilon**.
* At the end of the string, where we are that matters.
* At the end of the string, are we in **final state**? 

> It is **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8db192d4-da42-47e3-8ebe-002ab6acebff)

* If **loop** is not there, then we cannot **accept infinite things**.
* (a + b) ^ * -> It generates **infinite** people.
* If we don't keep the **loop** then we cannot accomodate the **infinite** people.
* We have taken **2 states**, as it is a **finite automata**. We cannot take **more states**.
* The **language** given is **infinite language**. The only condition is that the **starting** should be with **a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e335f4f-f062-4e57-b248-94b50b2cff93)

* In **((a + b) ^ * )**, we can take **epsilon**. Overall we cannot take **epsilon**.
* Overall no change of **epsilon** as already **a** came.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8cd2174c-b91e-444f-8594-27a9af1ca2a1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9141e3a8-5df4-46b6-bd85-2be44bc7b7a1)

* aabab -> String accepted.
* We came to **S1** it means that we started with **a** only.
* If string not started with **a**, we cannot come to **S1**.
* We have to start automata from **starting state** only.
* We cannot start from wherever we want.
* Valid thing, starts with **a** only.
* We started from **S0** and after looking at **'a' input** we changed the **states** to **S1**.
* If we want to remember **something new** then only **change the states**. [**IMPORTANT**]
* Every state having some meaning.
* **S0** on **input 'a'** -> **S1**.
* **S1** on **input 'a'** -> **S1**.
* **S1** on **input 'b'** -> **S1**.
* Sigma -> {a, b}
* States -> S0 and S1.
* States are **two** and inputs are **two**.
* **DFA** means, if we want or not, we have to complete eveything.
* In the **language**, starting with **b**, nothing will come.
* Deterministic -> We have to saw for everything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f9f3992-0848-4226-a7d2-da5338d486b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d0e6c69-7eb4-457d-9109-cbbe66a49000)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcb8dae3-90f1-4c5e-ab31-82d72fa89d82)

* Required things are completed, stop the diagram.
* This is **NFA**.
* Computer programs are **DFA**.
* We have to say everything.
* According to the **language**, **starting 'b'** is not possible.
* If someone starts with **b** then **no change of final state**.
* If we come to **S2** then no change of going to final state(S1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8435f11-709e-4b6c-8a71-d3b811b3a08f)

* This is not **DFA**.
* **a and b** we are not covering in **S2**.
* After staring with **b**, anything will come, we cannot go to final state(S1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/577c187c-c6fa-4355-bb27-06a1e8f72cc2)

* This is **DFA**.
* Deterministic algorithms.
* **S2** will say that string already started with **b**.
* In the diagram, we have **three states**.
* Final states -> 1 [S1]
* Non-final states -> 2 [S0 and S2]
* If at the end of the string, if we are in the **non-final states** then **string** is **rejected**. 
* If at the end of the string, if we are in **final state** then **string** is **accepted**. 

* From **S0** anyway to go to **final state**?

> If we are at **S0** then we have **some hope** of going to **final state**.

* From **S2** anyway to go to **final state**?

> If we are at **S2** then we have **no hope** of going to **final state**.

* So, **S2** is called as **dead state**. 
* **Dead State** -> Non-accepting state and no hope as well.

> **S0 and S2** are both patients in one of the hospitals, after testing is over, the doctor said that there is **some hope** for **S0** patient. **S2** is dead already. **S2** already gone.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/667c0f6b-d223-4942-8676-3035ea537929)

* **S2** is there because of **DFA**.
* We have to include everything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17bea880-24ea-469a-b49b-cd727720f461)

* **Dead state** is one of the states.
* If anyone comes to **Dead state**, they cannot move any further. No way.
* Behaviours matter.
* Names doesn't matter.

* From **S2** state, we cannot reach the **final state(S1)**. So **S2** state is a **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c9e381f-24d2-40af-a663-903cb555b4cc)

* If we remove the **loop** then the automata will not be **DFA**, it will be **NFA**.
* Because of **DFA**, we have to keep the **loop**.
* If a string is starting with **b**, then there is **no change** of reaching the **final state**.
* **S2** means already stated with **b**.
* After starting with **b**, anything happens we do not care.
* Total states -> 3
* Minimal DFA contains **3 states**.
* Dead state means **no acceptance**.
* **S2's** behaviour is **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fa51cbb2-60f0-4df4-8cf9-729d6f7344cb)

* Minimal Finite Automata -> NFA -> 2 states
* Minimal DFA -> 3 states

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac43c76b-49d8-4501-916e-594b225f7643)

* [**IMPORTANT**]

* CMDFA -> Construct Minimal DFA
* L = {Set of all string over a and b}
* Sigma ^ * -> (a,b) ^ * -> (a + b) ^ *
* Minimal String -> Epsilon.
* Epsilon length -> 0.
* With **0 + 1 -> 1** states, start the **automata**.
* With **1 state** that itself is **starting and final** state.
* Actually by reading some symbol we go to the **final state**.
* Without reading anything, we are going to the **final state**.
* It means that **epsilon**, we read.

* **NOTE** -> Start state itself is the final state then by default **epsilon** is accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ad23f4e-2571-49f0-84d4-743539a34485)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff64aac2-f284-40d1-b8ea-5f0ecc4c209a)

* Nothing special.
* Here, no condition, everything OK.
* Everyone allowed.
* It is **DFA**.
* If it is **DFA**, then indirectly it means that it is **NFA** also.
* Everywhere exactly **one transition**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a23f5f0b-8f12-4876-9a31-1d189104db77)

* If **conditions** are **more** then **states** are **more**.


* CMDFA -> Construct Minimal DFA
* L = {Set of all string over a,b excluding epsilon}
* Sigma ^ + -> (a,b) ^ + -> (a + b) ^ +.
* Except **epsilon**, everything will come.
* Minimal String -> 1 length
* With **1 + 1 -> 2** states, start the automata.

* Whenever there is **some hope** then that state is not a **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/230f1150-9679-4e2b-aad6-ca08f667c8cc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb7cdbcd-d2ed-4781-aefa-c0f201ec8efb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6516a8f7-701a-4e29-ab9b-ecfd51619b9f)

* If we come to **S5** state, then we are **dead**. We have no change of going to the **final state(S3)**. 
* Other than those **three(a, ab, ba)**, if anything else comes, **reject** all of them.
* In total we have **5 states**.
* It is a **finite** language.
* After some point of time, all of the strings are over.
* Whenever it is a **finite** language, after some point of time, all strings are over.
* Even though all are over because of **DFA**, we have to cover some unnecessary things.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e2a6444a-97ce-47a9-adbd-2b56f660eb42)

* If we construct a **DFA** for a **finite language** then compulsory **dead state** required because other strings, we have to reject.
* Only three strings accept remaining reject. The red color indicate remaining. The remaining is **infinite**. There is a **loop** also.
* Whenever we say **infinite**, **loop** required.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cf430051-d66f-4501-b814-5cb9781a83b2)

* DFA  for finite language -> Dead State mandatory.
* Only three strings, we have to accept. After three string are over because of **DFA** other strings we have to take care. We have to **reject** them.
* The language is saying **only three strings**, not more not less. There is no atleast nor atmost.
* Most of the time **final state** is **one(1)**. Sometimes maybe many, sometimes maybe all.

## dfa-construction-iii (6) [6th Sept 2023]

* L = {Set of all strings of a's and b's where everything end with b}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abe8d44e-27c2-49e1-b03c-0999bf136025)

* Starting **anything** is OK but followed by **b** at the end.
* **((a + b) ^ * ) * b** -> **Regular Expression**.
* **anything** followed by **b**, **concatenation(dot)** will come.
* If we don't write anything, by default **dot** there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82fd6df7-9e52-4026-aa73-77777ad4e760)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de977d1b-218c-454c-81e2-04429e996eef)

* For any language if we construct a finite automata, then that language is a **regular language**.
* Every **regular language** should have **regular expression** also.
* When we say **finite automata** is there, then **regular expression** is also there.
* Minimal String is **b**. No **epsilon** here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/15aac143-b716-4341-9186-157d5e138967)

* Start with **a**.
* **S1 and S3** both will **reject** as they are both **non-final** states.
* **S3** will reject permanently
* **S1** will reject temporarly.
* Finite language means it will accept only a few strings.
* For a Finite language we have to take care about **infinite** also as it is in **DFA**.
* We have to take care of **everything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ffa689ed-57f9-4577-a821-c7d037d838a6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c32c138e-83f0-4cb7-b2ea-dce116a480d7)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f2ee6b0-5541-499f-b123-a323cfa62328)

* **S2** indicates already started with **a**.
* When we are **confirmed**, change the state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44c3ec69-8609-436e-ba7c-41eb947b510c)

* Ending condition -> Ending with **b**.
* Minimal string -> **b**
* Minimal length -> 1
* With the **1 + 1 -> 2** states, start the automata.
* We are in **S1** and the string has not ended.
* Afterways when string ends with **b**, we will go to **final state(s2)**.
* **Loop** means the symbols may come or may not come.
* Mandatory thing, then only change the state.
* Before **b** anything can come.
* We want to write **a,b** in the loop, but we have written only **a**.
* We cannot write **2 b's**. It will be a dilemma machine because **two** different behaviour.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6425beba-cb34-4284-9588-5d04199557e8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1327dd6a-7c54-41bf-8268-c944f1f67336)

* Minimal string accepted -> From starting state to go to the final state, what are the strings we are reading without taking care of the loops. 
* On **S1**, we are going to **S2** by reading **b**.
* We are at **S2** means that string already ended with **b**.
* Ending with **one 'b' or 1 lakh b's** doesn't make. Same thing. Keep a **loop** in **S2**.
* First minimal string of the **automata** is **b**.
* In **minimal strings**, we don't care about the **loops**, no loops.
* The **loops** we have to take **one time**, the **minimal string** is **abb**.
* In **S2**, ending with **b** guranteed.
* We can keep changing **ending**.
* If **a** came at the ending then wait at the **non-final state(S1)**. Afterwards **b** will come, then go to **final state(S2)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a15a7f4-fa84-49e5-b35d-5f0dd3f7edec)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77b99f57-d683-4b8e-a0f8-44228d8fbd2a)

* **Starting** we cannot change.
* **Ending** we can change.
* If we get a string ending with **a** then finally we are at the **non-final state(S1)** and the string is **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d0a189f-b25e-4f47-b463-0320a30d8fec)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce4be864-992b-4cc8-b8d7-f9e05bb0889e)

* Ends with **a** we will go to **non-final state(S1)**. We cannot say this is the ending. Ending will keep on changing.
* In **ending with something** condition, there is **no dead state**. [**IMPORTANT**]
* In **starting with something** condition, there is **dead state**.  [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d178e1e-842f-4d94-9015-2a53fdd5d588)

* On the string **ba**, we will be in the non-final state **S1**. So **rejected**.
* There is hope of going to **final state**.
* **Ending** will keep on chaning.
* **Starting** cannot change.
* Who will go to **dead state**?

> When there is **no hope**.

* **Ending** condition, don't go to **dead state**.
* **Starting** condition, go to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ca37d7f-e852-4629-82ef-23962bceb7c8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8702f42-61ed-486d-ba0e-9e0d93fdd31c)

* We have **2 states**.

* L = {Set of all strings contain 'ba' as substring}
* **ba** should be there somewhere in the string.
* Minimal string -> ba.
* Minimal Length -> 2
* With the **2 + 1 -> 3** states, start the **automata**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e0fd8775-8e6c-4ee3-94fc-4bf05081db32)

* ((a + b) ^ *) * (ba) * ((a + b) ^ *)
* For any language, **regular expression** is possible then **DFA and NFA** are possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2aace801-dbd0-42d3-b3f1-69a5ba5005a3)

* Yes.
* To prove some **language** is a **regular language**, we can write **NFA or DFA** or maybe we can write **regular expression**.
* Out of all the **three**, whichever we can **prove** is possible then others are also possible.
* Just **prove one(1)** out of the **three**.
* **Regular expression** indirectly saying so many things. It is saying that the language is a **regular language**. **Regular expression** there means **DFA and NFA** also there.
* One thing we find out, remaining things also there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0073998-0d4f-469a-8ad6-964e3ed055ef)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a5eca91a-8a91-40d2-9cf9-a02947e04659)

* Every state we have to take care.
* **S3** said that already **ba** came.
* After **ba** anything is **OK**.
* **S1** said that after me, **ba** will come.
* In **S2**, already **b** came and after me, **a** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/153ef7df-82d2-494a-b0ac-487c7fdf5483)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a4ff8a8-15a3-44f5-b126-63c21f63096b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/362f4fc8-0d7b-4e03-b529-0ddea35ad8a5)

* Please respect every state.
* **Minimal DFA** is **unique**.
* **DFA and NFA** are **not unique**.
* Minimum **3** states required.
* Starting or ending no condition. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d0c7bbc3-bc21-4d8c-9173-2e1bff2b33a1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/348adf4c-2aff-4d99-a1d8-85b3868f1dee)

* Ask every state. What are you?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/490b5240-ef45-4c62-8e3f-ec0db4fca8aa)

* 3 states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3efb61d-c08f-4c38-95e0-f032d97a3b14)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4d39baa-b56f-45ad-b55c-6efbf46270d8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59667c07-73ad-43a8-aab1-6b5e823e5895)

* Minimal DFA construction -> Dead State needed or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3bd3db52-5bf8-476c-babb-3fcad01c7e4b)

* L = {All string of a's and b's where every string starts with 'a' and end with 'b'}
* Minimal String -> ab.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a63dd89-acdc-4ed3-9c11-5cd44200ff83)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dc6e4d2-5e29-4e07-aa0e-f324f070f2ae)

* **a * ((a + b) ^ * ) * b.
* Minimal String -> ab.
* Minimal length -> 2.

* **S2** saying that already starting with **a** done, ending with **b** will come afterwards.
* **S2** gurantees starting with **a**.
* **S1** saying that after me, string will start with **a** and will end with **b** and it will reach the **final state**.
* Starting with **b**, go to **S4** state which is the **dead state**.
* If starting with **b** then no need of checking the ending.
* No hope is there.
* **S3** saying that string already started with **a** and ending with **b** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/04a01e08-5258-4538-a9d1-ba19f3ae7332)

* If unformunately **a** came at the end then **ending problem** but already started with **a** confirmed. Ending only problem, so go to **S2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6cb2c03-0e18-4440-abbd-87e6af51ef9b)

* **S1** saying that if nothing started then come to **S1** but we already started with **a**, that's why we are going to **S2** if we get **a** at the end.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f338111-008c-4c22-99c0-c6bcfd74b358)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d9109e6-5528-462c-a989-d9e10e57365d)

* Starting symbol we cannot change.
* We are in **S3** means that string started already. Not only started but **starting with 'a' and ending with 'b'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12983716-df8a-4933-9b52-549ecee14892)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/916fdb84-7ae0-45a9-9f92-0ca0c6ae6e16)

* Ending problem and starting no problem.
* We don't have starting problem.
* At the end, don't go to **dead state**.
* We should go to **non-final** state.

 ## dfa-construction-iv (7) [6th Sept 2023]

* L = {All strings of a's and b's where each string length is exactly 3}

* Minimal length -> 3
* **3 + 1 -> 4** states to start the **automata**.
* (a + b) ^ 3 -> We have to go inside exactly three times. It gives exactly three length string.
* Everywhere **2 choices, '3' times**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d2cd671-c71b-48b9-aee7-d693cb1d0cf3)

* No.
* Star(*) means **many times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a8d25c7-5b67-4de1-8e94-f9818b84b20f)

* More than '3' length string coming, no way of going to the **final state**.
* No hope is there.
* Going to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74783245-69fc-4528-9070-547f257be681)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f7fc248-162f-45c3-af40-f63c396772d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9881426-f4c5-4f27-a950-14a4eafd239b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d777d6dd-1a61-489a-999b-6880ce017678)

* [**IMPORTANT**]

* L = {Atleast 3-length string}
* 3,4,5,6,7, .......
* ((a + b) ^ 3) -> Exactly 3 length string.
* ((a + b) ^ 3) * (Epsilon) ^ * -> ((a + b) ^ 3) * ((a + b) ^ *) -> After exactly 3 length string over, anything can come.
* ((a + b) ^ *) * ((a + b) ^ 3) -> Anything followed by **three length string**.
* The string should be **atleast of length = 3**, doesn't matter if it is in the front or at the back.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b20cda85-5461-428a-8e5d-c7440adbd5c0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9995027-65ac-4d84-bfbc-ffa154759336)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcd194b0-ebb8-4773-a032-502318cf6860)

* We can write more than 3 in the before or after as well.
* Anyside  we can take.
* ((a + b) ^ *)  * ((a + b) ^ 3) * ((a + b) ^ *)
* Minimal DFA is **unique**. [**IMPORTANT**]
* There is **no minimal unique regular expression**.
* **Minimal NFA** is not **unique**.
* Minimal length -> 3
* **3 + 1 -> 4** states are need for the automata.
* It will accept all three length.
* We are in **S4** means that the **3-length string** is over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a4b43ac-0ff2-4a2b-a1a3-d6f8744dbcd0)

* This is **NFA**.
* More than **3-length** is also ok.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84f2ab11-5b8e-48e0-a758-9d13ebf00666)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5492f20-c2bc-4ea6-8a20-ace2e9f12dcc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b8a0aa3a-5359-44ac-b61f-2dee462b2233)

* All of the **three regular expressions*** are going the **same thing** only.
* In any expression, if these symbols(*, dot(.), +) are there combined, individually, then the expression is called as **regular expression**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a842efe-68e6-40c0-be54-76c2fd1b8bc1)

* There is **no unique regular expression**.
* All three are **regular expression**.
* Minimal **DFA** is unique.
* Minimal **NFA and regular expression(RE)** is not unique.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cb9e109e-c4c7-4459-bc5a-0122b207b394)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f75fa02e-218d-437c-8ef8-e4917182f2b4)

* **Note**:-
* Minimal DFA atleast 3-length -> 3 + 1 -> 4 states -> No dead state required
* Minimal DFA atleast 100-length -> 100 + 1 -> 101 states -> No dead state required
* Minimal DFA atleast n-length -> n + 1 -> (n+1) states -> No dead state required

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/170291ca-40cd-4494-9dd7-4758ef11b91b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f3866ae-5dff-4484-9463-07903b97f41e)

* If asked in **MSQ** and all of the **three expressions** are given then all of the **three** are **correct**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0edfe886-e125-4af2-915f-952b677b13d8)

* [**IMPORTANT**]
* **NFA** is possible for **regular language**.
* **Regular language** means **NFA, minimal DFA, DFA and regular expression** there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d25b46a-c676-463b-bf0a-c4a3e4e5b167)

* L = {Set of all strings of a's and b's where each string length is almost 3}
* It is a **finite language**
* As it is a **finite language**, so the **Dead state** is compulsory.
* Minimal length -> 0
* Minimal string -> Epsilon
* Initial state = Final State -> Epsilon accepted condition.
* **0 + 1 -> 1** state needed to start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31730ce2-792b-4a74-bf3b-634e50fca002)

* Zero(0) length string is **accepted**. Epsilon accepted.
* If we keep **self-loop** then **1-lakh a's** are also accepted, which we don't want.
* So no **self-loop** allowed. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d760185-a79e-437d-aa53-3f115597999b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36716dbf-cf0e-4a6d-a2bd-ec7ceeeff6ca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f90acbd7-4290-43db-905e-6a2bf421c1bc)

* As we have **0,1,2 and 3** string length as **accepted** that's why all of the states are **final states** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36d8560b-f69f-49da-8776-7999a3f45327)

* There is **dead state**.
* More than **3-length string** is **rejected**.
* Minimal DFA -> Atmost 3-length -> 3 + 1 = 4 states -> 4 + 1 = 5 states ['1' is a dead state] 
* Minimal DFA -> Atmost 100-length -> 100 + 1 = 101 states -> 101 + 1 = 102 states ['1' is a dead state] 
*  NFA -> Atmost 3-length -> 3 + 1 = 4 states [No dead state in NFA] 
*  NFA -> Atmost 100-length -> 100 + 1 = 101 states [No dead state in NFA] 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/025d96fa-db8e-41b3-8f28-9af75305c82b)

* Every **dead state** is not only **non-final state** but also **permanently non-final state**. **Yes**.
* But every **non-final state** is not **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/610f7e2d-fee7-41ee-ac14-4d191e2bafe4)

* Non-final state -> **D** state -> Dead State.
* Max. characters allowed are 3 characters or strings of length = 3.
* This problem having maximum **3** places.
* In every place we can keep **a or b or epsilon**.
* We can go inside **exactly 3-times**.
* Everytime we can select whatever we like.
* **zero(0) length we add three times, we get zero(0) length only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8b0610e0-d81a-433c-b54e-1b5b8cdbf658)

* Two length will come
* One length will come
* Three length come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ede19d6-6210-4540-878a-3bcd353ba993)

* Three times only allowed. More than **3** not allowed.
* If we do **(sigma ^ * )**, the answer will be **1 lakh**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b622f786-57e3-4f76-b876-a6d9dc5df188)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cd84c46-94db-4617-a623-4e66f6a4d39f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55d83f99-9bfb-4ff1-a6c8-65c055c7480a)

* **Whole cube** doesn't mean that all are **three length**. **NO**.
* This is the reason.
* We don't know what's inside. 
* **Whole cube** -> Go inside **three** time.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a06d36f9-000b-4e69-98e9-45cafba11b72)

* Yes.
* Inside can be **anything**.
* What is there inside, please check.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7820aa91-0405-484e-96db-12f9b41ea4ff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f106f1a-5716-448a-b0a5-9f98a566c74a)

* [**IMPORTANT**]

## dobut-clearing-session (8) [6th Sept 2023]

* Prefix -> Set of all leading symbols -> Starting onwards we have to read -> Leading symbols should come -> Starting is compulsory.
* L = {Accepting all prefix of string abababab..... }

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53597f98-fc6f-4f10-8a13-9983420fa1d1)

* First prefix is **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/deb7b513-850f-4dcc-91e5-d7b1dae12b34)

* How many proper **prefix** are there?

> **Exclusing itself/himself**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c91325a4-01a0-4dcd-8e88-6d5ad6e59927)

* For an **n** length string, the no. of **prefix** are **(n + 1)**.
* For an **n** length string, the no. of **proper prefix** are **n** only.
* Minimal length prefix is **zero(0)** which is **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17a455e9-a6b0-4909-8eb3-8e85efa64e40)

* Minimal string -> epsilon
* Minimal length -> 0
* **0 + 1 -> 1** state, start the automata.
* All valids should be **accepted**.
* All invalids should be **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/308dba47-a612-4816-8122-f2944b9c718c)

* NFA.
* Accepting all **valids**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2a4dd004-d94c-4e51-9e2d-308f76843a12)

* Minimization of DFA [Later]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bdb0ae32-d1c3-4c85-9c72-b6223899d75b)

* We are doing **minimization of DFA** on **1** to get the **minimal DFA** which is **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25c7fb80-f6b0-41e3-8565-5602a2f97d92)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01397f24-e5db-4421-b132-92ebf4a9facc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/64bfb61c-ea40-4b1d-9295-8367f9c4fbdf)

* Now this is **DFA**.
* Starting with **b**, there is **no prefix**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1b7c3f9-95a7-4c00-b4d0-08d5ff85dee5)

* They don't go **outside**.
* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e60eb2ae-618f-4960-8ddc-6ea7c0c87cc9)

* Use the already **dead state**. No need of another one.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4db0122f-0e18-45c2-ba4d-911add02ab9a)

* No string is starting with **b**.
* Side by Side **a** is not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8094207-61d2-4d96-8e0f-36290e650d83)

* The string is not going to me our string, **now also and in the future also** then it is in **dead state**.
* **DFA** is not unique, **minimal DFA** is **unique**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbbb09f8-a78f-4e82-bbfa-fa69cdca6998)

* When **no hope** then go to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7a76ade-0a6a-4974-8469-884196297feb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/141082fe-2c95-4f63-b360-7c5401cb0753)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e6beb78a-ce18-4794-9a6e-7c21d5a57933)

* L = {All strings of a's and b's where length of each string is divisible by 5}
* 0/5 = 0.
* **Zero(0)** is divisible by **5**, **YES**.
* We don't care what's inside the strings, whether they are a's or b's.
* We only care about the **length of the string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf7b9d4d-081d-4e91-af1f-bd9c65304128)

* AP series.
* Common Difference -> 5 [Loop/cycle]
* With a **5** length there is a loop/cycle also.
* If anything will create an **AP series**, it is compulsory that **finite automata** is **available**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2af94a43-a7b9-4a04-8619-9b7ef97ad29f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2554389b-6144-4a30-90c5-e05069a01a92)

* With a **5** length there is a cycle.
* Every **5**, we have to come back. That's the **common difference**.
* Every **5**, we will **accept**.
* In **minimal DFA** where every string length is divisible by **n** contains **n-state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4354b36b-7021-4c63-a168-2b97e1cfaa0a)

* Language is **regular** or not.
* We will just check if **AP series** is coming or not.
* If **AP series** is coming then **finite automata** is possible.
* **common difference** means **cycle** is possible with that **common difference**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b951b5de-2563-4078-b7af-433bf8ed2734)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36c4cb46-3488-42d4-add5-e76a68cdf762)

* AP series possible
* Common difference -> 1.
* One length cycle is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/971f767a-8195-4ba4-aa13-c6a91157debf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e3e1a49-7621-447b-8027-2d2963f6f556)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b257437c-4d92-4c22-941e-c1525049fb27)

* AP series coming or not.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe1ce1a7-097d-4705-95e1-060c1445148c)

* If we make **S0** as **final state** then **0, 5, 10, 15...** length strings are **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6a51486-5724-4980-b4b6-0fee49b0f3ca)

* Make all of the **non-final** state from before as **final states** now and the **final state** from before as **non-final** state.
* Whatever we were **rejecting** before, now we are **accepting** them.
* This is the **minimal DFA** for **accepting** all of the strings who length is **not divisible '5'**.
* This is the **complement** of the previous one.
* This is **L'**, 'L' complement.
* **L'** -> {Set of all strings of a's and b's where each string length 'not' divisible by 5}.

* If any problem, **not** is there then we will **remove 'not'**. Construct for **without 'not'** first. After that, do a **complement** which is make the **final states** as **non-final states** and the **non-final states** as **final states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0ff867f-52a5-4028-90cd-9471c7812f7b)

* [**IMPORTANT**]
* Don't try to create **'not' first**.
* First create **without 'not'**.
* **Epsilon** is not accepted here.
* **5 a's** are not accepted
* **3 a's** are **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f23458b2-d52f-43e2-9c68-f6854ae3181e)

* L-complementation(L').

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e6b8013-97c6-460e-ba4f-3aa38429b09b)

* L
* A' -> Other than **A** -> From universal set(U) remove **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e1704ca-f2b8-4b51-b4f9-22e1cb045110)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23b320ff-fb4c-4a54-adbe-dcd6aed3472c)

* If two people are **complement** to each other then **L intersection L' = Phi** and **L U L' = (Epsilon ^ * )**.
* Union should be everything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7876b813-83e2-4970-ada7-7e2deb2fd15e)

* L and L' are complement to each other.
* Try without **not**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/810193f8-086c-42bc-bdd1-347f83cb8804)

* If **L** is a **regular language** then **L'** is also a **regular language** because for **L'**, **DFA** is also possible.
* If it is **NFA** and we want **complementation** by interchanging **final and non-final** states, **NFA** will not given **any gurantee**.
* For some questions, there is **no answer**.
* In **DFA**, **complementation** works.
* If we have **NFA** and we want the **complement** then first we have to convert the **NFA** into **DFA** and then do **complementation** on that **DFA**.
* Don't do **NFA complementation** directly.
* **DFA complementation** is **guranteed** and always **possible**.
* **NFA complementation** is **no gurantee**.
* **NFA** means multiple things.
* Finale(F)
* Non-finale(NF).
* It will work in **both directions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/debbb8e1-3333-4226-bffd-257fb63d4bd7)

* On **S1** with **input 'a'** there are **two** different behaviours.
* **a** possible in both the cases/places(L and L')
* Both are accepting **a**, that is **not possible**.
* In **complementation**, how something is **common**.
* In **complementation**, intersection should be **phi**.
* **NFA complementation** is **no gurantee**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56e7a7ae-5ccd-4d9e-92c3-dddc680cf918)

* **DFA complementation** is **guranteed** and always **possible**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22b7074e-e66c-43f6-aa51-f165d4d86377)

* Do **conversion** first and then do **complement**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e17d649-3b3c-48f7-9ae9-c5b95dc85ae1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a7626d7-67dd-4a42-8753-9c9105e97332)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3dc598f7-b8c1-48ef-8610-14a2e0f27f9e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1e603bb-e92f-4b4f-8292-66f0058c6047)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21b32f18-bd13-47c2-ac7f-5fec82081e1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0be37e61-d727-4f05-8fac-2e0ce1e28898)

* Because of **NFA** we cannot give any gurantee.
* We have to do **manually**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3b06d7c-841c-48c9-b5dc-1a34d7125b0f)

* Now, interchange
* Final -> Non-final
* Non-final -> Final
* What is **L1**, if it is **DFA**?

>  (Sigma ^ *) - L.

* As we have **NFA**, there is **no gurantee**.
* We have to check **manually**.
* We got **(sigma ^ * )**.
* Everything **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee950985-a49f-4692-aa04-c46b36dbd067)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e815a47-da9a-4217-98b3-2a70e48af796)

* What is **L1**?
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/278f82f1-27b2-40ea-babb-1b8e9a25f5ae)

* **DFA** is direct.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38498d17-aede-4f88-b78f-7974f43acaeb)

* When we say **language** take the **accepted** things.
* When **language**, check what are **accepted** things.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37ab1efe-18f6-49eb-bfa0-0c1f4a93dee8)

* When **DFA** is there then the **language** is a **regular language**.
* **DFA** there means there is a **AP series**.
* All are **related**.
* From **DFA** we can get **minimal DFA**.
* From **NFA** we can converted to **DFA**.

## dfa-construction-v (9) [7th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ec88083-6b17-456c-bebe-b18528a250b6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83010aa8-b621-4e48-b15b-635049e22dc2)

* Epsilon is accepted, only a's are accepted, only b's are accepted, a's followed by b's are accepted.
* Minimal string -> Epsilon
* Minimal length -> 0
* **(0 + 1 -> 1)** states are needed to start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc46156e-5c37-45ac-9cb2-bf71599dc39e)

* Epsilon is accepted, only a's coming, only b's coming, a's followed by b's are coming, b's followed by a's are also coming which we don't want.
* So we need a **new state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/869732af-40c2-4a64-9e1b-5598148edf8c)

* **S2** means we have already seen **b**.
* After **b** if we see **a**, then **no hope** of going back to **final state**. We are going to **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2035e7fd-3637-4e8c-8be4-f8e6060769de)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a109d058-4599-43b3-9f04-6cb7c3fb9368)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2eda6a7f-ba83-48d0-a663-1f9612b53c27)

* **DFA** with **more than '1' final state** has **more power** compared to the **DFA** with only **'1' final sate** because the **DFA** with **more than '1' final state** is **accepting more people**.

* For a particular langugae, we have a **DFA** with **more than '1' final state**, can we convert it into an equivalent **DFA** with **exactly '1' final state**? 

> Sometimes maybe possible, not everytime.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6bd398be-36d1-4fa7-903e-cae832ccafee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89572cf1-b41d-4991-8cef-ffe793cea801)

* After b's, we don't see a's.
* It is a trap.
* (a ^ *) * (b ^ *)
* (a ^ *) -> Min. a's allowed is **zero(0)**.
* (b ^ *) -> Min. b's allowed is **zero(0)**.
* Star(*) -> It means that inside we can repeat any no. of times. To whom we kept **Star( * )**, we can repeat them any no. of times.
* (a ^ m) * (b ^ n) -> Concatenation.
* **m** no. of **a**, *followed by*, **n** no. of **b** -> **Followed by** means -> Concatenation

* **m** no. of **a** OR **n** no. of **b** -> **Plus(+)**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/86d1f041-b709-4ff0-8c7c-b1c0206c1186)

* Minimum one **a** needed, min, one **b** needed and min. one **c** needed.
* (a ^ +) -> Inside **minimum** we have to take **one time**. **Epsilon** is not there.
* (b ^ +) -> Inside **minimum** we have to take **one time**. **Epsilon** is not there.
* (c ^ +) -> Inside **minimum** we have to take **one time**. **Epsilon** is not there.
* Minimal string -> abc
* Minimal string length -> 3
* **3 + 1 -> 4** states needed to start the **automata**.
* **S4** means we have already seen **a, b and c**.
* After **c** any no. of **c's** are allowed.
* After first **c** we don't see any **a's or b's**.
* **S3** indicate first **b** over.
* **S2** indicate first **a** over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/02583265-e50d-4f57-8823-331491b44259)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb670cfd-5757-4f83-a4c8-59d33e267758)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecb699b2-1658-4840-9ecf-a13532910476)

* At **S1**, **hope** is there.
* [**IMPORTANT**]
* **Dead state** property -> It is one of the non-final state from which we cannot reach **final state**.
* **Non-final state** -> It is a state from where there is some hope of reaching the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4f6fe0b-724e-4fc5-bcf1-659d522bdc90)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/658ab590-293e-4618-bd90-6719db35a432)

* Regular Expression -> (a ^ *) * (b ^ *) * (c ^ *).
* Minimal String -> Epsilon
* Minimal string length -> 0.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0edd643f-9ae1-454f-98b8-4817d0e82b2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb1e18a0-916b-407b-8829-1d831381665b)

* Only a's, only b's, only c's, a's followed by b's, b's followed by c's, a's followed by c's, a's followed by b's followed by c's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/304b0907-9880-4024-b55d-74c72181c8e4)

* [**IMPORTANT**]
* According to language every **valid string** is covered -> NFA -> Every **valid thing** should be **YES**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dedd875-152a-42e3-8827-5f4aad227af6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/888d947e-1f4c-4e2b-b95f-532a2ab07bb3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ba665973-b211-4c87-ad37-12fef94c126d)

* After **C's** we don't want to see **a's and b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/214b02a7-9246-49b5-ac3e-66e7a0aeed41)

* **S2** means **single a** came
* **S3** means **single a and single b** came.
* **a's** are generating alone in the **loop**.
* **b's** are also generating alone in the **loop**.
* **Inbalance** came.
* **All valids** are accepting and **invalids** are also accepting.
* It is like **(a ^ m) * (b ^ n)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/818cde68-894a-401a-9aa4-9584cdafbdef)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/870f9e6f-c251-4979-b2ee-e894ed1fa2aa)

* It is not **NFA** as well.
* NFA -> It means that only **valids** should be **accepted**. **One invalid** cannot be **accept/accepted**.
* **Comparison** is there so **finite automata(FA)** not possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbbe44ad-35b0-4415-9242-1144e81a26c3)

* **NFA** there means **DFA** also there.
* We got to know **DFA** not possible, we will say **NFA** not possible as well.
* For every **NFA**, **DFA** is possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1622afc-8685-4e6b-929c-a03b8f02f034)

* If we remove **dead state** then this is **NFA**.
* It is only accepting **valids** and not accepting any **invalids** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2dcd4e5e-7ebd-4808-8709-4468f37fc90f)

* If we remove **dead state** then this is **NFA**.
* Every **valid** thing, it is **accepting**. **One invalid** also not accepting.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfeac0c1-d231-4ab6-a471-ef1d087cb588)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f00044c-9e27-4c01-aa79-2583e60af947)

* If **comparison** is there then **NFA** not possible.
* One invalid also cannot accept.
* This is **NFA**.
* This is **not NFA** for the given language.
* It is accepting more. It is accepting **invalid**.
* At the end of the day, it should satisfy **language**.
* **Invalid** cannot accept.
* **DFA** -> Every invalid should be **reject/rejected**.
* Why constructing **NFA**, every value should be **accepted** and **one invalid** cannot be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1f534df-2540-4bed-a920-0163e4997630)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5b09448-4eb9-4e7a-92c6-c2a15646138b)

* **NFA** -> All values should be **accepted**, **one invalid** also cannot accept. [**IMPORTANT**]
* **DFA** -> All values should be **accepted**, **all invalids** should be **rejected**. [**IMPORTANT**]
* Either **NFA** not **DFA** will **accept invalid**. **None or No one** will **accept invalid**.
* In Both(NFA and DFA) of them, **invalid** are **not allowed**.
* No machine will accept **invalid**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56782923-6f3c-4ff2-9a42-c301764c9178)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b93a833d-ba2b-44fa-b1fa-a1e1f81dbd5f)

* Comparison is there, **finite automata(FA)** fails.
* Both, **NFA and DFA** will accept **only valid**.
* No machine, neither **NFA or DFA** will **accept one invalid** also.
* Every machine will **accept valid** only. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff009035-31ad-4f33-b8fc-8304b1014e97)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c6fe4a7d-06b2-4e58-b23c-035e274bf86c)

* So, the given language is **non-regular**.
* **NFA** will talk about only **valid** thing.
* Both **NFA and DFA** having **same** power as they are accepting the same language only.
* Whatever **NFA** can do, **DFA** also can do.
* **NFA** is easier because in **NFA** we do no care about the **invalid** thing. One **invalid** we cannot accept in **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e1964c7-aacc-4445-96fa-efd21825575b)

* It is because **invalid things** are also **accepting**.
* Every valid thing **accepted** but **invalid** things also **accepted** that's why it **failed**.
* **No comparisons** in the earlier **examples**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa4a13a5-1281-4ee4-a1f7-e0369c85bb66)

* In **DFA**, every **invalid** thing goes to **rejected** physically. We will write also. We **show** in the diagram.
* In **NFA**, we do not show the **invalids** in the diagram because **by default** the **invalids** will go to **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92b221bd-676a-4b61-910f-86a9c413f726)

* No comparison.
* So, **NFA and DFA** are possible.
* So, it is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d26b2a5e-eb67-4821-8ad5-c90f3a6a2a92)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9caaa586-0274-45b5-a806-6b9e8976ac0d)

* Now, **comparison** is there.
* So, **finite automata** is not possible.
* It is a **non-regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaaffdee-397c-45f4-ad2b-12a37d58d9c1)

* Without **comparison**, we cannot say that **'m' not equals to 'n'**.
* Without **comparison**, we cannot say that both are **not equal**.
* So, **comparison** is there.
* So, **finite automata** is not possible.
* It is a **non-regular language**.
* Without comparing, we cannot say that they are **not equal**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80f59d8e-be90-43a3-b27e-8b47b1f61980)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea4ef90b-105a-4e96-a2f4-7737232abe82)

* For **equal**, we have to do **comparison**.
* For **not equal** also, we have to do **comparison**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4d6c5c2-938d-4f36-83b3-0638b6602fb8)

* Again, **comparison** is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30a27082-3787-4978-afbc-2c85da60caf4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/53241fec-4d8b-4d8c-a3ac-c0da8c077972)

* Again, **comparison** is there.
* Similar/same to the **above problem**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7616262-6bf0-49dd-a7e6-864e56a7dcf3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d895d8b9-3ab7-4ca6-a8ec-f2555532f9e3)

* **comparison** is not there.
* So, **finite automata** is possible.
* So, it is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cac6efad-96a6-4671-af1a-744b8ad7dd0b)

* **(m + n = 10)** it is a **finite** language.
* If we add, no. of **a's** and no. of **b's**, it doesn't go more than **10**. It is **exactly '10'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0ddee4b9-0ed3-4d8f-b15b-24fc7fff80df)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d8e803d-89c0-4d51-8da3-6bafde8aaab4)

* Every state will remember something.
* Finite things we can remember.
* Even though **comparisons** are there, **finite** things we can remember.
* Finite automata saying that it has finite capability of remembering as it has **finite** states.
* In the above language, there are only **11 strings** available.
* So, it is a **finite language**.
* Every **finite language** is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32d6940a-5579-4325-b092-c0d6df06ee8e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c021bf28-0a4d-46a8-8868-631c8fcc2cb0)

* [**IMPORTANT**]
* **Finite language** is a **regular language** because **finite automata** can handle any **finite language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08928fba-2f9b-4baf-ba16-99263c13c2e9)

* NFA.
* m = a
* n = b

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9281d1b-2bf2-40a1-93b0-a780598b4c35)

* NFA.
* For **DFA** just do the **dead states** for the **rejected** ones.
* **Finite automata and stack**, both can **remember**.
* **Finite automata** can remember **finite things only** as it has **finite** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/769bd7c9-dc0d-4603-b37d-d99592eae8e5)

* (m + n = 5) -> It is **finite**.
* **Not finite** -> Where numbers are not visible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/acd3644c-1b2e-41b5-bc23-8b7f5c6d49ce)

* Infinite possibilities are there.
* Looks like **finite** but it is **infinite**.
* Many  possibilities are there.
* **Comparison** is there. That's the **problem**.
* If **Comparison** is not there, then we don't care if it is **finite or infinite**.
* If we want to say some language is a **regular language** then **finite automata** should be **available**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a293cd3f-70fb-4e59-bfa6-6a9c1314326d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57c62721-9eec-4980-ad8d-37fa599de635)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/617e26a8-5a9a-441c-8c80-3446e7f2b23a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/672e7b30-cb51-434d-bf91-1c8d5449d27a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/45cf2020-3ec6-40bf-988f-3342871c0f2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1fae7f1-da13-4c21-8d70-474026946217)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb9d6dee-7e45-4b3e-b28a-6c30bdc960b3)

* **Comparison** is there but it is a **finite language**.
* So it is a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2666ef5b-8575-4cbd-a3c5-99035119bc5c)

* **Finite automata** can do **finite comparisons**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6def9f98-bf3f-48a1-ba5a-e27e8db99945)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4d9d71e-635a-4bfa-bb36-864c7d595366)

* Every state can **remember and compare** something. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab05f81c-7785-43c7-92c7-4c0d8dca1769)

* It is remembering **more things** but remembering **finite things**.
* Many **comparisons** are there and still **finite automata** is **possible** because the language is a **finite language**. [**IMPORTANT**]

* **Infinite language** and **comparison** is also there, **finite automata** cannot handle.
* So it is **not possible**.
* With the help of **finite states**, we cannot do **infinite comparisons**, it is **not possible**.
* So all are **non-regular** languages.
* **Infinite language** and **comparison** is also there, so **infinite comparisons** we have to do, which is not possible with **finite automata** as there are **finite states** only. So, **not possible**.

* **Infinite language** but **no comparisons**, **finite language** can do this. [**IMPORTANT**]

### Algorithm [**IMPORTANT**]

* Language(L) is **regular** language or not.
* FA -> Finite Automata.
* RL -> Regular Language.
* NRL -> Not Regular Language.

* **Comparison** will come in the picture when we have **more than one(1) alphabet**.
* When **comparison** is there then there is no concept of **AP or GP** series.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9206fe5c-2db0-4e31-b589-b49ecef9853f)

* [**IMPORTANT**]

1) 'L' is **finite** -> FA -> RL
2) 'L' is **infinite**:-

  * Single Alphabet:-
       * Check for **AP series** -> FA -> RL
       * If not **AP series** -> FA not possible -> NRL.
  * More than **one(1)** alphabet:-

     a) Comparison there -> FA not possible -> NRL
     b) No comparison there -> FA -> RL.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97055bf0-a597-4505-af62-9d64cc8ea2fb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f3bfbb6-6be8-4100-bb23-9c4fde645587)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76069993-44d5-483a-b79b-a7f3dc4347b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e30c3008-a682-4143-ab49-6a22ddc4140e)

* [**IMPORTANT**]
* Practice it.
* Use **common sense(CS)**.
* GP series and Finite language -> Regular language
* Comparison but Finite language -> Regular language
* Some language is **regular language** then **finite automata** should be **possible** otherwise the **language** is not a **regular language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7bfb4914-ddcf-478f-af67-f04af42edcad)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6ccc2cc-620a-44f8-a95a-3fb014f90b4a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a25e4d6f-d57d-439f-9462-b3a3bc00ec3a)

## dfa-construction-vi (10) [7th Sept 2023]

* L = {Set of all strings of a's and b's where in every string 3rd symbol from left hand side(LHS) is 'a'}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dddfb63-7fe7-4807-b1d3-bbd302a55ebd)

* Minimal string length -> 3
* **3 + 1 -> 4** states needed to start the automata.
* 3rd symbol should be **a**.
* 1st and 2nd symbol maybe **a or b**.
* In **S4** means that **3rd symbol** is already over. Afterwards anything can come, no problem.
* If 3rd symbol is **b** then there is **no hope** of reaching the **final state**.
* Because in the future we cannot change the **3rd symbol**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcad1345-1b6c-4611-84f1-c945475ab931)

* Condition is from **starting** only.
* Left hand side means **starting** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea135670-f86e-4330-9a4c-521121be6051)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62030706-ac44-4326-8de6-d137a8bdfdec)

* DFA.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1365ce4-0888-44c4-9740-2c9b642b636e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/412836e3-4511-445c-a711-583e2f51db59)

* 3rd from **LHS** is **a** -> 3 + 1= 4 states -> 4 + 1 = 5 states -> '1' is a **dead state**.
* 100th from **LHS** is **a** -> 100 + 1= 101 states -> 101 + 1 = 102 states -> '1' is a **dead state**.
* nth from **LHS** is **a** -> (n + 1) states -> (n + 1) + 1 = (n + 2) states -> '1' is a **dead state**.
* Sigma = {a,b}
* Regular Expression -> (sigma ^ 2) * a * (sigma ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ab37c5e-1cce-46b8-90b0-8b46935bf15e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9814f400-32e5-48c3-9bf2-5e9790bac961)

* L = {Set of all strings of a's and b's where in every string 2ns symbol from right hand side(RHS) is 'a'}
* Sigma = {a,b}
* Regular Expression -> (sigma ^ *) * a * (sigma ^ 1)
* Minimal String -> aa, ab
* Minimal length string -> 2
* In the **two length** also either **aa** or **ab** should come.
* Ending symbol should be either **aa** or **ab**.
* **2 + 1 -> 3** states are needed to start the automata.
* Start from **S3** state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a473e214-9f1c-4675-913a-d59bfe381570)

* From **final state(S3)** count. First symbol can be **anything** and second symbol is **a**.
* Here, **ending** matters.
* In **S3** means that we are getting **aa**, which is **ending with 'a'**.
* In **S4** means that we are getting **ab**, which is **ending with 'b'**.
* In **S2** means that **ending with 'a'** is over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09dd4c9e-9bae-4572-8306-de4d8e76e927)

* The condition is from **ending**, so **no dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc36b738-c0cd-4516-b693-eb49c39c041c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32e79ff1-6339-4adb-af71-426efd6e1075)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/09a314ac-295a-4e0b-8eb9-a148a5b493b5)

* [**IMPORTANT**]
* L = {3rd symbol from RHS is 'a'}
* Last 3-symbols target.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57f079df-ce13-4e05-9ad2-da982ed98260)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1a3cd69-db32-4ea9-befe-9d43630fa4ef)

* From ending, we have to take care of all **two length strings**.
* For **two length strings**, from **ending** possible combinations are **four(4)**. **4 states** take.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b403357b-c51f-482b-8bf0-f6d5c594af1d)

* We want **aa or ab** but **ba** came, that is not my **goal**. **Ending** should be either **aa** or **ab**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dd65795-3224-40f7-912b-8d2e2a28e910)

* Hope is there.
* **Second symbol from RHS** -> Ending **two symbols** matter, so there are **four(4)** possibilities. So **four** states are there.
* **Third symbol from RHS** -> Ending **three symbols** matter, so there are **eight(8)** possibilities. So **eight** states are there.
* Drawing diagram is difficult but **no. of states** counting is **easy**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/27e0183f-e49c-4966-8873-3643bd009a72)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/caacf41a-186c-439a-acb3-bae04d183557)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2331e504-fe38-4cfc-96c2-9078f5acd1bf)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d8a1f0b-016a-49c5-acf3-5bfd8ac7a133)

* Who is **useless** make him the **starting** state.
* Who is **usefull** make them the **final** states.
* Second symbol from **RHS** is **a**.
* from **RHS** means from **final state**. [**IMPORTANT**]
* From **final state**, **First symbol** is **a or b**, **second symbol** should be **a**. 3rd or 4th symbol is **anything**.
* **anything** means we can write **self loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cdf2e48-ea57-4eaf-874a-e2afea6a6fa2)

* NFA.
* As it is **NFA**, one invalid also we cannot **accept**.
* By default they are **rejected**.
* Valid things are **aa or ab** as the **last two symbols**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c90aa66-fd69-48ce-b060-c5ff98819497)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/016dd8e6-a14f-45cd-9e14-a012b4adb4a3)

* Minimal length -> 3
* Minimal length string -> abb, aaa, aba, aab
* **3 + 1 -> 4** states needed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3289ba68-8fa9-410c-a4ee-392ae027f88f)

* NFA.
* While constructing **NFA**, **every valid thing** we have to **accept**.
* One invalid should not be accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0f9702fb-e2aa-40a7-9bb1-322e76a610e3)

* [**IMPORTANT**]
* Every valid -> **YES**
* Every invalid -> **NO**

* From RHS, 2 symbol is 'a' for **DFA** -> 2 ^ 2 -> 4 states.
* From RHS, 2 symbol is 'a' for **NFA** -> 2 + 1 -> 3 states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e72bf4a-2f40-4c93-98fa-cadfc4138bb8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2eb45e51-8c42-4900-b603-d1cc1525cb4d)

* Starting is **S1**
* Final is **S3**.

## NFA to DFA conversion

* **S1S2** is **one state** name in **DFA**.
* Take the **Starting state** and apply the symbol **a and b**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a8deae1-473e-40ad-8b45-c2c14b3d1f54)

* After completion of **a and b** in **S1**, we got a **new state** which is **S1S2**. So, go to the **new state**.
* Don't see the **NFA** states**.
* After completion of **a and b** in **S1**, if any **new states** came then take.
* If **no new states** came then **S1S2** also didn't came.
* Stop there only.
* If any **new state** then only proceed.
* If **no new states** then stop it.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3be6c69e-555e-457b-bef3-da4df1e0877a)

* While doing the **transitions** see the **NFA**.
* From **NFA** only, **DFA** is coming.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a3a9ac6-4a6e-4a06-9508-10f188434823)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/593ebb6b-21fd-4e2d-8005-b5a17224344d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2f08351-1eba-45fc-80a7-e23afbb100ac)

* If any new states came, then only continue.
* Two new states came.
* **S3** on 'a' is **nothing** which means **leave it**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11819480-5246-42e2-b4e2-1d27f10a981d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f04ffbb4-e113-46b2-a7fe-126919f7c3c4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc3c2699-976a-4965-a7a6-fd411d1ec340)

* DFA
* In the original **NFA**, who is the **final state**?

> **S3**.

* In the equivalent **DFA**, wherever we see **S3** in the states, make them **final states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/baa07fa3-f0d5-442f-9248-140ad047aebb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a49f3032-be77-4bed-90cf-44d1d7f055c7)

* Final State added.
* No new states, that's why stopped.
* 3 states are there in the given **NFA**.
* For the **3 states**, **8** subsets are possible. That is **subset construction method**. So, **8 states** are required.
* We managed in **4 states**.
* This is better than **subset construction method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/45e55208-d954-4c22-987a-af806e1852ed)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a429a99f-360a-4c3d-b9bb-ecd0f761905f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0599446-73e8-4b19-8fd0-91689096d9cc)

* Exactly

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a08f31c2-1620-4909-8aa8-e33defa0f6d8)

* **NFA TO DFA** convertion:- [**IMPORTANT**]

1) Take NFA start state.
2) Apply all symbols from **sigma** one by one.
3) For every **new state** came continue **second step or step-2**.
4) While applying transitions see **NFA** everytime.  [**IMPORTANT**]
5) **NFA final state** wherever present in **DFA** make them as **final state**.
6) If **no new state** then **stop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3edc5e34-f678-44d9-985b-e57681a456d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b5555ff-0931-4e14-8669-731b4b3c42be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c722e7b7-7aef-4c8b-a367-f6c85d67eddc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65904662-5a56-4e63-a3bb-1bf52c13dd28)

* Convert the **NFA** into **DFA**
* HW. [Tomorrow class]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18bbbbdb-f403-4fac-979a-58e179a6cd4b)

* 3rd symbol from **left hand side(LHS)** is **a**
* Constructing **NFA**.
* Minimal length -> 3
* Minimal string -> aaa, bba, aba, baa
* **First symbol** is anything
* **Second symbol** is anything
* **Third symbol** is **a**
* **Fourth and fifth symbol** are anything.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/526af6f5-e98e-4aa4-ba24-a2b14e0c5909)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56869811-d21a-4e70-8188-0bc4b93d955f)

* **NFA**
* Trap not required in **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23eb4d86-8eab-4918-8647-abfdfd93cf89)

* 3rd symbol from left -> 3 + 1 -> 4 states
* nth symbol from left -> n + 1 -> (n + 1) states

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a321cb7-331a-4591-b0ad-e5b8737b42f2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da77980e-a091-402f-832b-c918a1767634)

* The **conversion** is from **NFA** to **DFA** and not **minimal DFA**.
* If we are lucky we will get **minimal DFA** in the **conversion**.
* No gurantee.
* If not **minimal DFA** then there is a **minimization algo** also there.
* We can apply **minimization algo** to check if the **DFA** is **minimal or not**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de3a2f0e-2f65-44b4-8a6a-1b922e68b337)

* DFA.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ee96c75-f6c0-4512-926f-b019493b8462)

* NFA

## NFA to DFA conversion

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/009bd868-f7e1-46cb-9458-e6d9a6ab36ee)

* In **NFA** going to multiple states are allowed.
* In **DFA** going to multiple states is not allowed.
* **S2** on **b** is not going anywhere, **nothing**.
* In case of **NFA**, not going anywhere is **allowed**.
* In case of **DFA**, **we have to go**. If at all not going anywhere then go to **dead state**. No other way.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d59302e-067f-483a-89c0-43463cf61e44)

* If **nothing** there then only **dead state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b5bbb1d-7fdf-43f0-8810-fefc86e1b6df)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b49b0b94-da37-4ad4-8f02-5ef81d36b988)

* Wherever **S2** make **final state** in **DFA** because **S2** is the **final state** in **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05bae09b-571b-43c0-88ea-29294a434b69)

* [**IMPORTANT**]
* NFA's set of states(Q) = {S1, S2}.
* If **Q** contains **2 states** then **2 ^ Q -> 2 ^ 2 = 4** states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/691f1fb8-2fff-4286-8f90-8a9762a7a7fc)

* For the given **NFA** when we are constructing **DFA**, in the **worst case** all of the **subsets** can come.
* This is the **worst case** that can happen.
* If **NFA** contain **2 states** then the **equivalent DFA** contain **2 ^ 2 -> 4** states.
* This is the **maximum** thing that can happen.
* In the **Worst case**, all of the **subsets** came in **DFA** construction. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3f90e176-fb50-4340-b47b-db3607e0677f)

* If **NFA** contains **n-states** then equivalent **DFA** contains **2 ^ n** states. This is the **maximum**. More than this is **not possible**. [**IMPORTAN**]
* Sometimes **less** also may come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57cdc401-6595-40a0-97b4-8245caf0eb29)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08880fd2-3819-4d5a-b54a-9084c6955f6f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c5ac59c-35cf-4a96-b243-2244ba73e06e)

* Best case. [Not required]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c441b5d-040a-451c-bbaa-b069e72fe927)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9815dbae-7609-498a-9dea-c1fb42f9fc2a)

## dfa-construction-vii (11) [8th Sept 2023]

### HW

* In **NFA to DFA** conversion, **DFA** is gurantee. It is not guranteed that **minimal DFA** will come.
* NFA contains **4 states** so **max no. of states** in **equivalent DFA** will be **2 ^ 4 = 16** states, in the **worst case**.
* **Worst case**, all **subsets** will come.
* If we are **lucky** then only **one state** will come.
* If **NFA** contains **n** states then the **equivalent DFA** contains, **min. of one(1) state** and **max. of (2 ^ n) states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6dae6231-eac2-41b0-b57a-5a578e7419eb)

* 1 <= (DFA states) <= 2 ^ n.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b70e02ea-b539-46c7-b4d5-fb3de5b4c139)

* If we are lucky, we will get **8 states** which we got in the **minimal DFA**.
* If we are unlucky then we will get **2 ^ 4 = 16 states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f0e179a-4d4f-4371-b520-ce151b750bca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c79cf767-edf3-45ee-bede-cf7373d00c63)

* NFA to DFA construction.
* We got **4 final states**.
* **Conversion algorithms** are for understanding.
* Not for GATE exam.
* Because we are anyways not getting guranteed **minimal DFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/61b5c434-5fba-4931-b416-3a2da44c4df0)

* We luckly got **minimal DFA**.
* We apply **minimization algo** on a **DFA** with **n** states and the **equivalent DFA** has **less than or equal to 'n'** states.
* **Equivalent DFA** <= **n**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/510792fe-d6cd-4f40-8f2d-90de64289a5f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3179acc-5ce0-4f65-ad00-6f925d9c22de)

* L = {Set of all strings of a's and b's where in every string no. of a's divisible by 4}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92ef3514-2406-44da-b94f-593f3535a48e)

* We care about **only a's**.
* We don't care about the length of the string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2cf41793-0790-4e24-bd64-798baf723dc0)

* If it was the **length of the string divisible by '4'**.
* Then it would have been an **AP series**.
* Common differenece -> 4
* With **4** one cycle is also possible.
* There is a **4-length** cycle.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac6f808a-b20a-4e5e-af07-4dbd52f9642f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c824c207-cb8d-4bbd-9900-97e4b0527885)

* No. of a's should be divisible by **4**.
* Our goal is **only a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8290b4df-5060-4d28-b1d4-d416f2c22a0e)

* **b's** is not our problem.
* They may come or may not come.
* **Changing state** means compulsory **b** should come.
* **Loops** means it may or may not come. It is no gurantee.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f937e80d-d016-4899-b596-e82eb7e38490)

* **b's** may come or may not come.
* They may come at any time.
* Just count **a's only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/27cbdea6-227a-4c85-a72c-8665836ddd12)

* When we divide a number by **4** then we will get **0,1,2 and 3** as the **remainders**.
* For **every remainder** there is **one state**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ddf39da-dbba-4389-bbed-e297d6339e92)

* Whichever matters, give that in the **transition line**.
* When **only a's** matter, do like this.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a48d5fa-40b2-4210-87c6-4384fc2a5dc9)

* When **length** matters, do like this.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b13a6146-205b-4ee1-96be-286a602fd4b1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d00f91f4-adfb-4869-aa6d-bc8ff4f55d33)

* L = { All strings of a's and b's where in every string no. of a's are divisible by 2 and no. of b's divisible by 2}
* Try solving **individually**.
* **AND** operator.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fca73671-6100-4204-90f5-639ad733ab25)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f7bfd47-d019-4f69-b830-7adcf959c1da)

* In **P1** our goal is **no. of a's** and not **b's**. That's why **self loop** for **b's**.
* As **divisible by 2**, so we get **0 and 1** as the **remainders**, so only **two states** are required for the **two remainders**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75066ce9-5525-4db6-8d74-70435a1d9494)

* In **P1** our goal is **no. of b's** and not **a's**. That's why **self loop** for **a's**.
* As **divisible by 3**, so we get **0, 1 and 2** as the **remainders**, so only **three states** are required for the **three remainders**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/888e92d8-1138-48f3-aef7-1d57454d3d18)

* Satisfying **P1** diagram means that at the end of the string, we have to come to **S1**.
* Satisfying **P2** diagram means that at the end of the string, we have to come to **S3**.
* Two sets are there, one set has **two elements** and the other set has **three elements**. If we do **cartesian product**, we will get **2 * 3 -> 6** elements.
* Just do **cartesian product** of states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9a66c69b-2f81-4bae-af0d-5c55320a0ba5)

* Where both **initial states** from the **previous diagrams(P1 and P2)** are there make that the **initial state** of the final diagram.
* S13 -> S1 * S3
* S1 on 'a' -> S2
* S3 on 'a' S3
* S13 -> S2 * S3 -> S23.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/007eee50-7bb5-48bc-a061-be702b6cc2ad)

* Yes. **Common initial State**.
* Using the **existing states** and creating **new states**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1fcb1c50-84d8-47f3-84e7-3dcc86cdaf74)

* Satisfying both the **final states** from the previous diagrams(P1 and P2) and they are coming **together/both** in a state in the combined diagram is the **final state** of the **new diagram**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7feebfd8-fcb9-4e0b-a28c-7c2c581f86de)

* AND -> S13 -> S1 and S3
* OR -> S13 -> Either satisfying first one or satisfying the second one -> Either one is **final state** then that state is a **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e378386-1bc8-4f8e-97c3-8a9c95aa98a8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/48930288-bdbb-4acc-8aa2-9694cd91029a)

* For **OR** operator.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/deb229cc-c890-4a45-9374-3e0c4f95ffb4)

* **Minus(-)** means that **first one** should **satisfy** but not the **second one**.
* **First final state** should be there but not the **second final state**.
* Satisfy here means **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a60149ba-2a7a-4d13-9cc3-5849abdc1cde)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b89b7392-1c5e-4d7d-8237-bcd9228a5ecf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8992c77e-feb1-49b3-895f-813d12c624dd)

* Final States combinations [**IMPORTANT**]
* If it is **AND** operator then make **S13** as the **final state**.
* If it is **OR** operator then make **S13, S14, S15, S23** as the **final state**.
* If it is **minus(-)** operator then make **S14, S15** as the **final states**.
* The **operators** are present in the question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c030d4ea-380f-47c8-a846-9007faac5f6c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fdec66f2-63d7-43c9-aacb-5f9f63aee99c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ff7c1b3-df46-40ff-87b8-513a1d77bb08)

* **a's and b's** can come at any place.
* Anyone can start
* We have to check how many **a's and b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb145211-0002-45bb-9ecd-325eacf82238)

* L = {All strings of a's and b's where every string contains no. of a's divisible by 4 and no. of b's divisible by 2}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c919b192-12ef-4f62-ba9f-2ad2c2c80e39)

* Conditions are **different**.
* No. of states for a's is **4**
* No. of states for b's is **2**.
* By doing **cartesian product** of the two we got **2 * 4 = 8** states.
* We cannot do any **minimization**.
* **Different** conditions means we cannot do **minimization**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaf8a388-c343-4a29-af83-e6c636ea268a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40f087e4-01f3-4721-b5ac-988c5e4ff79e)

* Simply find **individually** and multiply. [**IMPORTANT**]
* **Same** for all of the **three operators**. Only the **final states** are **different/change**, rest everything is **same**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e94e1be1-990b-477c-95df-fe903a13771f)

* **P1** is on **a's**.
* **P2** is on **b's**.
* Whatever states we get by doing **Cartesian product** that is the **no. of states**, we cannot do any **minimization**.
* As **P1** is on **a's** and **P2** is on **b's**, we cannot do any **minimization** also. This is the **only way**.
* Condition are on **different people**, we cannot do any **minimization**.

* If the condition are on **same people** or the conditions are **same** then we can do **minimization** or **minimization** is possible. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be762d05-055c-46c8-8a05-170a6ece320d)

* L = {Set of all string of a's and b's where no. of a's divisible by 4 **or** no. of a's divisible by 2}
* **4 * 2 -> 8** states is **correct** but it may not be **minimum**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2930da1-4305-4b53-84ca-9e1b86162469)

* It is **AP series** and **common difference** is **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfeda8f2-8ee4-4cac-bfa5-1625bb0942ca)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84dd6bed-41ff-486c-93e0-2695cacdbf98)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a6666de-b77d-43ae-9a24-e58c96ab49d4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b8990bb6-28c9-4ed3-9316-dd14a18c14a8)

* It is an **AP series** with **common difference** of **4**.
* If the operator was **AND** operator.
* Worst case answer is **8**
* The best answer is **4**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/47f917f2-df4a-4873-b915-adb782b29285)

* We are unable to find out any series.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a50beed6-fb6d-4ccf-abf0-772b614342b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9997cf84-009a-4d95-8d26-dae10fec7531)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87899fd8-2c2a-436b-a72f-cfa37a9f6f02)

* How do we know it is the worst case?

> Continue the series until the **max. no. of states** and after that if we are unable to find out the **common difference** then **max. no. of states**, **6** here is the **answer**.

* By default answer is **6**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0166fb39-c8d5-4d66-96c3-6bc2b82bfedc)

* **Same** thing repeating that why we have kept a **loop**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1ceb0052-6499-40aa-9abe-0d6f8d14c43e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/200183d4-f087-4c3e-9052-ec8ea3aa1665)

* We don't care about **b's** that's why we keeping **self-loop** of **b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0849bf40-44f0-425e-8faf-05d1f7d98042)

* We couldn't find any **series/patterns** in the numbers, that's why we have to use the **max. no. of states** possible that is **21** states.
* OR operator.
* **3 * 7 -> 21** states is the **max. no. of states** possible. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5db4f6f3-708e-4808-aab6-991d8ee33184)

* AP series came.
* Common difference is **21**.
* We tried to **decrease** the no. of states from **21** but we are unable to.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11f4de15-1cb2-4495-b88e-edec475c89c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/20308f76-85f8-49cc-acbb-a1506ea9f5e1)

* So states are **21** only.
* **AND, OR** or any operator, it doesn't matter. Everytime **multiply** then **conditions** on the **different symbol**.
* If **conditions** are **different** then blindly **multiply**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75ffa6f7-b404-4b7d-b5d5-af371cfaf25b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3ee235c-a309-46f9-871d-ff9e0d618b0e)

* [**IMPORTANT**]
* If the **symbols(a's)** are **same** then there is a **difference** between the results of the **operators**.
* AND -> 4 states
* OR -> 2 states.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df8446f3-a26c-4471-98cb-3b7e09e8aab7)

* We are getting **same no. of states** which is **6** for both **AND, OR** operators even though the **symbols(a's)** are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/211812cd-eb16-4a9c-a14a-e063da0f417e)

* [**IMPORTANT**]

* How to solve bigger problems?

1) Solve individually first
2) Blindly multiply which is the **upper bound**.
3) **Upper bound** is the only answer when we have **different symbols**. **Operators** do not matter.
4) Game will start with **same symbol**. **Operators** matter now.

* Product automata will give **boundary** which is the **upper bound**.

## doubt-clearing-session (12) [8th Sept 2023]

* L = {Set of all strings of 0's and 1's where each string contain atmost one pair of '11' or atmost one pair of '00'}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2319b886-0174-4455-9c18-e85579b04f45)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0989bc65-e930-445c-a7e0-f0b38e84c097)

* Yes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/832cfd0b-ae5f-4c9d-90e2-d859b2426974)

* Yes, because of **OR** operator.
* In **OR**, either one is ok, both are also ok. Both are **not satisfied** then **OR** is not ok.
* In **Exclusive OR**, either one is satisfied then ok but **both** is not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/921ce2f1-fa30-4422-82ce-dabff5ff33f4)

* 1100 -> Each pair of 11 or 00 are there. OK. Both are there.
* 000 -> Two pairs of '00' are there. So not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50937f74-bc93-465e-92a9-5ed6738da0ec)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec604122-f1ea-4f02-829f-8774fcca73d0)

* AND -> Both are allowed.
* **OR** is giving some ambiguity.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1dcfedc-c830-44dc-8987-cee0b0d08e95)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13d36ef5-f31e-437e-8e3a-260790946f46)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29a7087d-c29a-41bc-be32-a90302c1503a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f2c2ff9-50f2-4b82-a17e-145294df22df)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f8db5ef6-8879-48fb-ad99-b2bc69262c41)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/059039c2-c23f-4a09-89a2-50f728c636ce)

* Not only we have to remember **00 or 11**, we have to remember **0011**.
* **AND** operator -> Both should satisfy.
* Consecutive or Non-consecutive. Doesn't matter. It will work for **both**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d584fdd-c8a1-4c0e-a95f-3ab2df0b1464)

* In this diagram, we were only remembering **00 or 11** only.
* Let's remember **0011 or 1100**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/651711db-b117-497b-9167-0a8afec71cae)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99729181-9b64-4e8f-bae6-0b20165c4d4e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bff5207d-a14a-4b39-8004-66563ce7226b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08ef6f15-f903-4421-bf52-2df9ada2a20b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99a4363b-a058-4102-b7c0-099201fe15f0)

* We have **10** states.
* What is the above DFA doing? [Example questions]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b306cc5e-8724-44cf-9b41-0cb07770f389)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1db9a5fd-4a1b-43de-8079-651700d0844b)

* Another Type of question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f7f2629-740a-4bae-9a49-6e78b904f1bb)

* How many DFA's possible with 2-states(X and y) where 'x' is initial state over the alphabet {0,1}?

> All possible **DFA** we have to take care.

* We have **4 choses** for the **final state**, **x and y** both are final, **x** is final, **y** is final, **no one** is final.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e0f3700c-93a8-4f2e-ae43-0503ee894636)

* Is **No one** is final possible?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7728ff86-b389-4d34-9f0e-6a6f2c34987c)

* This is a finite automata.
* As there is **no final state**, so nothing to **accept** or **no one** is **accepted**.
* L = Phi
* L = {} -> Empty Language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1607b68b-434e-46bd-beec-ae0d2a44fc83)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/156ae588-7fc0-4d2e-ad11-e57a9046a357)

* Only **epsilon** is **accepted**.
* Everyone going outside, no one coming back to **final state**.
* The language accepted by the automata is **not empty** but the string is **empty**.
* The language accepting **empty string** but the language is not empty.
* Language not empty but accepted string is **epsilon** which is a **empty string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ebfc634-faaf-4e37-8a50-e95f3a4b8edf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b91f3fc7-e9ca-4944-bbb7-0160ef5252ca)

* DFA -> We can only go to **x or y**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d197e2ad-9bec-4812-b36e-be75f2321ff0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7250ced8-b875-4f08-bdf7-c04fd3b78656)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/67ee12a0-9315-4f85-acda-c9c7517e5093)

* In total **64** DFAs.
* In all of the **64** DFAs, who is **initial**?

> **No discussion** of **initial** came because we have **only one choice(x)**.

* If only one choice, what discussion will come.
* **Initial state** is **fixed** so only **one choice**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c301e40-be68-4ff9-a080-cfdeb92e4de1)

* Everywhere **2 choices**.
* Without considering **final states**, we have **2 ^ 4 = 16** DFAs.
* **X** on **0,1** we have **4 choices**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bdf9211f-aca0-4dee-bfad-389675ee3a3b)

* **Y** on **0,1** we have **4 choices**.
* **X and Y** on **0,1** we have **4 * 4 = 16 choices**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cca5418f-003b-4f9b-a5b6-8c095318f26d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e4d5bae-10ed-4a6c-ae93-cbe12792396f)

* In all of them **x** is the **initial state**.
* **X** on **0,1** we have **4 ways**.
* **Y** on **0,1** we have **4 ways**.
* **X and Y** on **0,1** we have **4 * 4 = 16 possibilities**.
* One work is done **m-ways** and another work is done **n-ways**, both can be done at a time in **m * n** ways. [**IMPORTANT**]
* **X** on **0,1** we have **4 ways**. **Y** on **0,1** we have **4 ways**. Both(X and Y) can be done at a time in **4 * 4 -> 16** ways.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0bcdf4a1-e3a9-41cb-91a7-dfecadc8f262)

* **X** is changing but **Y** is not changing.
* **Y** on **0,1** we have **4 ways**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ebd544d5-926f-4470-9f14-2461bbf2d00b)

* Everyone is a **DFA**.
* We have **16** diagrams logically.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65a6a9f3-e0b0-45b3-870f-7ac4c79ec5a8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6ed4018-b8e4-42c1-8019-8b0e1c82b73e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e8e2a92-c330-4814-a0a1-dce8e75b3db1)

* We want **DFAs** only.
* In all of the **DFAs**, **x** is the **initial state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3843db23-b812-4769-8e75-b1298737e464)

* We have **16 DFAs**.
* Take all of the **16 DFAs** and in all of the **DFAs**, make all of the states as **final**.
* **Zero(0)** states as **final state** will accept **empty languages**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1305d47-a10c-48f2-a08b-d2e3dba52bd3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1bfdf80-bc98-421a-b822-4f129f8bbb9d)

* If **initial state** is not mentioned.
* **X** maybe **intial** so **64 DFA** and **Y** maybe **intial** so **64 DFA**. So in **total**, **64 + 64 = 128** DFAs.
* We cannot take **two states** as **initial**.
* If **no state** as **initial state** then we will not know from where to start.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ffb8bde-3a80-4512-a08f-427a9cb5b3c6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8cb1888c-c374-47cc-bea2-0ff82a89f882)

* Without considering **final states**, we have **2 ^ 4 = 16** DFAs.
* By considering **final states**, we have **2 ^ 4 * 2 ^ 2 -> 2 ^ 6 -> 64** DFAs.
* Go like this, if we want **answers**.

* In the question, if it was added that, **and only one state is final** then:-
* We want only **32** DFAs.
* We only want one state as **final**, either **x** or **y**.

* In the question, if it was added that, **and every state has final** then:-
* We want only **16** DFAs.
* We only want where both the states are final.

* In the question, if it was added that, **and no final state** then:-
* We want only **16** DFAs.
* We only want where zero(0) states are final.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/100f1b5b-263b-4602-876f-12e176dc4fea)

* In the question, if it was added that, **and atleast one final** then:-
* We want only **16 + 32 -> 48** DFAs.
* We only want where **2 states** are final and we want where **either one of the states** are final.
* Atleast one final state -> Atleast one state ok and both are also ok -> One final state is ok, two final states is also ok.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9e7fa1b-6f83-4455-9f00-696a3280b5bd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4a73c20-84fe-443e-aafc-9be84172f95c)

* In the question, if it was added that, **and atmost one final** then:-
* We want only **16 + 32 -> 48** DFAs.
* We only want where **zero(0) states or either of the states** as final.
* Either one state or zero state.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a461b54b-4434-4b79-b82f-347fde229847)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93e387aa-73bc-4f43-90d9-1c5dd3817916)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fde4ca2-4a9f-49e2-a27e-dd8202a309e7)

* **X** is **initial**.
* In every diagram **X** is **initial**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5e47634-dd22-4ae9-bc48-3ee27f2fd974)

* How **64** came?

> **X** on **0,1** we have **4 ways**.

> **Y** on **0,1** we have **4 ways**.

* So, **4 * 4 -> 16 ways**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2850c2b8-a91a-4209-8d9a-74d64e8498ec)

* Totally we have **64 DFAs**.


![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/547340a4-5269-4a9c-af6e-6bc1fa7869b0)

* How many possible DFA's are there with 3-states x,y and z where 'x' is initial and sigma = {0, 1}
* From **final** state we got **8** possibilities. From **000 to 111**.
* **000** -> No one is final
* **111** -> All are final.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3caea32-8bf4-4de7-99a5-5a82a8f12868)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f134b849-8de7-4a93-af68-1700f2269c4d)

* [**IMPORTANT**]
* We have **5832** DFAs.
* **DFAs** without final is **3 ^ 6**.
* **DFAs** with all final is **3 ^ 6**.
* **DFAs** with one state as final is **3 * (3 ^ 6) -> 3 * 7**.

## regular-expression-i (13) [9th Sept 2023]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38ed71a8-bc74-4101-82a9-9623ccb65af6)

* How many DFA's possible with 2-states(x,y) where **x** is starting state, sigma= {0,1}.
* Total DFAs is **64**.
* No final state is **16**
* All final state is **16**.
* Any final state is **16 + 32 -> 48**. Which is **Atleast one final state**.
* **Atmost one final state** -> **16 + 32 -> 48** -> Maximum one final state.
* Exactly one final is **32**. Maybe **x** or maybe **y**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3382b195-a479-4526-b8ff-c6f1465ef940)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f066d7a-131c-4ff6-8c32-345b32d4231c)

* How many DFA's possible with 2-states(x,y) where **x** is starting state, sigma= {0,1} and accepts empty language.
* On **X**, **0,1** we have **4 ways**.
* Both can go to *X**, both to **Y**, **0** to **X** and **1** to **Y** and **0** to **Y** and **1** to **X**.
* On **Y**, **0,1** we have **4 ways**.
* For **X and Y**, we have **4 * 4 -> 16** ways.
* Totally we have **16** DFAs without thinking about **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2de8402e-2f03-46b6-b7a0-107b16708ec2)

* **16 DFAs** without final state.
* As **no final state**, they will accept only **phi**. They will **accept** nothing.
* **16 DFAs** without final state and they are accepting **empty languages**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f214599e-f53f-47b7-b996-ec591093ba12)

* **Y** is **final**.
* **Y** is ready to accept anything but we have to start from **start state(X)**.
* **X** is saying, I don't go outside.
* Like this, we will have **4 more** DFAs.
* Even though **final state** still it will accept **empty language** if we cannot reach **final state** because from the **initial state**, we cannot reach the **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70faaf83-61b3-4384-b6de-db45995b9997)

* **4 DFAs** with **Y** as the **final state**, accepting **empty language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4b50706-902b-4cfa-aa7f-1afbdcf805b5)

* We don't want to accept anything.
* When we make **X** as **final** then it cannot accept empty language. It is accepting **epsilon** which we don't want. We want to accept empty language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74a0af88-fd10-4b35-857d-9006d8bde7d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/738c44dc-394e-46f0-872e-9f23ed7c49d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1424b06-f5eb-471a-988c-01be2b5b950c)

* **4 diagrams**.
* **Final state** is there but from **starting state** we cannot reach **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e314b526-9d04-485b-ba79-8589ce8078a1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cf012ae-4ccf-4816-b0f4-d410228295b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb1d70c6-71a0-4d13-afad-3103ef8bde53)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d4f547a-af1a-4100-9800-750e1de33e9c)

* We have **16 DFAs** when **X and Y** both are **final**.
* There is **no chance** of accepting an **empty language**.
* We will get **epsilon** atleast**.
* In these **16 DFAs** we are addressing every person and we are **accepting** every person as well.
* **X** and **Y** both are **final**. We go anywhere that is **final** only.
* They are accepting **everything**.
* They are **(sigma ^ * )**.
* They are called as **universal or complete language**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f554b595-c95d-40e0-b204-4da24e08e779)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c888f82-f3c3-45f1-8a06-1885ac58ef6f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8ae40b9-72ac-4d73-8844-e35c630e10c9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1115375d-ba64-47e2-94e3-6680e3a77eb7)

* Every string is **YES** only.
* In the given **DFA(above)**, if every state is **final state** then it will **accept** everything?

> **It is correct**.

* As there is **no non-final** states, so everything is **YES**. There is no **NOs**. [**IMPORTANT**]
* **(sigma ^ * )** means **all strings** -> Universal or complete language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/382523aa-00ec-4c5f-8383-9e6544572d56)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7382d50-df96-4a7e-b1bf-1523b2c2b3ac)

* In the given **DFA**, if every state is **final state** then it will **accept** (sigma ^ * )?

> **Correct**.

* In the given **NFA**, if every state is **final state** then it will **accept** everything?

> **We cannot say**. We cannot give any gurantee. For somethings there is **no response**. For some strings there is **no response** in the machine.

* It is **maybe**.
* If **maybe** not there then choose **no** as one time fail is **fail only**.
* Every **DFA** is **NFA**.
* Accepting everything is **DFA**.
* **NFA** where everything is **final**, sometimes it will **accept** everything. **YES**. When the **NFA** is a **DFA**.
* There exists an **NFA** where **every state** is **final** and **accepting everything**, **right or wrong**?

> **True**.

* There exists an **NFA**.
* Question is not saying **every NFA**. It is saying **one NFA**.
* If **every NFA** then it is **False**.

* Every **NFA** where **all states** are **final** and **accepting everything**, **right or wrong**?

> We cannot given gurantee. **False**.

* There exists one NFA -> **True**.

* There are some **NFAs** where **every state** is **final** but not **accepting everything**, **right or wrong**?

> **True**.

* There are some **NFAs** where **every state** is **final** and **accepting everything**, **right or wrong**?

> **True**.

* The **NFA** maybe **DFA** who knows.
* A special type of **NFA** is called as **DFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/00232048-2b33-430c-948a-1cfaeedbdd60)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4738cdc6-1990-47d0-a4c1-dac477dcde74)

* They are accepting everything. No way.
* They are saying **YES** to everything.

* We have **16** more DFAs where the **X** is the **final state.
* As **X** is already the **initial state** and we are making **X** as the **final state**.
* So we will not get **empty languages** as we are accepting **epsilon** as the min. string here.
* We cannot get any diagram where among the 16 DFAs they accept **empty language**. They **min accept epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9a1efc4-10ab-42e9-a0b3-e73d3c909e61)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5ae3dff-6a4e-4c04-90e5-f31f819314ea)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c03e021-faf6-4978-9b3b-171f5195d9ec)

* **16 DFAs** where **Y** as the **final state**, **Y** will accept something. Block at **X** itself.
* **16 DFAs** where **Y** as the **final state**, we want to **accept empty language**. **X** will not come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/085e1c95-48b0-413b-9f59-4f2bcd6ffb17)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc15faad-860e-4fe3-bb9e-e36554ab4f0e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ba97f64-fc73-42b5-b8f0-4d49b67f3520)

* So we have **16 + 4 -> 20 states**, where **empty languages** are **accepted**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c9a5ef8-23c3-4b51-b74d-4d1bbdfdb720)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b7ff0dd1-2769-4919-aafc-5e1dade8fd65)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10a5724a-ffcc-4dca-be71-fb696f0b90ef)

* How many DFA's possible with 2-states(X, Y) where **X** is initial, sigma = {0, 1} and accepts everything(sigma ^ * )?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82a515a7-39d0-4c6a-8651-cff1fe0274a2)

* In the **16 DFAs** where **Y** is the **final state** means that **X** is not the **final state**, so **epsilon** is got. We can't accept everything.
* So the **16 DFAs** where **Y** is the **final state** are **gone**.
* For the **16 DFAs** where there is **no final states**, they are **not accepting anything anyways**. So they are **gone** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0cb5e75e-4424-4cec-9124-d6db5b97aa12)

* **16 DFAs** are there where **X** is the **final state**. So **min. epsilon** is **accepted**.
* **X** contains **4 choices** and **Y** contains **4 choices** as well.
* So, **4 * 4 -> 16 choices**.
* **X** is **initial as well as final** state.
* We want to accept **everything**.
* So, we will put **self loop** on **X** and **X** will not go **outside**.
* If **X** goes **outside** then something is **rejected**.
* Actually on **X**, **0,1** we have **4 ways**
* Now, **one way** only as **X** is not going **outside**.
* Now on **X**, **0,1** we have **1 way**
* Now on **Y**, **0,1** we have **4 ways**
* So, **1 * 4 -> 4** more ways.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5243ccb6-963b-45d5-a576-e625936df688)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0885110-ed95-4a10-8aec-30900c904aa9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d63b05ec-192d-45b1-8bbe-32f636f085de)

* From the **16 DAFs** where **X** is the **final state**, we have **4 more DFAs** which **accept everything**.
* **X** is **initial as well as final** state also, so **epsilon** but we want to **accept everything**.
* So on **X** only keep the **self loop**.
* **X** only we can select **himself(X)**. **X** don't go **outside**.
* So **16 + 4 -> 20** DFAs.
* The no. of DFAs where **everything** is **accepted** is **20** DFAs.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98a24b5e-6f04-470f-abfb-fb2a63fb6d8f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80c3b5c4-aa82-470b-b511-dc3afad22457)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a1d5fa9-30bc-4846-9a54-45c8a5999ce0)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5131cc4c-886a-4a20-bbef-e88933ee8009)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a23e35c8-9b4a-43f5-a2f6-d50f97927958)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/46b5861a-012f-49fd-9255-eb9919414fe5)

* **20 DFAs** are there we are **accepting nothing** or accepting **empty languages**.
* **Complement** these **20 DFAs** by interchanging the **final to non-final state** and the **non-final to final state** and we will get **DFAs** which will **accept everything**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/adf5fb3a-914f-4989-af76-64ddb94f6e11)

* Yes ofcourse that's the reason.
* **Complementation** of **nothing** is **everything**.
* (sigma ^ *) - phi -> (sigma ^ *)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/447abbad-9556-4465-9099-5a858a0ca5ee)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6684c852-b011-4846-92b1-0a10167d0d98)

* Give Regular expression(RE)
* L = {All strings of a's and b's where starting and ending symbols same}
* Two possibilities are there.
* One is **a** at the starting and ending.
* One is **b** at the starting and ending.
* (a + b) ^ * -> Everything is possible. It may come or may not come.
* Whatever we say should come from either **first regular expression** or from **second regular expression**.
* Because of the above reason, we are using **plus(+) operator**.
* **Plur or OR operator** means we are going to take **either one**.
* (a + b) means **two people** are there either **a** or **b**.
* (a . b) means **one person**. We cannot take **either one**. It is **one string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2008e295-16b5-44e3-a77d-a7034efe8b0c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad3d6bf1-1537-4b44-8f07-1fed0b3e6f1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/33e432ba-6399-4a2c-a378-a279eb8b28a7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63404014-7997-493e-938e-535abc3ff999)

* Dot, OR operator [**IMPORTANT**]
* **a or b** or **b or a**. Both are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c04f0ea9-3148-4cec-bba2-811198632290)

* It is **first one or second one**.
* Some string will come from the **first one** and some strings will come from the **second one**.
* There are **two models**.
* Take either **first or second**. Don't take **common**.
* We cannot take **both**. That's the meaning of **OR** operator.
* We cannot get **1 lakh a's and 1 lakh b's**.
* We can get only **1 lakh a's**.
* We can get only **1 lakh b's**.
* **OR** operator -> Either first or second, we cannot take **both**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6edac5f3-49c3-4ad8-b1c6-55dc63f6179d)

* **Concatenation** means **compulsory**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff91895c-200c-42fa-81ad-2ee36e30134b)

* The strings should come from the **first or the second or the third or fourth of fifth** regular expression.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3072cee5-d17f-4c20-b8c4-87d9b97a8cf9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/52027c45-e574-445f-8dab-6546a7ab00ee)

* **Epsilon** is included because when we have only **Epsilon** then the **starting and ending** symbol are **same**.
* Regular expression having these operators -> Star(*) or kleen closure, Plus(+) or Union, Dot(.) or concatenation [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a1b21fb-fcdd-4a9b-8bd5-d71ea71c42d3)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/703e66bf-b82d-47b8-acd4-7a727db64a7b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fcdd3a9-4a59-4cf7-89f9-8d2030481399)

* Given RE, L = {Set of all strings of a's and b's where each string contain 'abb' as substring}
* Minimal String -> abb
* **abb** can be anywhere in the string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e38f94e8-1b41-402a-b978-3221cec366f5)

* Starts with **abb** and also no string starts with **b**.
* They are not mentioned in the question.
* So wrong regular expression.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44e5b178-fa52-494f-a1ec-b608268fa872)

* We are saying that **ending with 'abb'**.
* Huge blunder.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f08a0c43-912c-4016-8b02-12fadf6703e6)

* According to the language, **abb** should come as **substring**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e691210f-4670-44d5-9002-7ee63ca7b3a4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19d39add-635e-47d3-ac44-d2a511572749)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5be71d2-cda9-4e43-bf1e-f804f023b8c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eddc38d8-20b0-4b8a-8e26-86be93b6c9b6)

* We want **abb**.
* **abb** should be there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f9b72f4-7bea-4898-82db-6789ed493d76)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc4e0ec6-9840-48a0-b60d-537292cd8a6a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3a2b9ba-ea64-4f64-b805-06817cbce9d2)

* Possible options to the questions.
* Option **2** is **correct**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39ae39cf-95e5-4bfb-b2ad-159cbab90867)

* Give Regular expression(GRE)
* L = {Set of all min. 3-length strings over 0,1}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be187d94-9ff1-47c1-8c58-50e274788ecf)

* Here we want **min. 3-length string**.
* After **3-length** anything can come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f77fc1e4-4a05-4db6-8bac-2dd9a4d72377)

* All of the **three** are **correct** but **first two** are **better** answers.
* In the **Last one**, we are wasting **star(*)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e2531fd-580b-4b01-9d71-08608e9059c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4df5e34-da95-4e10-9413-627f6af8a006)

* Non-sense MSQ(Multiple Select Question).
* In this, **starting symbol doesn't matter** and **ending symbol** doesn't matter.
* Only **length** matters. Exactly.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b967105c-f183-4781-bb1b-b8e47c35da13)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d4dbdf93-447d-48a0-b303-8e60e5c385ac)

* All are **correct**.
* We have to select **all** of them.
* **One** we cannot say.

## regular-expression-ii(14) [9th Sept 2023]

* Atmost 3-length string

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e84deca-2475-4123-97a9-e5c59d9aec40)

* Atmost 3 means **max is 3**.
* Atmost 3-length string means we can have **0, 1, 2 and 3** length string.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbcddab8-c787-4099-9bd7-d079f040133f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b7ab952-a5d3-4360-8361-31a9c414f283)

* Minimal regular expression(RE) is **not unuqie**.
* Minimal DFA is **unique**.
* regular expression(RE) will talk about **valid** things only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88cf9785-0012-4a96-ba8e-ef5558b5cb34)

* Exactly 3-length string
* (0 + 1) ^ 3 -> We are going inside exactly 3-times.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd0d8a7b-93a8-415d-a97c-be25198b83fd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f3480e3-01dd-498f-99f3-99c9b7a63035)

* L = {Set of all even length strings over the alphaber {0,1}}.
* **Epsilon** is **zero(0)** length.
* (0 + 1) ^ 2 -> Two length string is coming.
* ((0 + 1) ^ 2) * -> Everytime, **two length** will come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d12ae6d5-d161-41a9-89ce-5ac5fdd96b3b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa8ee8d5-458a-4313-a7a6-eb67eb189069)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9ff0143-b3d7-4935-a51f-158a7c75bc7d)

* Odd length
* Even length + 1 -> Odd length
* ((((0 + 1) ^ 2) * ) * (0 + 1))

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b501d563-48b5-409a-892b-bb6c12ba1e3e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a28befdd-a289-4e56-892a-f2a8a698b948)

* [**IMPORTANT**]

L = {Give a regular expression of all a's and b's where the length of every string is **divisible by 5**}.
* Length of the string is divisible by 5.
* ((a + b) ^ 5) *

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/14034eee-c2fe-4bf7-bc15-d70c1f3c50b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ccf9d7a3-f47b-4594-89c6-f64835850c9f)

* Even means that the number is **divisible by 2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d5eb8e8-f730-495b-a4f5-6a52e63a6321) 

* L = {Set of all string of 0's and 1's where in every string 2-consequtive 1's are not allowed}.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/948093d3-191a-424f-9089-3d366442c792)

* Because of whole star(*), we can go inside **any no. of times**.
* ((0 + 10) ^ *) * (1 + E).
* E -> Epsilon.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e89172b5-ecb6-4de3-aea2-bb6f7e6c18b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/639219be-c163-4999-af77-34768302caa9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cdf51bc2-5fd5-4d16-9b0c-6747932d03dc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff28ce25-3e20-4117-a5d7-9115c446e4f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1f5e7b6-91cc-48ac-9a7c-c0bcc7982393)

* [**IMPORTANT**]
* L = {Set of all strings of all 0's and 1's where in every string consequtive 0's and 1's are not allowed}.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf3fb83a-d519-4e64-9c67-e433712ac913)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b6103ac-dd55-4179-b62a-f02173ae6822)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30f31b68-faa1-41d2-8490-8b3920393bcd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f16986fe-ac64-4bcf-8551-cb75bc8e1528)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de0fb0e6-8a42-44da-9889-d706a2984e64)

* [(0 + E) * (10) * (1 + E).
* [**IMPORTANT**]

* L = {All strings of 0's and 1's where in every string 2-consequtive 1's are not allowed and starting with '1'}.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18dac704-f06f-4fae-8af1-6aa6e7ec81b2)

* Minimal String -> 1,10, 100000, 10001
* Minimal length -> 1

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4029d21-c03b-41f4-b61c-51f44c7805f5)

* (10) ^ * -> It means that 0's and 1's side by side are not allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce0264cc-73e0-4a3c-9a4e-2707eda8b1f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71fd8b95-2fb8-40b2-a1b9-d804a26d09af)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b42dba98-ac56-47e4-af65-c8776ce33a36)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee781aea-864e-488a-9dd5-83857ca23f8e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff216d0a-a7b4-4d5c-a66a-6a77def99e4c)

* Everything possible.
* Try covering the **majority** then try adding the **minorities** that are **left out**.
* [**IMPORTANT**]

* Epsilon ^ * -> Epsilon possible.
* Because of **star(*)** we can go inside any no. of times.
* Phi ^ * -> Epsilon.
* We may not go inside also then **Epsilon** comes.
* If we go inside **one time** then **phi** will come.
* Phi + Epsilon -> Epsilon only [Nothing + One thing -> One thing]
* Phi -> Nothing
* Epsilon -> One thing.
* We don't go inside that's why **epsilon** came.
* (a + Epsilon) -> They are **two different** people. Either **a** or **epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50fe1681-29e3-4d0a-9a57-2869e2adba39)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5cd6aa59-2fd3-4a27-8319-3c6075080a3b)

* [**IMPORTANT**]
* Zero(0) multiplied by anything is Zero(0) only.
* Epsilon -> Zero(0) length string or empty string [Zero(0) is length].
* Phi -> Empty language [Zero(0) strings there, not length is zero(0). **Zero(0)** is the no. of strings].
* As **phi** is a **language**, we cannot say it's length.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/952d3e1e-253c-433d-91f2-2d8eb06140ab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1af17f7e-1173-414d-9fed-54a6f69cabbe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df9522dc-2099-483c-addd-d5e2e33b1417)

* [**IMPORTANT**]
* (Phi ^ * ) -> because of **star(*)**, we can go inside any no. of times. Inside, don't go also then **epsilon** will come.
* (Phi ^ + ) -> because of **plus(+)**, we have to go inside.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/208d2426-238a-4ad0-96a0-a05abcf91195)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f619ecc9-8199-4df4-9088-49c657393edd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e4dfa6f-32d1-48dd-b4fa-d4379f3cea0e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32f147b1-f71a-4452-8b3c-2aac7d08f9e4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7226210-90c7-4e77-9619-13f933f85de2)

* [**IMPORTANT**]
* Phi + Epsilon -> Epsilon
* Length of **epsilon** is **0**. No. of string is **1**.
* L = {Epsilon}
* Cardanality of 'L' or |L| = 1 ['L' contains no. of strings]
* Length of **epsilon** or |epsilon| is **0**

* L = {Phi}
* Cardanality of 'L' or |L| = 0 ['L' contains no. of strings]
* Length of **Phi** or |Phi| is **non existent**. There is no question of **length**, as there is **no string**.
* There is no question of **length** as string is **not there**. **N0** string is there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17923429-d3cf-4c05-bd97-cdc0687aeb9c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a65d4e6-646b-4f9b-9898-afd270387c5d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40b84e88-8be4-46a6-a07f-47e682031e01)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7987f28c-bfaf-4cd6-8e46-d5086320b48a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cff1369a-04c2-43e2-b649-3544a444cff2)

* [**IMPORTANT**]
* GRE, L = {Set of all strings of a's and b's where each string contain exactly 2-a's}
* Minimal length -> 2
* Minimal string -> aa
* **b's** can come at any place.
* Inbetween can also come. Question didn't mention about **consequitive a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f4151179-19a8-47de-9127-72015cd5021c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8cff01b8-28d0-43ed-9c16-dcf11cc0e85d)

* Correct answer. [**IMPORTANT**]

* ((b ^ * ) * a * (b ^ * ) * a) -> If the **last (b ^ * )** is not present/not written then we can say that the string is always **ending with 'a'**.
* (a * (b ^ * ) * a * (b ^ * )) -> If the **first (b ^ * )** is not present/not written then we can say that the string is always **starting with 'a'**.
* **Possible options to the question**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/117a86ae-5a8b-4040-b8a7-521039f51282)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d900b77-6b7c-4eff-bbe8-b25672709753)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0c711258-6d94-46b0-ba59-a5bd0abf83be)

* L = {Atmost 2-a's}
* **a's** may come or may not come.
* If **a's** come then they can come for **2-times** only.
* ((b ^ * ) * (a + epsilon) * (b ^ * ) * (a + epsilon) * (b ^ * ))

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ae1308b-9b4b-4eeb-8acf-ee6f6e486c43)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c6beb69b-45fe-4b5e-ab38-119842c6fa5d)

* Minimal string -> Epsilon.
* Max of **2-a's** only possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66685807-d6cd-4d0a-9430-a335ec8f2987)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf593466-69bb-4a6f-a730-9c150f94d68d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fe09511-f862-45c2-8f01-15c0497a34e7)

* L = {Atleast 2-a's}
* Minimal string -> aa
* **2-a's** are compulsory then anything can come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6f51673-b52f-4231-810b-0b48db3abccd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/46a848fc-7905-4edf-be8b-c4deddf0977c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d1ae94e-b854-410d-847c-d5153b160a9e)

* All **four** are **correct**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/170c2c04-53c7-41b9-b62f-5f67ad561d3d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7442a82-585c-4868-ab5f-8f44a4f7e346)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/410380d6-0532-4ccf-8a89-f07ed5f87126)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8256389-cdb1-4bb6-a4e7-e0fa64b01696)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea3be7a3-833e-4335-a5d7-912d3a75d1f6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c64e095-cd79-466b-b329-9685c24535d9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7570d838-e01f-4981-aeb1-4f302796af72)

## regular-expression-iii (15) [10th Sept 2023]

* GRE,  L = {All strings of a's and b's including epsilon}

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40a170f3-c7a9-438a-9cbc-45bb1814dafe)

* In **(a + b) ^ * )**, we can get **epsilon**.
* If we want to get **epsilon** then don't go **inside** at all.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ee0263d-3913-4692-91b5-29e1ff156900)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2a77132-5969-4436-8699-861dc5068351)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1068ab10-63fd-4d42-bf88-6269c49cce60)

* If we want to get **epsilon** then don't go **inside** at all.
* If we want **10 a's** then just go inside **once** and then take **(a ^ * )**. It will give **10 a's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6466f787-2d3b-456c-a3e3-513a3c71ce29)

* Both mean the **same** thing.
* We wasted **one star(*)** in the **second one**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16f88583-cbca-4cff-9b7a-be3e5502b94e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1bdd847f-bee6-4baa-aab2-66eac421a0f9)

* Meaning wise all are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4df34106-84e7-4f50-8bfb-ceefc2373fcc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78abb4d-3934-4ca4-9008-e2dc349175d7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8d28756-ff7b-4e20-87f1-cb681ae1b538)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd42f3f5-96c2-40b3-9039-b44a0b322506)

* Epsilon is possible, a's possible, b's possible, a's followed by b's possible, b's followed by a's possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a0c3e45-1f83-4d01-9794-9ee4733ffaa8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9fdd81c5-8852-4607-947a-90ea3624cad5)

* Which one **even**?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad06799b-0837-4059-9c9d-be39d9b53fa9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f0e1b2c-6534-4849-bf42-eba03749c6ed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83e2d960-5494-4f24-b3a7-256291138648)

1) (0 *) -> All there.
2) ((00) ^ *) -> Even no. of zeroes.
3) (((00) ^ *) * 0) -> Odd no. of zeroes.
4) (((00) ^ *) * (0  + epsilon)) -> Even followed by one odd and sometime, even followed by **zero(0)**, it is **even**.

* So, **1 and 4** are **even**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2133bd2a-941d-4c91-8f84-5f0db897eea3)

* ((0 ^ *) * (1 * (0 ^ *)) ^ *) -> Only 0's is possible, Only 1's is possible, 0's followed by 1's possible, 1's followed by 0's possible.
* It is like **((0 + 1) ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a04a0efd-4d5b-4086-bdb8-66e442499a75)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23d99b1c-fd4e-4eac-993a-9e38af7cddfe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ddc9962-6186-4f95-becb-b87d6b70d211)

* These **four** are **same**.
* Always ending with **b**, why not ending with **a**.
* Always ending with **a**, why not ending with **b**.
* Always starting with **a**, why not start with **b**.
* Always starting with **b**, why not start with **a**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5294122-8cc3-46c8-b4e5-4cd32d3b039c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f855522d-b720-4595-839a-403474f31244)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3509f7c6-3817-4607-a5c0-a7904c620fe8)

* No problem
* Last **a** will be given by **(a ^ * )** outside.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/605f3b30-7eb6-4331-a546-7179be805d78)

* All **12** of them are **equal**.
* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fcd48d57-6824-4d78-b604-479f3dfb44c9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/52697abe-d850-40d6-83c3-8b5e1b3ef1b5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/90d41c02-87b7-4d07-b21b-eff7ce49d2de)

* L = {Set of all string over it's alphabet, {0,1,2} in which every **2** is immediately followed by exactly 2-0's and every **1** is immediately followed by **0 or 2**.
* Everyone is immediately followed by **zero(0)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f988dbf-cb2e-418c-904f-4f560cf9d70c)

* [**IMPORTANT**]
* Directly we cannot write **regular expression**. Directly we cannot construct **DFA**.
* We have to start with **NFA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8a5e231d-fa56-45bb-8dac-f959483a625f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dca33ec-bbcf-461c-af33-f87c9e9fa2e2)

## NFA Construction

* **NFA** will cover only valid things.
* When we are constructing an **NFA** for a given language(L) then we will try to cover everything in **L** only.
* **DFA** will cover everything in **(Sigma ^ * )**.
* **NFA** construction much easier than **DFA** construction because **NFA** will cover only string present in **L** but **DFA** will cover every string present in **(Sigma ^ * )**.
* **(Sigma ^ * )** -> (L U L') -> Valid and Invalid both.
* L' -> Complement of **L**.
* **L'** complement people will go to **non-final** state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c31411b-bf81-4312-a871-1f1a6415b7dc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34701ac8-969c-44f9-8b7f-e4c2fd1f7162)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6bca4dc8-1612-4e4e-94bf-bf236fe492d1)

* Start from 1hr 32mins.




















































































































































































































































































































































## Misplaced Images

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db87f3f9-4670-43db-9fe5-644c00632aed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bef6f5d8-9532-4788-a4fe-07b0c733ca7b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d43f8ed-d24f-413a-9b1a-dddcb37f6f9b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97f0067c-0503-45b8-b37e-ba734b7274e6)
