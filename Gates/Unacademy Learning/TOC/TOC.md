# TOC

## Motivation

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dfb4fce-5b66-4a58-8260-3591eb6708bc)

## Syllabus

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/67e960e4-abc6-4c11-bb0f-615be22d1258)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbc0f3a7-9e89-4a70-a93f-4f3a4806dd78)

* Link -> https://unacademy.com/course/complete-course-on-theory-of-computation/ON3TCUN5?_branch_referrer=H4sIAAAAAAAAA8soKSkottLXL81LTE5MSc2t1EssKNDLyczL1jepdM%2F1SQ0t83FOAgAdZnNEJgAAAA%3D%3D

## introduction-to-theory-of-computation (1) [3rd Sept 2023]

* TOC is nothing but mathematical representation/study of computing machine and it's capabilities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/746564f6-4f2a-4faf-8788-fd12ef5418e7)

* First mathematical model is ready and then the model is sent to algorithms(Close to programming language).
* Model -> Algorithm -> Coding
* Language -> Collection of string.
* String -> It is nothing but collection of characters.
* aabb -> It is a string. There is no meaning of it in the english language.
* Formal language -> It is also collection of strings only but meaning of the string is not important but format of the string is important.
* aabb -> Two a's followed by two b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d264ad18-54fd-4584-8b97-753a1dfecfd8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95df5916-4e93-4a3f-bba1-633a45df3eb3)

* In this subject, meaning is not important but the **format is important**.
* a ^ 2 -> Two a's
* b ^ 2 -> Two b's
* a ^ 10 * b ^ 10 -> 10 a's followed by 10 b's

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70630489-07c3-428e-9063-319ed54022b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3038f041-4f0f-4a30-bc87-26b34939f30b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ad4880b-7b17-415e-9399-cbf4fe3413a0)

* Meaning is not there but format is there.
* In machine language, format is important.
* In human language, meaning is important.
* **W** is one string.
* '*' -> Combination.
* **W** is one of the strings which is a **combination(*)** of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ed863f7-7467-4a28-81a7-aecc983743a9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d729926b-bc67-43ed-8c97-e2989121a3b6)

* **W** is combination of a's and b's.
* Reverse of **W** is **W ^ R**.
* **L** -> Palindrome.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/194dd818-3441-452a-941a-fa0228474b81)

* Order is **important**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a04a3851-a540-4997-bf0f-b79583963354)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/94f1873d-1e31-4a0a-8631-48f4a83470e3)

* Formal Language -> Set of palindromes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0dd66a2d-9b8b-454e-a8f7-29e916a711d3)

* One of the formal languages where there are infinite no. of strings.
* 'n' number of a's followed by n-number of b's.
* **W** -> We can take any combinations of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78ec184-fc4b-4038-b49b-da28a258be32)

* a's should come first and then b's should come
* Infinite language as no boundaries.
* How many a's and how many b's, no relation
* 'm'-no. of a's followed by 'n'-no. of b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9bfc043b-6c9e-404c-a2fd-61c398263adb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f16d7f6-18db-4914-baa9-46fdf565277e)

* Like these many formal languages

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13edd8d6-8fb3-4671-a66d-1872c15e5ce9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab7487ee-b304-4498-a7e7-feeca0b7e4d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d710f226-4e31-41d4-87f7-c8b1c088347f)

* L = {WW} -> String Copy.
* Exact matching.
* Whatever we see **first** that same thing should be there in the **second** as well.
* No. of actual parameters = No. of formal parameters.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8429b54a-3cc8-4cf7-b7d6-571f414afca4)

* Examples.
* There are **four types** of formal languages:- [According to Chomsky]

1) Type3(T3) formal language
2) Type2(T2) formal language
3) Type1(T1) formal language
4) Type0(T0) formal language

* **Type0** is the superset among all of them.
* **Type3** is the subset among all of them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ddddb1b-8268-411b-a4fb-125fec4e992e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cac07f41-807e-4138-97f4-7ddf905c0b56)

* R3 -> Smaller -> Regular Language
* T0 -> Bigger.
* Our computer program maximum can be **Type0(T0)**. No chance of more than that. It is the limitation of the computer.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e290a64c-c906-46bf-9a17-5823dd96b7b4)

* To accept smaller language(T3), smaller machine is enough.
* The smaller machine is called as **Finite Automata(Machine)**.
* Automata means **machine**.
* Finite Automata means finite machine
* Finite Automata also called as **Finite State Machine(FSM)**
* Which one is the smaller formal language?

> **T3**.
* Other name of **T3** is **regular language**.
* **Regular language** is accepted by a machine called as the **Finite Automata(Machine)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaa5d6ab-6780-47d2-949b-56dfdaaf04eb)

* Other name of **T2** is **context free language(CFL)**.
* The machines that accept **context free language(CFL)** are called as **Push Down Automata(PDA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b863c99-6c93-4138-889b-278605bbd17d)

* Other name of **T1** is **context sensitive language(CFL)**.
* The machines that accept **context sensitive language(CFL)** are called as **Linear bounded Automata(LBA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f72166d-552e-446f-ab98-4e6803a9d5ac)

* All computer programs are **T0**.
* Other name of **T0** is **Recursive Enumerable languages(REL)**.
* The machines that accept **Recursive Enumerable languages(REL)** are called as **Turing Machine(TM)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74f6bda0-a63c-4e57-80fc-bf6efbb8eca4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0fbb9888-93fe-41b1-a868-856e35bd07fd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aca784a8-83ee-4308-8361-7936a9b363b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74569991-dd48-4dfb-a964-ca0ffc0722c0)

* Turing Machine is equal to computer.
* Regular language accepted by a machine called as **Finite Automata**.
* Formal languages and Automata theory(FLAT).
* Computing machine and it's capabalities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eedbb788-cc01-4c55-be70-0723778c85bc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e06c5c53-99f5-49d3-9854-ceb2fd3bd142)

* In general,
* T3 is the **subset(C)** of **T2**.
* T_i+1 is the **subset(C)** of **T_i**.
* Type3 means Type0 also.
* By default, every/all formal languages are **Type0**.
* Every machine is a subset of **Turing machine**.
* **Circle** indicates **state**.
* Two states are **S1 and S2**.
* State -> State is nothing but the thing which can remember something. [Remembering Capability]
* State is nothing  but **Remembering Capability**
* State is changing and remembering capability is also changing.
* Nothing knows/known -> Starting State.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c116a8e0-169a-4599-854d-46dc717c4388)

* Remembering capability is **increasing** so our state is **increasing**.
* Empty State -> S1 [Initial days]
* 'a' -> Mama's name
* **S2** means **a** completed
* **S1** means nothing completed.
* Same State
* If something new happened, then we may go to **other state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a9b1f25-f11a-4e7a-a802-dad45eca1ad5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9c6eb1e-f007-4530-908a-d902603117a8)

* Double Circuit(Double circle) means **final state**.
* After accepting **a**, the automata is in **final state**.
* After completing **aa**, the automata is in **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e620dab2-4763-4708-9bf8-317f3b53d776)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0251b251-09b4-447e-bebe-b8332c900f27)

* The **automata** will accept the **above language**.
* In the automata, there are **two(2) states**.
* That's why it is called as **Finite state machine(FSM)**, it it called as **finite automata**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83aa4eae-7daa-4346-8e74-e66ff8dfc28f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee57ac3c-a5e8-4697-aa4b-38bdddf13887)

* The finite automata is accepting **L1** formal language.
* Finite automata is accepting some formal language means the formal language is a **regular language**.
* Finite automata will accept **regular language** only.
* This formal language(L1) is a regular language.
* For the formal language(L1), finite automata(FA) is available so the formal language(L1) is a regular language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a868e695-5c0c-4e69-9f63-9e95b02c6abf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30b15c92-1ff7-4a5f-a0ae-9daf46c931b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e5e8914-a32c-42d2-899e-f45773136625)

## difference-between-nfa-dfa(2) [4th Sept 2023]

* Why these many Automata's?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fcb26a7-2fe7-4711-9027-9597e109140a)

* Between a's and b's there is a **relation**.
* How many a's will come, those many b's should come.
* What is the minimal string?

> 'ab'.

* If the minimal string is 'ab', then the length of the minimal string is **2**.
* Minimal string is 'ab' of length **2** then **start automata** is of **three states**.
* States -> Minimal string length  + 1 -> 2 + 1 -> 3
* With **three states** start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87e54840-82ee-4c97-a229-ddfd6bb6d5af)

* **Every circle** indicate **state**.
* **Double circle** indicate **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39fc7de4-d639-44e4-b23e-0bb06f9bbb38)

* Starting state is **S1**.
* Final state is **S3**.
* Initial or initially arrow to whom, that's the **starting state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/670988fb-7cdf-442e-96e1-a5435105df25)

* After reading **ab** from starting state we can go to **final state*** then **ab** is accepted.
* Minimal string **ab** is accepted.
* With the **three states**, start the story.
* When can we say that a machine is a correct one?

> One valid think cannot be rejected. One invalid think cannot be accepted.

* All valids are accepted.
* One invalid cannot be accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbbfc3b9-7604-4f74-8cec-e19ff01a6a2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1671c305-6f61-4e82-a182-d82e207ccbb2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96f44ef5-f907-44f2-964b-cb24dbc59d0e)

* The automata we have constructed is **wrong**. As it is accepting **invalids** as well.
* To this language, finite automata not possible.
* a's and b's are always equal in the language.
* **Loops** means it may come and it may not come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/001e5520-1f4c-471f-bf13-9344323f3191)

* This is called as finite automata or finite state machine.
* Finite state machine has failed to accept the **above language**.
* As **Finite state machine has failed**, we are going to the **next automata**.
* The **next automata** is **PDA(Push Down Automata)**.
* **Push and Pop** operations come in **stack** data structure.
* FA(finite automata) fails to accept above language, so we are going to **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d2e0bf7-3087-4a0e-adee-c6aa3dbd3a71)

* In the above diagram, we are not keeping any relation between **a's and b's**, a's are coming any no. of times, b's are also coming any no. of times. This is a **problem**.
* a's loop can be repeated **infinite** no. of times. So, b's loop also repeat **infinite** no. of times.
* If a's loop is repeating 10 times then b's loop should also repeat 10 times.
* But unfortunately there is **no relation**.
* **a** repeating whatever way it want, **b** also repeating whatever way it want.
* **a** repeating 10 time and **b** repeating **1 lakh** time.
* We didn't keep any **condition**.
* **PDA** is nothing but **finite automata(FA)** only including **one(1) stack**.
* In **PDA**, **stack** also there.
* Just add one more stack to **finite automata(FA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e07ad5c-b803-4d8f-a6cf-f91093c0b433)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c019b9a2-3470-460a-90c8-86933ed72fb1)

* **#(Hash)** indicates(marker) -> **Stack empty** -> Nothing there in the stack.
* Top of the stack, **#** means that the stack is **empty** now.
* How do we know string is over?

> There is a **marker**, which is the **dollar($)**.

* **Dollar($)** indicates -> **String is over**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ad6328d-a1c3-4eca-86d7-d73be4fd549c)

* Every **a** is pushed into the stack. As **three a's**, so **three push** operations.
* When **b** is coming, then start **pop operation**.
* It is because we have to count the **no. of a's and no. of b's**. [**IMPORTANT**]
* We have to count that **no. of a's** =(equals) **no. of b's**.
* For every **b**, pop **'a'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10e352ad-8dcf-4f03-a262-f3f7937e0d04)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32a543f7-7e73-413c-91d9-bf2593b16e70)

* Next symbol coming in the input is **$**, which means **string is over**.
* **$** means **String is over** and **String is over**  means **b's** are over.
* Now, at the top of the stack, we have **#** which means **stack is empty**.
* **Stack is empty** means **a's** are over.
* When we got to know that **b's are over** and **a's also over**, it indicates that **no. of a's** are **equal(=)** to the **no. of b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/520afa32-74fd-4ed3-9c45-fb24664bacd0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/798db7be-749c-402e-9bc2-703334a8e62f)

* Yes.
* No. of a's == No. of b's.
* Now, **String is accepted**.
* **$** -> String is over -> b's are over.   [**IMPORTANT**]
* **#** -> Stack empty -> a's are over.      [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd9cb26e-69a1-45d7-95e1-740b395a6bff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1cc2ecb-57af-4940-ad39-e945cd71794b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4d47c15-2c54-452b-be1b-cc81a69fbbbf)

* aaab$
* Top of the stack should be **Hash** but unfortunately still **a** are there.
* So a's are **more**.
* It is **invalid**.
* In **PDA**, when is the string accepted?

> At the end of the story, **stack** should be **empty**.

* If **stack empty** then only **string is accepted**.
* String is over($) but still stack is not empty.
* So **string rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/430aeeab-34aa-47fb-8690-34b92d5007ba)

* **Stack** is taking care about **how many a's came** and afterwards b's will come.
* In **finite automata**, we do not have any track of **how many a's came**. We don't have **stack**.
* If we want to compare a's and b's then until b's comes, we should store a's somewhere(stack).
* We have to keep track of a's, **how many a's came**. We have to store somewhere.
* **Finite automata** don't have **stack**.
* Comparison minimally requires **two people**.
* So, until **b's come**, we cannot do **comparison**.
* Until **b's come**, **a's** have to wait.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb809f5a-e046-4c07-9af7-356d7e99f189)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/100cbb97-7c52-4b42-b3a7-7e10d6307b46)

* a's more
* At the end stack should be empty then only **accepted**, otherwise **rejected**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5817a5b-a5db-4811-8eba-ae214923fb5c)

* In the **stack**.
* Stack not empty, that's why **rejected**.
* My language, a's = b's.
* Finite automata fails to recognize those languages where comparison is **involved**.
* When comparison is involved, finite automata fails we need **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d209403-2293-4232-9223-4f1d91e109e0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e0a9bd3-7033-447a-8f2e-0bd06584e74a)

* Every valid thing should be **accepted**.
* No invalid thing should be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d6952b7-fd0b-4de0-b51b-5a90a7b3946b)

* In these language, we have to compare, a's = b's = c's.
* Two comparisons are involved over here.
* When **a** is coming, push in both the stacks(S1 and S2).
* When **b** is coming, pop only in **S1** stack. For every **b**, pop 'a'.
* When **c** is coming, pop only in **S2** stack. For every **c**, pop 'a'.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d8ed4e8-9fc0-422e-9015-b556749ff33f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a46014a2-1ec2-42ab-b211-c05b16a99f91)

* When we saw the first **c**, **b's** is over which means that **a's** also over.
* It indicates that **a's = b's**.
* Whenever b's over, then a's also over.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51779c8c-63bb-43e8-a973-0aab990d57e1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f188c39-40b8-48a8-8dc4-68142e7dd42f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a35e6b65-ab6c-4cfa-b02f-998c3950ac8f)

* **$** means **c's** is over.
* **c's** is over means that **a's** also over.
* It indicates that **a's = c's**.
* We also proved that **a's = b's**.
* So, indirectly we have proved that **b's = c's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/687f43e4-5e8c-4ec4-bda7-9683cf42186a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22aa49bc-c917-4981-a0f3-9cc2e75a03b3)

* When two comparisons are there, this is the story. 
* Now, using **one stack**.
* Because of two comparisons, we have done **two stacks**.
* With **one stack**, can we do this?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aeb89b79-7352-4ef7-a02f-79970392d6db)

* Suggestion
* **one a** for 'b' and **one a** for 'c'.
* For every b, pop 'a'.
* For every c, pop 'a'.
* Finally stack is empty.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad0584d5-d179-4f4a-a362-f3d7175f9cb2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c32c956d-98af-4ae4-9d77-c354d44a1760)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3dc6664-c88e-4a38-a22f-9b0d7554400a)

* No invalid ones should be **accepted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c7ba6be5-5cf8-43a3-80dd-57fa28ace195)

* Another suggestion.
* Nonsense going on.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2301e938-3b6c-4145-bd84-7643fe8066cf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66e21007-a55e-4278-b6a1-8b23315dadb0)

* More than **one comparison**, **PDA** fails.
* One stack, we cannot do.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da0f6785-ae38-4a62-a4c4-6e499a3d1d31)

* When comparison required -> Finite automata fails -> PDA says, it can.
* Only one comparison -> PDA.
* More than one comparison -> PDA fails -> With one stack we cannot do.
* Here, two comparisons needed, so **PDA** fails because it(PDA) can handle max. of 1-comparison.
* For these reason, we are going to **Turing machine(TM)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e564cb54-c1a8-4aa3-a122-1db11ae3b9d8)

* **Turing machine(TM)** -> For the existing PDA, add one more stack, so total of **two stacks** now.
* PDA already contains one stack.
* **Turing machine(TM)** -> Finite automata(FA) + 2-stacks.
* PDA -> Finite automata(FA) + 1-stack

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3796003c-ab94-48c2-9ec0-8615f6464f14)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d322e07-5d8b-4c6a-99cd-7f3e5cbc8235)

* **LBA** is theoritically present. Practically not there.
* LBA only for name sake.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc59591f-d492-4882-b7c8-53442a216756)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7124302c-013a-49cb-9812-05e8566ba61d)

* Exam -> 4 Automatas
* Outside of Exam -> 3 Automatas(FA, PDA, TM) [Since **LBA** is only theoritical]
* More than one comparison -> Turing Machine.
* Turing Machine means **two stacks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b37b661-a47c-447e-9306-1b9d461903e3)

* When 'b' coming, pop 'a' and push 'b' into the other(seecond) stack.
* For every 'b', pop 'a'.
* When **b's** are over, stack is empty, so **a's = b's**.
* For every 'b', pop from first stack and push in the second stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ade51065-ccf1-4809-9d2b-7d7fc4650600)

* For every 'c', pop 'b' and push 'c'.
* When **c's** is over, stack is empty, so **b's = c's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b33836a-6a03-4800-bda2-20ff07459900)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7da2ebc-18bf-48dd-8956-be2d9f99eef3)

* Again one stack is empty.
* For every 'd', pop 'c' and push 'd'.
* When **d's** is over, stack is empty, so **c's = d's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/346b2ab6-41ce-4853-8366-fe4ac2a41b99)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ccdd282-6465-4798-8cfd-3835f2744aa2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fea6d77f-d20d-43f8-8440-7b623420f6b0)

* Using **Turing machine**, we can do anything.
* With **two stack**, we can do anything.
* Computer is nothing but **finite automata with/plus 2-stacks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0e87046-62ed-493c-8990-da126ccd7c89)

* At the end of the string, stack is empty then **string is accepted**.
* First all a's should come, then all b's should come and so on.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0fa9647-a062-4ec5-92cc-75b6627cba5b)

* Inside the computer many programs.
* For every logic, there is **turing machine**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ece7a79-f14c-4758-b654-6276d0bedd8e)

* FA + 1-stack -> PDA
* PDA + 1-stack -> Turing machine
* Power of **turing machine**, **equals to** the power of the **computer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/78e219bf-6e27-4c03-9cd5-3de93f2fed55)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/537598ee-4d21-4bc2-8c8d-451b54b18ee2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c838ade4-7c98-437f-9e39-7c01652ad863)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d67a728-62ff-4ae7-97d2-ad0de3181d5b)

* Alphabet -> It is **finite** non-empty set of symbols.
* Any language where the **alpha bit size** is **infinite**, no way.
* Language -> Atleast one letter/symbol required.
* **Alpha bit** is changing from machine to machine.
* Machine changes -> Language changes -> Automatically Alpha bit changes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38d01a94-a4ad-4636-93a6-29032696c6f9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42ca96a1-a19d-4af3-9fe5-a461b475f5de)

## dfa-construction-i(3) [4th Sept 2023]

* Alphabet(sigma) -> Finite non-empty set of symbols.
* String -> Collection of symbols over the given alphabet.
* abbc -> It is not a string because 'c' is not there in the **alphabet**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b220616d-7f78-468d-9f08-b2473effa4b6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9034b3e3-2128-4673-8acc-1f7d66cf6043)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e9279c21-2025-44da-9f55-fcf05a52da1f)

* One length strings, two length strings, three length strings possible.
* Epsilon(E) -> It is a string, whose length is zero(0). It is a zero(0) length string.
* That's why it is called as **empty string/Null string**.
* When we write **one symbol**, atleast **one length required**.
* Total TOC going on with **Epsilon(E)** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f41742b-3bba-4b31-9a24-752bb463dba5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7c588ed5-ad13-43d0-8071-4d60e19816d2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/649a9482-23f4-44e1-a20e-a4c623d08c36)

* Sigma = {a,b,c}, what is the minimal string possible over this alphabet?

> **Epsilon(E)**

* It is the **special person**.
* Epsilon(E) Length -> Zero(0).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71976527-d320-44dc-80fd-ed7ed8a23e3b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81209bf4-f776-4666-90e2-18533d6ff4e4)

* When we **concatinate** anyone with **Epsilon(E)**, we get the length of the **anyone string**.
* At the end of the day, we are concatinating **two string**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b53152f9-c24c-4cf9-af13-2dc9c7b2a12e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75cf7ef1-e6e9-4117-9729-c81cfdc4a026)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cf671a2-cf64-4735-b220-a0a219178bc7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/25af01b1-d4b6-4ca5-82ed-9e237e2ef8c5)

* String length -> Modulo operator.

### Power of a alphabet

* Sigma -> {a,b}
* Sigma ^ 1 -> Over the alphabets(a,b), what are the **1-length strings** possible.
* Sigma ^ 2 -> Over the alphabets(a,b), what are the **2-length strings** possible -> **Inside the sigma, we have to go **twice or two** times**.
* When we go inside **sigma**, take anything.
* Sigma ^ 3 -> Over the alphabets(a,b), what are the **3-length strings** possible -> **Inside the sigma, we have to go **thrice or three** time**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01d1eb92-a16b-49d4-9e10-3f86b1318927)

* Sigma ^ 100 -> **Inside the sigma, we have to go 100 times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4fd496a-49b9-45d7-8253-f739941980e4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a4b259a-dda7-4c81-8c1c-9f1b534f3931)

* Sigma ^ 0 -> **Inside the sigma, we have to go '0' times or don't go inside**. We don't get anything. We will get **Epsilon** only.
* Sigma ^ 5 -> **Inside the sigma, we have to go '5' times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c1d7e6e4-dabe-4e7f-a727-941713b02d87)

* Sigma ^ * (sigma to the power of star) -> It will give every possible string over the given alphabet.
* It is also called as **complete language**.
* In set theory it is called as **universal set**.
* Set of all strings over the given alphabet including **Epsilon**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3be222d4-0df5-4c26-8b6d-768a56539439)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0876eab9-3744-4ceb-a03a-4c499ffde246)

* N -> Set of natural numbers.
* It is **Countably Infinite(CI)**.
* Something we can list out, it is **Countably Infinite(CI)**.
* {1,2,3,4} -> **Countably Finite(CF)**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f67a8c95-1f0e-4ad2-ad76-56ec5f9ace92)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06ed0ce6-601f-4b52-b5c1-aac33283ccf2)

* Uncountable.
* Set of real numbers.

* Sigma ^ * -> Means everything including Epsilon.
* '*' -> Kleen closure
* Sigma ^ + (sigma to the power of plus(+)) -> Only Epsilon missing.
* '+' -> Positive Closure.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e913695-f30b-476d-9259-da52e1073d79)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9aa8c5b9-c181-4100-9f83-cbc489990cc7)

### Language

* Language -> Collection of strings over the given alphabet is known as **language**.
* In the language, infinite no. of strings are here.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c014480-ebbf-428d-bace-816eedb49f7d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f5c3658-e6a9-4cb3-9a36-1f402c2d8d1f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81a06104-6b08-440a-8338-84cb6d87ab64)

* Example
* In general, **language(L)** is **subset or equal to (sigma ^ * )**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77c6b719-d3a2-4d8a-8e16-059dde51fc84)

* More than **(sigma ^ * )** is not possible. Not possible, no concept there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5aeb8821-55ff-424d-b99f-291d5281a267)

* From everything take a **subset**.
* We can take **infinite as well as finite** subsets.
* Don't go beyong **(sigma ^ * )**.
* Empty set is subset to every set.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc5b66ec-5f52-4e82-9ea2-7f77102f497f)

* **L5 and L6** are **language** because they both are **subset** of **(sigma ^ * )**.
* In **L5 language**, the language is **not empty** but the string accepting is **empty** string.
* In **L5 language**, **one string** is there whose length is **zero(0)**.
* In **L6 language**, the language itself **empty**. No one is there. One string is also not accepting.
* We can take **everything** also.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3bd6146e-9e74-4267-96b2-b6a932de527c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f4cb14e-20fa-45bc-9bb6-da5509b670ed)

* Countable Language

1) Countably finite -> Set of all Indians.
2) Countably infinite -> Set of all natural numbers, Set of all computer programs, Set of all Turing Machine.

* Uncountable language -> Set of all real numbers

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d3c1226-de64-478f-9f5f-e9968da02418)

* Computer program is nothing but Turing Machine.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2ef958c-7015-4696-ae62-2ac9d39066cc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/231894ff-907d-4305-a4c4-48d189bc792b)































































## Misplaced Images

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db87f3f9-4670-43db-9fe5-644c00632aed)


