![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db87f3f9-4670-43db-9fe5-644c00632aed)# TOC

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dfb4fce-5b66-4a58-8260-3591eb6708bc)

* Link -> https://unacademy.com/course/complete-course-on-theory-of-computation/ON3TCUN5?_branch_referrer=H4sIAAAAAAAAA8soKSkottLXL81LTE5MSc2t1EssKNDLyczL1jepdM%2F1SQ0t83FOAgAdZnNEJgAAAA%3D%3D

## introduction-to-theory-of-computation (1) [3rd Sept 2023]

* TOC is nothing but mathematical representation/study of computing machine and it's capabilities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/746564f6-4f2a-4faf-8788-fd12ef5418e7)

* First mathematical model is ready and then the model is sent to algorithms(Close to programming language).
* Model -> Algorithm -> Coding
* Language -> Collection of string.
* String -> It is nothing but collection of characters.
* aabb -> It is a string. There is no meaning of it in the english language.
* Formal language -> It is also collection of strings only but meaning of the string is not important but format of the string is important.
* aabb -> Two a's followed by two b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d264ad18-54fd-4584-8b97-753a1dfecfd8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95df5916-4e93-4a3f-bba1-633a45df3eb3)

* In this subject, meaning is not important but the **format is important**.
* a ^ 2 -> Two a's
* b ^ 2 -> Two b's
* a ^ 10 * b ^ 10 -> 10 a's followed by 10 b's

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/70630489-07c3-428e-9063-319ed54022b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3038f041-4f0f-4a30-bc87-26b34939f30b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ad4880b-7b17-415e-9399-cbf4fe3413a0)

* Meaning is not there but format is there.
* In machine language, format is important.
* In human language, meaning is important.
* **W** is one string.
* '*' -> Combination.
* **W** is one of the strings which is a **combination(*)** of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ed863f7-7467-4a28-81a7-aecc983743a9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d729926b-bc67-43ed-8c97-e2989121a3b6)

* **W** is combination of a's and b's.
* Reverse of **W** is **W ^ R**.
* **L** -> Palindrome.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/194dd818-3441-452a-941a-fa0228474b81)

* Order is **important**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a04a3851-a540-4997-bf0f-b79583963354)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/94f1873d-1e31-4a0a-8631-48f4a83470e3)

* Formal Language -> Set of palindromes

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0dd66a2d-9b8b-454e-a8f7-29e916a711d3)

* One of the formal languages where there are infinite no. of strings.
* 'n' number of a's followed by n-number of b's.
* **W** -> We can take any combinations of a's and b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78ec184-fc4b-4038-b49b-da28a258be32)

* a's should come first and then b's should come
* Infinite language as no boundaries.
* How many a's and how many b's, no relation
* 'm'-no. of a's followed by 'n'-no. of b's.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9bfc043b-6c9e-404c-a2fd-61c398263adb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f16d7f6-18db-4914-baa9-46fdf565277e)

* Like these many formal languages

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13edd8d6-8fb3-4671-a66d-1872c15e5ce9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab7487ee-b304-4498-a7e7-feeca0b7e4d5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d710f226-4e31-41d4-87f7-c8b1c088347f)

* L = {WW} -> String Copy.
* Exact matching.
* Whatever we see **first** that same thing should be there in the **second** as well.
* No. of actual parameters = No. of formal parameters.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8429b54a-3cc8-4cf7-b7d6-571f414afca4)

* Examples.
* There are **four types** of formal languages:- [According to Chomsky]

1) Type3(T3) formal language
2) Type2(T2) formal language
3) Type1(T1) formal language
4) Type0(T0) formal language

* **Type0** is the superset among all of them.
* **Type3** is the subset among all of them.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ddddb1b-8268-411b-a4fb-125fec4e992e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cac07f41-807e-4138-97f4-7ddf905c0b56)

* R3 -> Smaller -> Regular Language
* T0 -> Bigger.
* Our computer program maximum can be **Type0(T0)**. No chance of more than that. It is the limitation of the computer.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e290a64c-c906-46bf-9a17-5823dd96b7b4)

* To accept smaller language(T3), smaller machine is enough.
* The smaller machine is called as **Finite Automata(Machine)**.
* Automata means **machine**.
* Finite Automata means finite machine
* Finite Automata also called as **Finite State Machine(FSM)**
* Which one is the smaller formal language?

> **T3**.
* Other name of **T3** is **regular language**.
* **Regular language** is accepted by a machine called as the **Finite Automata(Machine)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaa5d6ab-6780-47d2-949b-56dfdaaf04eb)

* Other name of **T2** is **context free language(CFL)**.
* The machines that accept **context free language(CFL)** are called as **Push Down Automata(PDA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b863c99-6c93-4138-889b-278605bbd17d)

* Other name of **T1** is **context sensitive language(CFL)**.
* The machines that accept **context sensitive language(CFL)** are called as **Linear bounded Automata(LBA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f72166d-552e-446f-ab98-4e6803a9d5ac)

* All computer programs are **T0**.
* Other name of **T0** is **Recursive Enumerable languages(REL)**.
* The machines that accept **Recursive Enumerable languages(REL)** are called as **Turing Machine(TM)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74f6bda0-a63c-4e57-80fc-bf6efbb8eca4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0fbb9888-93fe-41b1-a868-856e35bd07fd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aca784a8-83ee-4308-8361-7936a9b363b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74569991-dd48-4dfb-a964-ca0ffc0722c0)

* Turing Machine is equal to computer.
* Regular language accepted by a machine called as **Finite Automata**.
* Formal languages and Automata theory(FLAT).
* Computing machine and it's capabalities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eedbb788-cc01-4c55-be70-0723778c85bc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e06c5c53-99f5-49d3-9854-ceb2fd3bd142)

* In general,
* T3 is the **subset(C)** of **T2**.
* T_i+1 is the **subset(C)** of **T_i**.
* Type3 means Type0 also.
* By default, every/all formal languages are **Type0**.
* Every machine is a subset of **Turing machine**.
* **Circle** indicates **state**.
* Two states are **S1 and S2**.
* State -> State is nothing but the thing which can remember something. [Remembering Capability]
* State is nothing  but **Remembering Capability**
* State is changing and remembering capability is also changing.
* Nothing knows/known -> Starting State.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c116a8e0-169a-4599-854d-46dc717c4388)

* Remembering capability is **increasing** so our state is **increasing**.
* Empty State -> S1 [Initial days]
* 'a' -> Mama's name
* **S2** means **a** completed
* **S1** means nothing completed.
* Same State
* If something new happened, then we may go to **other state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a9b1f25-f11a-4e7a-a802-dad45eca1ad5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9c6eb1e-f007-4530-908a-d902603117a8)

* Double Circuit(Double circle) means **final state**.
* After accepting **a**, the automata is in **final state**.
* After completing **aa**, the automata is in **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e620dab2-4763-4708-9bf8-317f3b53d776)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0251b251-09b4-447e-bebe-b8332c900f27)

* The **automata** will accept the **above language**.
* In the automata, there are **two(2) states**.
* That's why it is called as **Finite state machine(FSM)**, it it called as **finite automata**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83aa4eae-7daa-4346-8e74-e66ff8dfc28f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ee57ac3c-a5e8-4697-aa4b-38bdddf13887)

* The finite automata is accepting **L1** formal language.
* Finite automata is accepting some formal language means the formal language is a **regular language**.
* Finite automata will accept **regular language** only.
* This formal language(L1) is a regular language.
* For the formal language(L1), finite automata(FA) is available so the formal language(L1) is a regular language.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a868e695-5c0c-4e69-9f63-9e95b02c6abf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30b15c92-1ff7-4a5f-a0ae-9daf46c931b7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e5e8914-a32c-42d2-899e-f45773136625)

## difference-between-nfa-dfa(2) [4th Sept 2023]

* Why these many Automata's?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fcb26a7-2fe7-4711-9027-9597e109140a)

* Between a's and b's there is a **relation**.
* How many a's will come, those many b's should come.
* What is the minimal string?

> 'ab'.

* If the minimal string is 'ab', then the length of the minimal string is **2**.
* Minimal string is 'ab' of length **2** then **start automata** is of **three states**.
* States -> Minimal string length  + 1 -> 2 + 1 -> 3
* With **three states** start the automata.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87e54840-82ee-4c97-a229-ddfd6bb6d5af)

* **Every circle** indicate **state**.
* **Double circle** indicate **final state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39fc7de4-d639-44e4-b23e-0bb06f9bbb38)

* Starting state is **S1**.
* Final state is **S3**.
* Initial or initially arrow to whom, that's the **starting state**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/670988fb-7cdf-442e-96e1-a5435105df25)

* After reading **ab** from starting state we can go to **final state*** then **ab** is accepted.
* Minimal string **ab** is accepted.
* With the **three states**, start the story.
* When can we say that a machine is a correct one?

> One valid think cannot be rejected. One invalid think cannot be accepted.

* All valids are accepted.
* One invalid cannot be accepted.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbbfc3b9-7604-4f74-8cec-e19ff01a6a2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1671c305-6f61-4e82-a182-d82e207ccbb2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96f44ef5-f907-44f2-964b-cb24dbc59d0e)

* The automata we have constructed is **wrong**. As it is accepting **invalids** as well.
* To this language, finite automata not possible.
* a's and b's are always equal in the language.
* **Loops** means it may come and it may not come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/001e5520-1f4c-471f-bf13-9344323f3191)

* This is called as finite automata or finite state machine.
* Finite state machine has failed to accept the **above language**.
* As **Finite state machine has failed**, we are going to the **next automata**.
* The **next automata** is **PDA(Push Down Automata)**.
* **Push and Pop** operations come in **stack** data structure.
* FA(finite automata) fails to accept above language, so we are going to **PDA**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d2e0bf7-3087-4a0e-adee-c6aa3dbd3a71)

* In the above diagram, we are not keeping any relation between **a's and b's**, a's are coming any no. of times, b's are also coming any no. of times. This is a **problem**.
* a's loop can be repeated **infinite** no. of times. So, b's loop also repeat **infinite** no. of times.
* If a's loop is repeating 10 times then b's loop should also repeat 10 times.
* But unfortunately there is **no relation**.
* **a** repeating whatever way it want, **b** also repeating whatever way it want.
* **a** repeating 10 time and **b** repeating **1 lakh** time.
* We didn't keep any **condition**.
* **PDA** is nothing but **finite automata(FA)** only including **one(1) stack**.
* In **PDA**, **stack** also there.
* Just add one more stack to **finite automata(FA)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e07ad5c-b803-4d8f-a6cf-f91093c0b433)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c019b9a2-3470-460a-90c8-86933ed72fb1)

* **#(Hash)** indicates(marker) -> **Stack empty** -> Nothing there in the stack.
* Top of the stack, **#** means that the stack is **empty** now.
* How do we know string is over?

> There is a **marker**, which is the **dollar($)**.

* **Dollar($)** indicates -> **String is over**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ad6328d-a1c3-4eca-86d7-d73be4fd549c)

* Every **a** is pushed into the stack. As **three a's**, so **three push** operations.
* When **b** is coming, then start **pop operation**.
* It is because we have to count the **no. of a's and no. of b's**. [**IMPORTANT**]
* We have to count that **no. of a's** =(equals) **no. of b's**.
* For every **b**, pop **'a'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10e352ad-8dcf-4f03-a262-f3f7937e0d04)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32a543f7-7e73-413c-91d9-bf2593b16e70)

* Next symbol coming in the input is **$**, which means **string is over**.
* **$** means **String is over** and **String is over**  means **b's** are over.
* Now, at the top of the stack, we have **#** which means **stack is empty**.
* **Stack is empty** means **a's** are over.
* When we got to know that **b's are over** and **a's also over**, it indicates that **no. of a's** are **equal(=)** to the **no. of b's**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/520afa32-74fd-4ed3-9c45-fb24664bacd0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/798db7be-749c-402e-9bc2-703334a8e62f)

* Yes.
* No. of a's == No. of b's.
* Now, **String is accepted**.
* **$** -> String is over -> b's are over.   [**IMPORTANT**]
* **#** -> Stack empty -> a's are over.      [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd9cb26e-69a1-45d7-95e1-740b395a6bff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1cc2ecb-57af-4940-ad39-e945cd71794b)












## Difference between NFA and DFA



















































































