# Algorithms

## Course Link

* Link -> https://unacademy.com/course/complete-course-on-algorithm-768/MKL1PBOY

## Syllabus

![image](https://user-images.githubusercontent.com/54589605/229165900-6a29602a-d898-4e24-ba8c-b402cc2fe2bc.png)


## Time Complexity (1) [31st March 2023]

![image](https://user-images.githubusercontent.com/54589605/229171932-718dbe68-e46e-4d3a-9207-ba295985e033.png)
![image](https://user-images.githubusercontent.com/54589605/229172682-b9f36d76-c52d-48e8-94b1-b39b77cc24c7.png)

> Algorithm is a combination of sequence of finite steps to solve a problem.

> Combination of some(finite) statements.

> Algorithms is a generic programming language. From one language to another language, syntax will change a little bit.

![image](https://user-images.githubusercontent.com/54589605/229176423-2a904b6d-7ac9-4198-b545-c33c994860a3.png)
![image](https://user-images.githubusercontent.com/54589605/229176605-da580b3a-d2b3-4a93-8594-a39d3d26a44d.png)

> After writing the **algorithm**, we can write it in some **programming language** also.

> Algorithm is for **humans**. If we write the algorithm in some **programming language** then the computer will understand.

> We will first write **algorithm** then we will write **program**.

> We have an **algorithm** and we want to convert it into a **programming language**, the programming language we will **choose/prefer** depends on the **use case or what problem it is solving**.

![image](https://user-images.githubusercontent.com/54589605/229180078-515d676f-6e4f-4bee-bcda-7331c2708762.png)

## Programming of Algorithm

> Finite steps doesn't mean finite time.

![image](https://user-images.githubusercontent.com/54589605/229281293-38ed4065-ceb0-4780-93d2-c3050eceb2c7.png)

> It is a program but not an algorithm. Every algorithm is a **program** but every program is not an **algorithm**. Program may halt and may not halt. Program is a **turing machine**. For a problem, algorithm is possible which means **HTM or halt turing machine** is possible.

![image](https://user-images.githubusercontent.com/54589605/229282357-a3fe704d-1501-4054-a8a5-254fd4513ed8.png)

> Algorithm possible means program possible. Program possible doesn't mean algorithm possible. Program contains **infinite loop**.

* Difference between algo and program?

> Program may stop and may not stop. It may go to **infinite loop**. Algorithm has to **stop**. So, algorithm is a **HTM or halt turing machine**.

* Algorithm -> **HTM or halt turing machine** -> It will terminate after finite time.
* Program -> **Turing machine**

![image](https://user-images.githubusercontent.com/54589605/229284887-1973e0f8-56bf-4df2-b297-536a21c086c0.png)
![image](https://user-images.githubusercontent.com/54589605/229286759-629bf52e-d197-41e0-8ddb-e82cd7dc30e7.png)
![image](https://user-images.githubusercontent.com/54589605/229286825-a414e8e6-9eb8-436c-b6cd-b730b3a01259.png)
![image](https://user-images.githubusercontent.com/54589605/229286830-527b2280-b8a7-4520-92f7-6accfcf33014.png)

1) It should terminate after finite time
2) It should provide atleast one output
3) It should be deterministic
4) Every statement in algo should be effective
5) It is independent of **programming language**.

## Time Complexity-II (2) [1st April 2023]

## Steps to design algorithm for given problem

> With them procedures if we construct an algorithm then the properties are satisfied.

![image](https://user-images.githubusercontent.com/54589605/229287724-0cedcdd3-bb21-4f89-9a5e-5ae8ce210566.png)

1) Problem Definition
2) Select designing technique
3) Draw Flowchart
4) Testing
5) Implementation means coding
6) Analysis

> We have **3** designing technique in the syllabus, **Divide and conquor, Greedy and Dynamic programming**. There are **2** more which are not in syllabus, **Backtracking, branch and bound**.

![image](https://user-images.githubusercontent.com/54589605/229289909-51c4fa62-338b-41e4-bb61-454b75f7b46d.png)
![image](https://user-images.githubusercontent.com/54589605/229290767-b5f3187d-8d0f-46c9-bfe2-e51685df4a36.png)
![image](https://user-images.githubusercontent.com/54589605/229290775-9caa7490-667e-4aca-bc7d-b4e93a659269.png)

## Analysis

1) Finding Time and space complexity
2) 

![image](https://user-images.githubusercontent.com/54589605/229291429-c0f0a728-8db9-4a84-87ba-539ac61b0edb.png)

> Better solution will be provided by **analysis**. If **time complexity** is **same** then go for **space complexity**.

![image](https://user-images.githubusercontent.com/54589605/229291609-9b22ec38-09b3-483a-84f6-66f9a3004250.png)

> If the question, simply asks for **which is better**?

* Then give chance to **time** first.

> If the problem having more than one algo?

* Then, the **best one** is decided based on **time complexity(CPU time)** and **space complexity(Main memory)**. 

![image](https://user-images.githubusercontent.com/54589605/229291954-08421313-1964-4260-a96b-fe371dbd3b86.png)
![image](https://user-images.githubusercontent.com/54589605/229292024-04f749de-c1bc-4f97-ad92-571dde3894fb.png)

## Time Complexity

* 'p' is a program 
* Time complexity or T(p) = Compile time or C(p) + Running time or R(p).

![image](https://user-images.githubusercontent.com/54589605/229299347-0bf03c23-4020-44b1-95ef-9d4adfd22510.png)

> **Time complexity of a program** is **based/dependent** on the **language of the compiler and type of processor**.

## Types of Analysis

1) **Aposteriori analysis** -> **Based/Dependent** on the **language of the compiler and type of processor**. Exact answer. Computer-computer time complexity changes.
2) **Apriori analysis** -> **Independent** of the **language of the compiler and type of processor**. Appropriate answer. Same answer in every computer.

![image](https://user-images.githubusercontent.com/54589605/229301833-7e8fddfa-f9a4-426e-a75c-dfffb02db141.png)
![image](https://user-images.githubusercontent.com/54589605/229302215-e54baa48-232c-4b3c-84ba-cde47fabf1c9.png)

> According to **Apriori analysis**, everyone cannot buy **super computer** but everyone can write **super algorithm** because god gave **same  brain** to all.

![image](https://user-images.githubusercontent.com/54589605/229303214-bb14f85c-420c-432f-b7ea-29822503ed5d.png)

> Some poeple use it effictively and some not. Some people believe in themselves and some not.

## Apriori analysis

> Instead of saying **best logic**, they are saying it in some other way like **employee of the month**.

> It is a determination of order of magnitude of a statement.

> It is **indirectly** talking about **logic**.


> While running, the statement will run only **once or one time only**. This **once or one time** is called as **order of magnitude**.

> **Order of magnitude** of a statement means that while running **the statement will be executed by the processor for how many times**. So add **theta** to it  and it will be like **theta(1)** then it is called as the **time complexity**.
 
 > The **order of magnitude** with **theta symbol** is called as **time complexity**.
 
![image](https://user-images.githubusercontent.com/54589605/229303840-d1c8f434-032c-4829-b799-61ffe5cbcd41.png)
![image](https://user-images.githubusercontent.com/54589605/229303934-0a4124ee-a413-45e5-9932-7f79a6c79c4e.png)

> Every **constant** can be represented as **theta(1)**.
 
![image](https://user-images.githubusercontent.com/54589605/229304161-b151ec85-0e26-4aff-9e02-a7c369d48fde.png)
![image](https://user-images.githubusercontent.com/54589605/229304170-fc834516-18d4-46fe-96e8-2cbcfe57f76c.png)

> **1** will be **executed** once only.

![image](https://user-images.githubusercontent.com/54589605/229304857-4f848126-5396-4993-9cb7-376c255bbd16.png)

> So, time complexity is **theta(n)**. We are ignoring the  **small constant**. **Small constant** are nothing but **processor's speed**.

![image](https://user-images.githubusercontent.com/54589605/229305044-dbc08dca-7151-44b0-8db3-708cc2368385.png)

> We don't need to go **inside**. It still gives the **same analysis**.

## Time Complexity-III (3) [2nd April 2023]

> We have **3** statements here

> We are doing **approximate** analysis. Small things(constants) don't matter. Functions matter.

> Inner for loops are nothing but **product rule**.

* Inner loops -> Multiply
* Outer loops -> Add

![image](https://user-images.githubusercontent.com/54589605/229334747-af798f6b-fe13-4adc-9eb5-9478430d40dc.png)

> **Theta** means we can write **Omega and big O**. But **big O** doesn't mean **theta** and **Omega** doesn't mean **theta**.

> **Theta** work means **Omega and big O** will work also. We are not saying **reverse** is possible.

![image](https://user-images.githubusercontent.com/54589605/229334991-150870f6-5a3d-4d4e-b26d-9c6c079dacbd.png)

> According to **Apriori** analysis, **time complexity** is nothing but **finding loops only but also larger loops as well**.

> **Time complexity** is finding **where the cpu is spending the more time**.

> If **no loops** is there in the program **O(1) or constant**

> If **one loop** is there in the program **O(n) or linear**.

* What is kept in the cache memory?

> It doesn't have much storage, so we keep the **valuable content** in it.

* What is the **valuable content**?

> **bigger loops**, because it is the place where CPU spending a lot of time.

![image](https://user-images.githubusercontent.com/54589605/229339523-88dcd9f7-f142-4b1a-8da1-cb5e543d624d.png)
![image](https://user-images.githubusercontent.com/54589605/229339552-ff559af1-fc12-427d-ae30-04325d873e20.png)
![image](https://user-images.githubusercontent.com/54589605/229339577-2e4ad668-2cc8-4bb6-8b86-bd778f8658ad.png)

> In the first loop, condition is **True** for **'n' times**.

> In the fourth loop, condition is **True** for **'n^(1/2) or sqrt(n)' times**.

![image](https://user-images.githubusercontent.com/54589605/229339992-99d7aece-35f9-4103-b075-fd5a84499c44.png)
![image](https://user-images.githubusercontent.com/54589605/229340135-0bb65e07-ec0e-4ef4-8f00-adfb0ebee439.png)
![image](https://user-images.githubusercontent.com/54589605/229340464-e42a3e51-ed88-4ef3-83df-82afe298a2ad.png)

* pf -> printf();

![image](https://user-images.githubusercontent.com/54589605/229340590-0b238405-e873-4e9a-954d-59c4b5d0aac2.png)
![image](https://user-images.githubusercontent.com/54589605/229341332-cfe9cc2f-fcb4-4440-8da6-ae243454325a.png)

> First loop is going on for **k** times where **k=n^(27/5)**. So, that both the sides are **equal**.

![image](https://user-images.githubusercontent.com/54589605/229341399-281e7842-e9fb-4eef-a435-35210423cdb7.png)
![image](https://user-images.githubusercontent.com/54589605/229341576-4cf83bca-6d01-4dad-a118-7a56a7ac876c.png)

> Third loop is going on for **k** times where **k=n^(6/14)**. So, that both the sides are **equal**.

![image](https://user-images.githubusercontent.com/54589605/229341656-b154adc5-2b75-4a1c-821a-4c8b88fa1b16.png)

> **n^7** is bigger as **27/5 -> 5.4** and **6/14 -> 0.4** both are **smaller**.

> Loop is how many time.

![image](https://user-images.githubusercontent.com/54589605/229342051-bdcbb4f5-9752-423c-a75c-4496ef582d5a.png)

> **Recursion** is loop.

![image](https://user-images.githubusercontent.com/54589605/229342062-0bbcec3e-a01a-4477-be62-7118d3852da1.png)

![image](https://user-images.githubusercontent.com/54589605/229342416-7006c3b2-ff8e-4b94-8eef-5fc624e32d80.png)
![image](https://user-images.githubusercontent.com/54589605/229342547-04bad110-ecf7-4be8-8252-668c792219d3.png)
![image](https://user-images.githubusercontent.com/54589605/229342558-909f4fff-12bc-4fe0-af46-7e9f090b3362.png)
![image](https://user-images.githubusercontent.com/54589605/229342563-3a771f6e-9790-4d95-8d2f-d9190639063e.png)
![image](https://user-images.githubusercontent.com/54589605/229342571-ad2faa59-27b0-44e1-846f-4f5458fd4d8a.png)

> **2** loops. **n/5** since **i** is getting **incremented by 5**.

> Always whenever there is an incrementation, then **divide by that incrementation** to get the **time complexity**. In the above question, **i** was incremented by **5** so, the time complexity was **n/5**. If **i** was incremented by **50** then the time complexity will be **n/50**

![image](https://user-images.githubusercontent.com/54589605/229342585-ce510fa1-bdb5-4e0f-82c5-f33496042959.png)
![image](https://user-images.githubusercontent.com/54589605/229342662-61bd79fc-0364-426d-854d-33944558b575.png)
![image](https://user-images.githubusercontent.com/54589605/229342706-08e28d9d-610f-46ee-bcc5-323243b2266b.png)
![image](https://user-images.githubusercontent.com/54589605/229342782-ee653ff3-5fe1-46bc-8e1e-8241b12bb1d5.png)

> Whatever is the **power of n**, just put it in the **time complexity** and the **incrementation** stays the **same**. 

> In the **second while loop**, **i=n** and **i value is increasing**. It is an **infinite** loop. It will not stop. So, **it is not an algorithm** as it is not stopping. It is a program and the time complexity of the program is **infinite**.

![image](https://user-images.githubusercontent.com/54589605/229343139-4045f163-dd95-4ff8-ad7b-40a0a1331abf.png)

> In the first question we started from **big number** as **i=n**, so we have to **decrement or go in decreaseing order**.

> If we started from **small number** like **i=0 or i=1**, then we have to **increment or go in increasing order**.

![image](https://user-images.githubusercontent.com/54589605/229343228-06526dd6-dc6c-4e48-955b-eef4e2e5fa91.png)

> In the **second while loop**, the time complexity is **n**.

![image](https://user-images.githubusercontent.com/54589605/229343274-da5dc060-f3ce-4843-a9ac-a2eb562aaaf2.png)

> In the **second while loop**, the loops runs for **once or one time only**.

![image](https://user-images.githubusercontent.com/54589605/229343421-bb48e8aa-7df9-4cfd-ae9d-3ebec7fc5cc5.png)
![image](https://user-images.githubusercontent.com/54589605/229343426-268ceb68-1c4c-419b-a4b0-3dc38936e79f.png)

* Yes

![image](https://user-images.githubusercontent.com/54589605/229343433-c4efddaa-8586-4fb6-a655-4555a5e490c6.png)
![image](https://user-images.githubusercontent.com/54589605/229343478-8d416473-76f1-429c-a656-d4b337cd4307.png)

> Same only whether **addition or increment** and **substraction or decrement**.

![image](https://user-images.githubusercontent.com/54589605/229343552-f3bde92c-b923-4c18-acf9-eb4b885c725c.png)

> Overall is substraction means the program started with a **big number** i.e **i=n**.

![image](https://user-images.githubusercontent.com/54589605/229343597-837ef707-1b54-4b93-aa25-85fb4bfebe91.png)

> Overall is addition means the program started with a **small number** i.e **i=1 or i=0**.

![image](https://user-images.githubusercontent.com/54589605/229343718-d6a77cea-00ef-4da4-a562-ad8b12996483.png)

> So it is **i=i-50** and **time complexity** is **n/50**. See the overall effect and it is still overall **substraction**, so the program started with a **big number** i.e **i=n**.

![image](https://user-images.githubusercontent.com/54589605/229343796-84e8e8be-64d5-4dc2-9b41-ad3953c0c92f.png)

> So it is **i=i+90** and **time complexity** is **n/90**. See the overall effect and it is still overall **addition**, so the program started with a **small number** i.e **i=1 or i=0**.

> Otherwise for **both** addition and substraction it will case problems of **infinite loops**.

![image](https://user-images.githubusercontent.com/54589605/229343975-2b7c769c-2113-4112-b5e4-fd3b996f385b.png)
![image](https://user-images.githubusercontent.com/54589605/229344013-73f1c7c5-933d-450a-b09c-568f5c50f835.png)

> If the program started with a **big number** i.e **i=n** and we did **i= i+1000** in the **first while loop** then the loop will be **infinite** loop.

![image](https://user-images.githubusercontent.com/54589605/229344177-8acf7b96-a426-4edf-9c02-98f7a013427f.png)

















































