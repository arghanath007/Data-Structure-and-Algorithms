# Algorithms

## Course Link

* Link -> https://unacademy.com/course/complete-course-on-algorithm-768/MKL1PBOY

## Syllabus

![image](https://user-images.githubusercontent.com/54589605/229165900-6a29602a-d898-4e24-ba8c-b402cc2fe2bc.png)


## Time Complexity (1) [31st March 2023]

![image](https://user-images.githubusercontent.com/54589605/229171932-718dbe68-e46e-4d3a-9207-ba295985e033.png)
![image](https://user-images.githubusercontent.com/54589605/229172682-b9f36d76-c52d-48e8-94b1-b39b77cc24c7.png)

> Algorithm is a combination of sequence of finite steps to solve a problem.

> Combination of some(finite) statements.

> Algorithms is a generic programming language. From one language to another language, syntax will change a little bit.

![image](https://user-images.githubusercontent.com/54589605/229176423-2a904b6d-7ac9-4198-b545-c33c994860a3.png)
![image](https://user-images.githubusercontent.com/54589605/229176605-da580b3a-d2b3-4a93-8594-a39d3d26a44d.png)

> After writing the **algorithm**, we can write it in some **programming language** also.

> Algorithm is for **humans**. If we write the algorithm in some **programming language** then the computer will understand.

> We will first write **algorithm** then we will write **program**.

> We have an **algorithm** and we want to convert it into a **programming language**, the programming language we will **choose/prefer** depends on the **use case or what problem it is solving**.

![image](https://user-images.githubusercontent.com/54589605/229180078-515d676f-6e4f-4bee-bcda-7331c2708762.png)

## Programming of Algorithm

> Finite steps doesn't mean finite time.

![image](https://user-images.githubusercontent.com/54589605/229281293-38ed4065-ceb0-4780-93d2-c3050eceb2c7.png)

> It is a program but not an algorithm. Every algorithm is a **program** but every program is not an **algorithm**. Program may halt and may not halt. Program is a **turing machine**. For a problem, algorithm is possible which means **HTM or halt turing machine** is possible.

![image](https://user-images.githubusercontent.com/54589605/229282357-a3fe704d-1501-4054-a8a5-254fd4513ed8.png)

> Algorithm possible means program possible. Program possible doesn't mean algorithm possible. Program contains **infinite loop**.

* Difference between algo and program?

> Program may stop and may not stop. It may go to **infinite loop**. Algorithm has to **stop**. So, algorithm is a **HTM or halt turing machine**.

* Algorithm -> **HTM or halt turing machine** -> It will terminate after finite time.
* Program -> **Turing machine**

![image](https://user-images.githubusercontent.com/54589605/229284887-1973e0f8-56bf-4df2-b297-536a21c086c0.png)
![image](https://user-images.githubusercontent.com/54589605/229286759-629bf52e-d197-41e0-8ddb-e82cd7dc30e7.png)
![image](https://user-images.githubusercontent.com/54589605/229286825-a414e8e6-9eb8-436c-b6cd-b730b3a01259.png)
![image](https://user-images.githubusercontent.com/54589605/229286830-527b2280-b8a7-4520-92f7-6accfcf33014.png)

1) It should terminate after finite time
2) It should provide atleast one output
3) It should be deterministic
4) Every statement in algo should be effective
5) It is independent of **programming language**.

## Time Complexity-II (2) [1st April 2023]

## Steps to design algorithm for given problem

> With them procedures if we construct an algorithm then the properties are satisfied.

![image](https://user-images.githubusercontent.com/54589605/229287724-0cedcdd3-bb21-4f89-9a5e-5ae8ce210566.png)

1) Problem Definition
2) Select designing technique
3) Draw Flowchart
4) Testing
5) Implementation means coding
6) Analysis

> We have **3** designing technique in the syllabus, **Divide and conquor, Greedy and Dynamic programming**. There are **2** more which are not in syllabus, **Backtracking, branch and bound**.

![image](https://user-images.githubusercontent.com/54589605/229289909-51c4fa62-338b-41e4-bb61-454b75f7b46d.png)
![image](https://user-images.githubusercontent.com/54589605/229290767-b5f3187d-8d0f-46c9-bfe2-e51685df4a36.png)
![image](https://user-images.githubusercontent.com/54589605/229290775-9caa7490-667e-4aca-bc7d-b4e93a659269.png)

## Analysis

1) Finding Time and space complexity
2) 

![image](https://user-images.githubusercontent.com/54589605/229291429-c0f0a728-8db9-4a84-87ba-539ac61b0edb.png)

> Better solution will be provided by **analysis**. If **time complexity** is **same** then go for **space complexity**.

![image](https://user-images.githubusercontent.com/54589605/229291609-9b22ec38-09b3-483a-84f6-66f9a3004250.png)

> If the question, simply asks for **which is better**?

* Then give chance to **time** first.

> If the problem having more than one algo?

* Then, the **best one** is decided based on **time complexity(CPU time)** and **space complexity(Main memory)**. 

![image](https://user-images.githubusercontent.com/54589605/229291954-08421313-1964-4260-a96b-fe371dbd3b86.png)
![image](https://user-images.githubusercontent.com/54589605/229292024-04f749de-c1bc-4f97-ad92-571dde3894fb.png)

## Time Complexity

* 'p' is a program 
* Time complexity or T(p) = Compile time or C(p) + Running time or R(p).

![image](https://user-images.githubusercontent.com/54589605/229299347-0bf03c23-4020-44b1-95ef-9d4adfd22510.png)

> **Time complexity of a program** is **based/dependent** on the **language of the compiler and type of processor**.

## Types of Analysis

1) **Aposteriori analysis** -> **Based/Dependent** on the **language of the compiler and type of processor**. Exact answer. Computer-computer time complexity changes.
2) **Apriori analysis** -> **Independent** of the **language of the compiler and type of processor**. Appropriate answer. Same answer in every computer.

![image](https://user-images.githubusercontent.com/54589605/229301833-7e8fddfa-f9a4-426e-a75c-dfffb02db141.png)
![image](https://user-images.githubusercontent.com/54589605/229302215-e54baa48-232c-4b3c-84ba-cde47fabf1c9.png)

> According to **Apriori analysis**, everyone cannot buy **super computer** but everyone can write **super algorithm** because god gave **same  brain** to all.

![image](https://user-images.githubusercontent.com/54589605/229303214-bb14f85c-420c-432f-b7ea-29822503ed5d.png)

> Some poeple use it effictively and some not. Some people believe in themselves and some not.

## Apriori analysis

> Instead of saying **best logic**, they are saying it in some other way like **employee of the month**.

> It is a determination of order of magnitude of a statement.

> It is **indirectly** talking about **logic**.


> While running, the statement will run only **once or one time only**. This **once or one time** is called as **order of magnitude**.

> **Order of magnitude** of a statement means that while running **the statement will be executed by the processor for how many times**. So add **theta** to it  and it will be like **theta(1)** then it is called as the **time complexity**.
 
 > The **order of magnitude** with **theta symbol** is called as **time complexity**.
 
![image](https://user-images.githubusercontent.com/54589605/229303840-d1c8f434-032c-4829-b799-61ffe5cbcd41.png)
![image](https://user-images.githubusercontent.com/54589605/229303934-0a4124ee-a413-45e5-9932-7f79a6c79c4e.png)

> Every **constant** can be represented as **theta(1)**.
 
![image](https://user-images.githubusercontent.com/54589605/229304161-b151ec85-0e26-4aff-9e02-a7c369d48fde.png)
![image](https://user-images.githubusercontent.com/54589605/229304170-fc834516-18d4-46fe-96e8-2cbcfe57f76c.png)

> **1** will be **executed** once only.

![image](https://user-images.githubusercontent.com/54589605/229304857-4f848126-5396-4993-9cb7-376c255bbd16.png)

> So, time complexity is **theta(n)**. We are ignoring the  **small constant**. **Small constant** are nothing but **processor's speed**.

![image](https://user-images.githubusercontent.com/54589605/229305044-dbc08dca-7151-44b0-8db3-708cc2368385.png)

> We don't need to go **inside**. It still gives the **same analysis**.

## Time Complexity-III (3) [2nd April 2023]

> We have **3** statements here

> We are doing **approximate** analysis. Small things(constants) don't matter. Functions matter.

> Inner for loops are nothing but **product rule**.

* Inner loops -> Multiply
* Outer loops -> Add

![image](https://user-images.githubusercontent.com/54589605/229334747-af798f6b-fe13-4adc-9eb5-9478430d40dc.png)

> **Theta** means we can write **Omega and big O**. But **big O** doesn't mean **theta** and **Omega** doesn't mean **theta**.

> **Theta** work means **Omega and big O** will work also. We are not saying **reverse** is possible.

![image](https://user-images.githubusercontent.com/54589605/229334991-150870f6-5a3d-4d4e-b26d-9c6c079dacbd.png)

> According to **Apriori** analysis, **time complexity** is nothing but **finding loops only but also larger loops as well**.

> **Time complexity** is finding **where the cpu is spending the more time**.

> If **no loops** is there in the program **O(1) or constant**

> If **one loop** is there in the program **O(n) or linear**.

* What is kept in the cache memory?

> It doesn't have much storage, so we keep the **valuable content** in it.

* What is the **valuable content**?

> **bigger loops**, because it is the place where CPU spending a lot of time.

![image](https://user-images.githubusercontent.com/54589605/229339523-88dcd9f7-f142-4b1a-8da1-cb5e543d624d.png)
![image](https://user-images.githubusercontent.com/54589605/229339552-ff559af1-fc12-427d-ae30-04325d873e20.png)
![image](https://user-images.githubusercontent.com/54589605/229339577-2e4ad668-2cc8-4bb6-8b86-bd778f8658ad.png)

> In the first loop, condition is **True** for **'n' times**.

> In the fourth loop, condition is **True** for **'n^(1/2) or sqrt(n)' times**.

![image](https://user-images.githubusercontent.com/54589605/229339992-99d7aece-35f9-4103-b075-fd5a84499c44.png)
![image](https://user-images.githubusercontent.com/54589605/229340135-0bb65e07-ec0e-4ef4-8f00-adfb0ebee439.png)
![image](https://user-images.githubusercontent.com/54589605/229340464-e42a3e51-ed88-4ef3-83df-82afe298a2ad.png)

* pf -> printf();

![image](https://user-images.githubusercontent.com/54589605/229340590-0b238405-e873-4e9a-954d-59c4b5d0aac2.png)
![image](https://user-images.githubusercontent.com/54589605/229341332-cfe9cc2f-fcb4-4440-8da6-ae243454325a.png)

> First loop is going on for **k** times where **k=n^(27/5)**. So, that both the sides are **equal**.

![image](https://user-images.githubusercontent.com/54589605/229341399-281e7842-e9fb-4eef-a435-35210423cdb7.png)
![image](https://user-images.githubusercontent.com/54589605/229341576-4cf83bca-6d01-4dad-a118-7a56a7ac876c.png)

> Third loop is going on for **k** times where **k=n^(6/14)**. So, that both the sides are **equal**.

![image](https://user-images.githubusercontent.com/54589605/229341656-b154adc5-2b75-4a1c-821a-4c8b88fa1b16.png)

> **n^7** is bigger as **27/5 -> 5.4** and **6/14 -> 0.4** both are **smaller**.

> Loop is how many time.

![image](https://user-images.githubusercontent.com/54589605/229342051-bdcbb4f5-9752-423c-a75c-4496ef582d5a.png)

> **Recursion** is loop.

![image](https://user-images.githubusercontent.com/54589605/229342062-0bbcec3e-a01a-4477-be62-7118d3852da1.png)

![image](https://user-images.githubusercontent.com/54589605/229342416-7006c3b2-ff8e-4b94-8eef-5fc624e32d80.png)
![image](https://user-images.githubusercontent.com/54589605/229342547-04bad110-ecf7-4be8-8252-668c792219d3.png)
![image](https://user-images.githubusercontent.com/54589605/229342558-909f4fff-12bc-4fe0-af46-7e9f090b3362.png)
![image](https://user-images.githubusercontent.com/54589605/229342563-3a771f6e-9790-4d95-8d2f-d9190639063e.png)
![image](https://user-images.githubusercontent.com/54589605/229342571-ad2faa59-27b0-44e1-846f-4f5458fd4d8a.png)

> **2** loops. **n/5** since **i** is getting **incremented by 5**.

> Always whenever there is an incrementation, then **divide by that incrementation** to get the **time complexity**. In the above question, **i** was incremented by **5** so, the time complexity was **n/5**. If **i** was incremented by **50** then the time complexity will be **n/50**

![image](https://user-images.githubusercontent.com/54589605/229342585-ce510fa1-bdb5-4e0f-82c5-f33496042959.png)
![image](https://user-images.githubusercontent.com/54589605/229342662-61bd79fc-0364-426d-854d-33944558b575.png)
![image](https://user-images.githubusercontent.com/54589605/229342706-08e28d9d-610f-46ee-bcc5-323243b2266b.png)
![image](https://user-images.githubusercontent.com/54589605/229342782-ee653ff3-5fe1-46bc-8e1e-8241b12bb1d5.png)

> Whatever is the **power of n**, just put it in the **time complexity** and the **incrementation** stays the **same**. 

> In the **second while loop**, **i=n** and **i value is increasing**. It is an **infinite** loop. It will not stop. So, **it is not an algorithm** as it is not stopping. It is a program and the time complexity of the program is **infinite**.

![image](https://user-images.githubusercontent.com/54589605/229343139-4045f163-dd95-4ff8-ad7b-40a0a1331abf.png)

> In the first question we started from **big number** as **i=n**, so we have to **decrement or go in decreaseing order**.

> If we started from **small number** like **i=0 or i=1**, then we have to **increment or go in increasing order**.

![image](https://user-images.githubusercontent.com/54589605/229343228-06526dd6-dc6c-4e48-955b-eef4e2e5fa91.png)

> In the **second while loop**, the time complexity is **n**.

![image](https://user-images.githubusercontent.com/54589605/229343274-da5dc060-f3ce-4843-a9ac-a2eb562aaaf2.png)

> In the **second while loop**, the loops runs for **once or one time only**.

![image](https://user-images.githubusercontent.com/54589605/229343421-bb48e8aa-7df9-4cfd-ae9d-3ebec7fc5cc5.png)
![image](https://user-images.githubusercontent.com/54589605/229343426-268ceb68-1c4c-419b-a4b0-3dc38936e79f.png)

* Yes

![image](https://user-images.githubusercontent.com/54589605/229343433-c4efddaa-8586-4fb6-a655-4555a5e490c6.png)
![image](https://user-images.githubusercontent.com/54589605/229343478-8d416473-76f1-429c-a656-d4b337cd4307.png)

> Same only whether **addition or increment** and **substraction or decrement**.

![image](https://user-images.githubusercontent.com/54589605/229343552-f3bde92c-b923-4c18-acf9-eb4b885c725c.png)

> Overall is substraction means the program started with a **big number** i.e **i=n**.

![image](https://user-images.githubusercontent.com/54589605/229343597-837ef707-1b54-4b93-aa25-85fb4bfebe91.png)

> Overall is addition means the program started with a **small number** i.e **i=1 or i=0**.

![image](https://user-images.githubusercontent.com/54589605/229343718-d6a77cea-00ef-4da4-a562-ad8b12996483.png)

> So it is **i=i-50** and **time complexity** is **n/50**. See the overall effect and it is still overall **substraction**, so the program started with a **big number** i.e **i=n**.

![image](https://user-images.githubusercontent.com/54589605/229343796-84e8e8be-64d5-4dc2-9b41-ad3953c0c92f.png)

> So it is **i=i+90** and **time complexity** is **n/90**. See the overall effect and it is still overall **addition**, so the program started with a **small number** i.e **i=1 or i=0**.

> Otherwise for **both** addition and substraction it will case problems of **infinite loops**.

![image](https://user-images.githubusercontent.com/54589605/229343975-2b7c769c-2113-4112-b5e4-fd3b996f385b.png)
![image](https://user-images.githubusercontent.com/54589605/229344013-73f1c7c5-933d-450a-b09c-568f5c50f835.png)

> If the program started with a **big number** i.e **i=n** and we did **i= i+1000** in the **first while loop** then the loop will be **infinite** loop.

![image](https://user-images.githubusercontent.com/54589605/229344177-8acf7b96-a426-4edf-9c02-98f7a013427f.png)

## Doubt Clearing Session (4) [2nd April 2023]

![image](https://user-images.githubusercontent.com/54589605/229349862-73b2a70e-6345-4fc6-a4a7-06a0f10ce3cc.png)
![image](https://user-images.githubusercontent.com/54589605/229349870-1d8e505c-9c32-4385-93b5-276e711caf20.png)

> First for loop is **increasing** and the second for loop is **decreasing**. One is **increasing** and one is **decreasing** but both are taking the **same time**.

> After **K times**, we got **2^K=n**, which is the last iteration of the **first for** loop. So, after applying **log** on both the sides, we got **K= log n base 2**. So, the **time complexity** for the **first for** loop is **O(log n base 2)**.

![image](https://user-images.githubusercontent.com/54589605/229350276-a7762caf-8950-4e42-bea4-58086221325c.png)
![image](https://user-images.githubusercontent.com/54589605/229350290-e4eec45f-df14-4ce8-a0d6-f17caab10565.png)

> Everytime, **i** is **increasing by double**, then the time complexity is **O(log n base 2)**.

![image](https://user-images.githubusercontent.com/54589605/229351964-f76521c9-f06a-4c52-933b-0209f75b8f93.png)
![image](https://user-images.githubusercontent.com/54589605/229352028-9ec44231-d60d-4da0-8211-43f15bb3a7e9.png)
![image](https://user-images.githubusercontent.com/54589605/229352197-e49c3b0d-5bd4-4ee3-841d-1f7d21f3f4f5.png)

> If we **divide by 2 or multiply by 2**, the value of **i** when incrementing the value of **i**, then the **time complexity** will be **O(log n base 2)**.

> If we **divide by x or multiply by x**, the value of **i** when incrementing the value of **i**, then the **time complexity** will be **O(log n base x)**.

![image](https://user-images.githubusercontent.com/54589605/229352430-a212e56c-4125-4f70-b31a-97af79c87eab.png)

> **i=5 * i and i=12 * 1**, we wrote together, then the **i** value is **incremented** by **i= 60 * i**. Then the **time complexity** is **O(log n base 60)**.  

![image](https://user-images.githubusercontent.com/54589605/229352593-76da8a14-da18-4045-a3f3-715a046bbb1d.png)
![image](https://user-images.githubusercontent.com/54589605/229352717-07dc02b0-a0d7-4e0f-89d1-97695a4517b8.png)
![image](https://user-images.githubusercontent.com/54589605/229352818-45696cfa-6bf3-4d31-8e1d-892258d6766c.png)
![image](https://user-images.githubusercontent.com/54589605/229352948-2cc2ba3b-42bd-4bb1-b644-53ab5a5ae2d6.png)
![image](https://user-images.githubusercontent.com/54589605/229353768-9cecc04f-d127-4e07-a8aa-f432fc142c29.png)

> **log n base 2** is bigger. Whichever base is **small**, we will take that.

![image](https://user-images.githubusercontent.com/54589605/229353802-b930c798-068b-4998-b7fc-d61dce895be8.png)
![image](https://user-images.githubusercontent.com/54589605/229353807-3bc17e59-dd76-4574-9e2c-e51b06178815.png)
![image](https://user-images.githubusercontent.com/54589605/229353886-12398664-8899-4b9b-ae87-e7060ef5de00.png)
![image](https://user-images.githubusercontent.com/54589605/229355507-22d62859-86f3-4d52-9f45-215b225027c6.png)
![image](https://user-images.githubusercontent.com/54589605/229355571-2ac9850f-87d9-4df9-bfc4-00e347821c51.png)
![image](https://user-images.githubusercontent.com/54589605/229355617-faaede82-e486-4f95-a3cb-5ff50566476b.png)
![image](https://user-images.githubusercontent.com/54589605/229355673-97455b13-01f0-41f5-9a2b-dab0439cc142.png)
![image](https://user-images.githubusercontent.com/54589605/229355727-8e9d3755-47fe-4e10-9a08-8ed24f0649ac.png)

> For the first loop, it is **incrementing** as it has started from **smaller value** ie **i=1**.

> For the second loop, it is **decrementing** as it has started from **bigger value** ie **j=n**.

> What is the **overall effect** we have to check.

* **Add and sub** -> n/2 or n/5 etc. -> These loops are **bigger** than the **log** loops below.
* **Div and Mul** -> log n base 2 or log n base 20 etc. -> These loops are **smaller** but **faster** than above loops.

> For multiplication, multiply the **numbers** only and for **division**, divide the **numbers** only.

> **Less time complexity**, loop is repeating **less**, the **better**. So **log** is better than **Add and sub** -> n/2 or n/5**.

> Loop should repeat **minimum** time as possible.

![image](https://user-images.githubusercontent.com/54589605/229356272-5fe38aba-dc13-4fa8-93e6-ac19c717653e.png)

* O(log n base 35) [Ans]

![image](https://user-images.githubusercontent.com/54589605/229356507-ba125e31-6ab7-432b-b6ed-d1395bbc487d.png)

> As starting value of **i=5** and it will not affect that much as **5** is a **constant** value, we can ignore it.

> For **multiplication**, the **reverse** is **division** and vice-versa.

> For **addition**, the **reverse** is **substraction** and vice-versa.

> If we do **multiplication and addition** togerther then we get **7007** which is closer to **multiplication** and it gave **7000**. For the **addition**, we got **1007**. So,  **multiplication and addition** togerther is approximately equal to **multiplication**. Exactly not possible.

![image](https://user-images.githubusercontent.com/54589605/229357155-9466c0e2-4fc6-4c01-9515-4cf03176d88e.png)
![image](https://user-images.githubusercontent.com/54589605/229357239-d6743186-915a-4b1c-9ad4-910dfd2e815a.png)

> So **multiplication** is faster than **addition**, that's why it is affecting more and for **addition**, it is affecting in **constant** values.

![image](https://user-images.githubusercontent.com/54589605/229357689-4c9500e2-72a2-40de-a193-c632f8e118bc.png)
![image](https://user-images.githubusercontent.com/54589605/229357956-e58bff4c-5dd1-49bc-b664-cdcefdb45802.png)

[**IMPORTANT**]

* i + 2 -> n/2
* i * 2 -> log n base 2
* i * i or i^2 -> log(log n)

![image](https://user-images.githubusercontent.com/54589605/229358415-4b380b13-4c16-4a0e-a484-0ea122ea6aee.png)
![image](https://user-images.githubusercontent.com/54589605/229358602-865544b6-6614-462f-a331-44849290a8e0.png)
![image](https://user-images.githubusercontent.com/54589605/229358750-549d09b4-028a-48db-b3a7-1332c5e325a9.png)

![image](https://user-images.githubusercontent.com/54589605/229359090-e9f13bdd-7796-48e4-8596-205a4cf96039.png)

> The **time complexity** is **log(log n base 2) base 10**. 

> Because the **initial value** of **i** is **i=2**, so the **inner base** is **2** as it has come **before/earlier**. At the end the **power** of **i** is **i^10**, so the **outer base** is **10** as it has come **after/later**.

> This is how we got the **time complexity** of **log(log n base 2) base 10**. 

![image](https://user-images.githubusercontent.com/54589605/229359259-d856333b-c5e8-4bd5-ae05-2092c4c079f3.png)
![image](https://user-images.githubusercontent.com/54589605/229359296-a63b614a-ba6d-489c-abd9-8109f750df01.png)

> The **time complexity** is **log(log n base 2) base 30**. Even if we add **i= i =7** in the for loop, it has very small effect which is **some constant**. So, the result remains **same** still. It is **baccha** only.

![image](https://user-images.githubusercontent.com/54589605/229359399-249e129c-0a6a-489b-a1d2-95912b6d29e9.png)

> If we also include **i= i * 7**, then also the result remains the **same** as it has very small effect which is **some constant**. It is **baccha** only

![image](https://user-images.githubusercontent.com/54589605/229359506-85a8a026-06e9-41f6-9e9a-cd956c337594.png)
![image](https://user-images.githubusercontent.com/54589605/229359522-a014b913-19d9-4b63-b6d4-20779aaaab8a.png)

> **log(log n)** is faster compared to **n/2 or log n**. So **log(log n)** is dominating the **time complexity** value compared to them. Every oen is **participating** but **log(log n)** is dominating. So, **overall**, **time complexity** remains the **same** which is **log(log n base 2) base 30**.

> **Constants** doesn't have much effects.

* 9 * 6 * 5/(9) -> 6 * 5 -> 30 
* log(log n base 1500) base 30

> So, we got **log(log n base 1500) base 30** as the **time complexity** value.

> Because the **initial value** of **i** is **i=1500**, so the **inner base** is **1500** as it has come **before/earlier**. At the end the **power** of **i** is **i^30**, so the **outer base** is **30** as it has come **after/later**.

> This is how we got the **time complexity** of **log(log n base 1500) base 30**. 

![image](https://user-images.githubusercontent.com/54589605/229360322-f893ef84-4f51-4192-beff-e6a088cab979.png)
![image](https://user-images.githubusercontent.com/54589605/229360445-870e27a9-188d-49a7-b948-9fb67861ba25.png)

> Answer will be **same** only even if we remove **less than equal to** to **less than** only. As **i^9 or i^6 or i^(1/9)** have the **highest power** compared to **add, mul and divide** that why they are dominating here. We have **ignored** the **rest**.

## Asymptotic Notation-I (5) [3rd April 2023]

> As **i** is starting from a **larger no.**, **i=n**, hence the **overall** effect should be **decreasing or decrement**.

* 5 * 4 / 3 * 15 * 25 -> 4/ 9 * 25 -> 4/225
* log(log n base 2) base 4/225

![image](https://user-images.githubusercontent.com/54589605/229436098-855e308e-58d4-4fd2-bffa-aa5598aa3b09.png)

> So, we got **log(log n base 2) base 4/225** as the **time complexity** value.

> Because the **initial value** of **i** is **i=n**, so it has a **greater value**, so now we have to check the **initial value** where the **condition** ends, which is **i >=2**. So the **inner base** is **2** as it has come **before/earlier**. At the end the **power** of **i** is **i^(4/225)**, so the **outer base** is **4/225** as it has come **after/later**.

> This is how we got the **time complexity** of **log(log n base 2) base 4/225**. 

> This is also **wrong** because of the **below proof**.

![image](https://user-images.githubusercontent.com/54589605/229445145-f47c35d0-3c16-4869-9553-a0a4822a08f1.png)
![image](https://user-images.githubusercontent.com/54589605/229446072-049a5c25-8c90-4c6c-bf62-8f3f146ecc24.png)
![image](https://user-images.githubusercontent.com/54589605/229446245-bf099211-58f3-44f9-abb7-cd1f5aac3adf.png)
![image](https://user-images.githubusercontent.com/54589605/229451172-5cb10e53-0796-4fed-8c8e-cd47d89ff4fb.png)

> So, the **time complexity** is  **O(log(log n base 2) base 255/4)**.


![image](https://user-images.githubusercontent.com/54589605/229436734-f0c42dd7-a885-4b66-8281-5b86b20d82cd.png)

> If we got final value of **i** as **i^(1/2)**. Then, the **time complexity** is **O(log(log n base 2) base 1/2**.

> But **sir** is saying it should be **O(log(log n base 2) base 2**. Let's see his **proof** for these solution.

![image](https://user-images.githubusercontent.com/54589605/229438172-40197edc-20df-4d56-b7fc-1ea12be76696.png)
![image](https://user-images.githubusercontent.com/54589605/229451172-5cb10e53-0796-4fed-8c8e-cd47d89ff4fb.png)

> Here is the **proof** why we are getting **base 2** in **outer** base even though **i^(1/2)**. So, remember when we get **1/2** as the **power** then put **2** as the base. In the proof we got **O(log(log n base 2) base 2**, so for **i^(1/2)** we got **time complexity** as **O(log(log n base 2) base 2** and not **O(log(log n base 2) base 1/2**, which we thought **initially**. 

> If it is **i^(1/2)** then it is **ulta/opposite** i.e **base 2** as the **outer base**.

![image](https://user-images.githubusercontent.com/54589605/229447306-8acf58ba-a21c-46ea-bac2-7b69ab6f6815.png)

> For **square**, reverse is **root**. They(square and root) both are the **same**. So, **i^(1/2)** is **root** only.

> Initially **i=n** and after **k times**, it is **n^(1/2^k) = 2**, which is the **termination** condition for the loop. We want the **k** value as it has looped for **k times**. So after applying **log**, we get **1/(2^k) * log n base 2=1**. So, **log n base 2 = 2^k** and after applying another **log**, we got **k = log(log n base 2) base 2**.

![image](https://user-images.githubusercontent.com/54589605/229451172-5cb10e53-0796-4fed-8c8e-cd47d89ff4fb.png)
![image](https://user-images.githubusercontent.com/54589605/229448219-3d9d39f6-5d57-47b9-8358-5f46bd4f9598.png)

> Initially **i=n** and after **k times**, it is **n^(4/255)^k = 2**, which is the **termination** condition for the loop. We want the **k** value as it has looped for **k times**. So after applying **log**, we get **(4/255)^k * log n base 2=1**. So, **log n base 2 = (255/4)^k** and after applying another **log**, we got **k = log(log n base 2) base 255/4**.

![image](https://user-images.githubusercontent.com/54589605/229450647-f70a7f71-4b00-4dd4-8d88-2fd6be134bbd.png)
![image](https://user-images.githubusercontent.com/54589605/229449100-7c669f9a-baf4-43e0-807c-e740f6f2681e.png)

> So, when we are doing **i^20** and the **initial value** is **i=2**, the time complexity is **log(log n base 2) base 20**.

> So, when we are doing **i^65** and the **initial value** is **i=2**, the time complexity is **log(log n base 2) base 65**.

> It is similar for **root** also. So, when we are doing **i^(1/2)** and the **initial value** for the **termination** condition for the loop is **i=2**, the time complexity is **log(log n base 2) base 2**. So, **reverse** is happening.

![image](https://user-images.githubusercontent.com/54589605/229454189-cfd8032b-7ca6-4f4e-8041-4ee4b8c58a7a.png)

> If we add **i= i + 75**, then also the **result** remains the **same** as  it has **very small effect**. If we add **i= i * 75**, then also the **result** remains the **same** as  it has **very small effect**.

![image](https://user-images.githubusercontent.com/54589605/229454633-edbc6237-8d4f-4db1-8dab-e56c1877d019.png)

> So, if the  **initial value** for the **termination** condition for the loop is **i=23**, then we get **n^(4/225)^k = 23**. Hence, the value of **k= log(log n base 23) base 255/4)**. So, the **time complexity** is **O(log(log n base 23) base 255/4)**.

> Try to understand what is **happening**. **Time complexity** means **how many times the loop is running and what is happening within the loop**.

## GATE Questions

* Find **time complexity** and **value of q**.

> For the first loop, the **time complexity** is **log n base 2** and **p** value is **incrementing everytime**. The loop is repeating **log n base 2** time and **p** is **incrementing everytime**. So, **p** value is **p= log n base 2** only. So, how many times the loop is repeating that many times only **p** is incremented.

> After the end of the first loop, **p= log n**.

> For the second for loop, the **time complexity** is **log p base 2 -> log(log n base 2) base 2**. The second loop is **log p** time and not **log n** times as **j <=p** is the condition.

> As from the first for loop, we gathered whatever is the **time complexity**, that value is the value of **p**. So, here in the second for loop as well, whatever is the **time complexity**, that value is the value of **q** which is **q= log(log n base 2) base 2**.

![image](https://user-images.githubusercontent.com/54589605/229472063-cd52d5b5-b7f4-4acb-9bcd-3553238a8382.png)
![image](https://user-images.githubusercontent.com/54589605/229484717-2e29daf4-7aff-4e5c-b8d4-47f9372e097b.png)
![image](https://user-images.githubusercontent.com/54589605/229488396-fec7b740-17de-42ce-86c1-38250c7cccb5.png)
![image](https://user-images.githubusercontent.com/54589605/229488623-74c42aee-b4d5-401a-9084-479fccb4ec2e.png)

> This is for when we have many values within **one** loop only. If we have **add and mul** within one loop then **mul** will be **faster** than **add**, so it will have much more effect than **add**. That's why we ignored **add** in that case and took the **faster value**.

> When finding **time complexity**, then we have to take the larger value like **log n > log(log n)** in the above example as if **n=16**, then **log 16 -> 4** and **log(log 16) -> log 4 -> 2**. As **4 > 2** which means **log n > log(log n)**. Hence we took **log n** as the **time complexity** in the above question.

[**IMPORTANT**]

> They are **two** different loops and they are **outer** loops, when **outer** loops, take the **larger one**.

![image](https://user-images.githubusercontent.com/54589605/229489833-b7094cbd-6aa4-491f-9e0b-85eba2b46e68.png)
![image](https://user-images.githubusercontent.com/54589605/229491861-8bd6410e-4516-4b4c-a3f5-b48bfabcd48a.png)

> Time complexity is **O(nlog n)** because the time complexity between the inner for loops is **log n** but the outer for loop is running for **n times**. So, it is **O(nlog n)**. The **q** value remains the same because every in the outer for loop, **p and q** are initialized by 0 only.

* return -> Get out of the function.
* exit -> Get out of the entire program or stop the program.

![image](https://user-images.githubusercontent.com/54589605/229493160-63908197-026f-4d08-a8a0-99c5c291754f.png)
![image](https://user-images.githubusercontent.com/54589605/229498658-742e3bc2-fa3f-45f9-810f-bd4a613428e1.png)
![image](https://user-images.githubusercontent.com/54589605/229499000-3e3da2fb-eaac-42a5-916a-1dffa2725d37.png)

> If **q=0** was within the first for loop like **p=0**, then the **q** value would have been **q= log n**, as after every loop, q value would have been initialized with **q=0** only.

* break -> outside loop or out of the loop.
* return -> outside the function(same as above), just different wording.
* exit -> program stops

![image](https://user-images.githubusercontent.com/54589605/229500169-d964c9f0-4f2e-4d42-83e5-4f6cc08b0848.png)

> For the first loop, time complexity is **log n^2 base 7** as the termination condition for the loop is **i <= n^2** that why.

> For the second loop, time complexity is **log n^2 base 7** as the termination condition for the loop is **i <= n^2** that why.

![image](https://user-images.githubusercontent.com/54589605/229502823-f7f097b7-0546-41d8-ac04-33e012c59105.png)
![image](https://user-images.githubusercontent.com/54589605/229503671-6dbfb9a4-7dae-4fee-ad9c-5ed7fdce71e4.png)

> Both are correct if we ignore the **constants**. Check which is given in the **options** of the question. Choose that one.

![image](https://user-images.githubusercontent.com/54589605/229505160-0a9114d3-7db8-4966-a2fe-94414755cf50.png)

> For the **value of x**, as the **inner loop** is repeating **log n** times and every time **n** is getting added so **n log n** but the **outer loop** is also there which is **log n** times. So, value of **x = log n * nlogn -> n * (log n)^2**.

![image](https://user-images.githubusercontent.com/54589605/229505864-77653c1c-7b46-4776-8359-026cf1ded495.png)
![image](https://user-images.githubusercontent.com/54589605/229506380-2c667974-8038-47a7-b56c-ee41add96fe9.png)

> If we have replaced the variable **n** in **x= x + n** with **x=x+1**, then the **value of x** is **log n * log n -> (log n)^2**. As the inner loop runs for **log n** times and the outer loop also runs for **log n** times.

> By replacing **n** with **1**, the **value** is changing only. The **time complexity** is **same** only. Time complexity will only change when loops are **increasing or decreasing**.

![image](https://user-images.githubusercontent.com/54589605/229507869-3706aefb-48c6-478e-961e-9066f9677571.png)

> Even if we put **0**, then also only the **value** changes. The **time complexity** remains **same** only.

> In **power**, constants matter, don't ignore them there.

![image](https://user-images.githubusercontent.com/54589605/229513967-e69ba091-bc02-4051-b9b2-f326e8cae36b.png)
![image](https://user-images.githubusercontent.com/54589605/229516312-1b66d5e2-7d55-4c94-812d-9252496a1841.png)
![image](https://user-images.githubusercontent.com/54589605/229516249-abe8a073-a836-4692-b8fe-199d8467ff15.png)
![image](https://user-images.githubusercontent.com/54589605/229516472-ecd2a386-997a-4998-b6a4-a7f951ad85c5.png)
![image](https://user-images.githubusercontent.com/54589605/229516823-dd337e48-f32b-45e3-bfc0-cf7bc2aaf8f7.png)

> If both the loops have **n** complexity then the value of **x** will be **n^(n^2)**. As **j** loop has run **n** times and each time **n** is multiplied to **x** then the value of **x** after whole of **j** loop is **n * n -> n^2**. So, **n * n -> n^2** will be for each loop of **i**, so for **n** loops of **i**, we get **n^(n^2)**.

![image](https://user-images.githubusercontent.com/54589605/229517864-ec76b7f1-355f-474e-b50b-339c380ea928.png)
![image](https://user-images.githubusercontent.com/54589605/229518106-566ea1c0-95dd-4296-a20f-3781f41d598d.png)

> So multiply **n^(1.57) * log n^7 base 8** and that is the **answer** for the given question.

![image](https://user-images.githubusercontent.com/54589605/229521532-a59fcc11-2c5d-4a57-a2f7-3aea51a22d12.png)
![image](https://user-images.githubusercontent.com/54589605/229521845-0e5338df-6e86-4b3a-b21d-5a71d2a0d21c.png)

> If **x=0**, then **0 * anything -> 0**. So, the value of **x** will be **0** only.

> There are **2** loops in the program. They are **inner** loops as **j** has come before **i** has completely stopped. AS they are **inner**, so we have to **multiply**.

> As **n** is a **prime no**, it has **only two factors** i.e **1 and itself**. So, for all the values of **i**, only **two** values will enter the **j** loop.

![image](https://user-images.githubusercontent.com/54589605/229525351-ff33b8a5-6dd6-41ee-bbef-a6f69111cc9b.png)
![image](https://user-images.githubusercontent.com/54589605/229525731-040aacb7-feb2-44be-b5c6-80d8d319ce75.png)
![image](https://user-images.githubusercontent.com/54589605/229525849-0890ab9c-f0e7-44d9-9b18-11c4d9d74a46.png)

> Even though there are **two** loops and they are **inner** loops. We only got **time complexity** as **O(n)** as there is an **if** condition which is stopping most of the **i** iterations to go to **j** loop. Everyone not allowed into **j** loop. Because of **n** being **prime number**, only **two** values can go into **j** loop.

![image](https://user-images.githubusercontent.com/54589605/229526008-c669800a-d873-4aac-b86f-e4a726abf724.png)

> If we remove the **condition** then the **time complexity** as **O(n^2)*.

![image](https://user-images.githubusercontent.com/54589605/229610057-63d39edf-fc3e-4f3f-a04c-444b937b3a20.png)
![image](https://user-images.githubusercontent.com/54589605/229610083-5ed96e12-f13e-4771-a543-08de173875e7.png)
![image](https://user-images.githubusercontent.com/54589605/229610117-fa09f375-4011-419e-94f8-78919579c1e2.png)
![image](https://user-images.githubusercontent.com/54589605/229610141-f21463be-d26d-4661-bec2-2d524e5a91cf.png)
![image](https://user-images.githubusercontent.com/54589605/229610164-75e7104b-2869-4289-9ef0-39b018acd540.png)
![image](https://user-images.githubusercontent.com/54589605/229610188-cb14c423-f0bd-4327-b9d6-0d282bf3ea82.png)
![image](https://user-images.githubusercontent.com/54589605/229610201-9735d2e5-c655-43d4-a010-b63421294136.png)



## Asymptotic Notation-II (6) [3rd April 2023]

### Time Complexity Questions continued

> There are **two** loops and they are **inner** loops. In **j** loop, it is dependent on **i**. Without mentioning **i**, we cannot define **j**. As **j** is dependent on **i**, or when **one** is dependent on **another** then we can't write them individually. We have to write them **combinedly** only.

> Based on the **dependency**, we cannot **divide**. Based on **i**, **j** will come. **j** is how many times? **i** times. Whenever there is a  **dependency**, we cannot **separate** them. We have to take **both** of them into consideration.

![image](https://user-images.githubusercontent.com/54589605/229578017-d9cf42fd-595f-4dac-a768-e6fe24d3e71d.png)

> If **n terms** are there then **each term** is **one loop**. We are getting the **terms** because of the **combination of i and j**. **i** will say how many loops. **j** will say every loop how many time.

![image](https://user-images.githubusercontent.com/54589605/229582397-11aa207b-9eb5-49a1-82e5-74d4f01e91f2.png)
![image](https://user-images.githubusercontent.com/54589605/229582500-1649aff7-3fc2-4944-aa2d-eb9e7deee18f.png)

> So, the **time complexity** will be **O(n^2)**.

> If **i=1**, then **j** loops  **one** time only.

![image](https://user-images.githubusercontent.com/54589605/229582790-576b0543-4ea8-4511-bcdf-a951bbc99c86.png)

> Instead of **i**, we have put **n** in the **j** loop, then also we would get **O(n^2)** as the **time complexity** which is the **same** as before. But in the **above question**, the actual answer is **n(n+1)/2** but we are simply ignoring the **constants**. So we get **O(n^2)**.

> For the **2nd question** we get **O(n^2) or n * n**, which is the actual correct solution. So they are not the same solutions.

> So the symbol we write on the right hand side which is the **Theta**, are simply **approximation**. But before **Theta**, whatever we write that's the **actual** solution.

> We are **approximating** because the **actual values** differ from system to system, if the system is **slower** then we could get **n(n+1)/2^t** or if the system is **faster** then we could get **n(n+1)/1.2**. So the **actual** answer is varrying with **constant** values. That's why we use **approximations**.

> So the **actual value**, **n(n+1)/2** will change from system to system. It could be **n(n+1)/20** or **n(n+1)/200** or **n(n+1)/2000000**. They keep on **changing**, but in every system one thing is **common** that is **n^2**. **Constant factor** will only **change**. This is the **meaning** of **Theta(n^2)**. From system to system in the **actual answers**, the **constant** factor can **change**. But one thing is **common** in every system which is **n^2**. Some constant factor **n^2**.

![image](https://user-images.githubusercontent.com/54589605/229583693-5e948183-2cc2-43d7-98a6-29e60a59197b.png)

* 1 + 4 + 9 + ........ + n^2 -> Series

* Above series explaination -> https://math.stackexchange.com/questions/1544526/the-sum-of-the-first-n-squares-1-4-9-cdots-n2-is-fracnn12

![image](https://user-images.githubusercontent.com/54589605/229589693-8d7753ca-fa17-402d-bc97-4385e90ca287.png)

> So it givens **n^3**. Hence the time complexity is **Theta(n^3)**. So, in every system **n^3** is **common**.

![image](https://user-images.githubusercontent.com/54589605/229590344-6a20a21d-ba93-4b54-960f-b69ba8ee783d.png)

> The loop is **dependent** on **s**. **s** is always incremented by **i**, but **i** is always incremented by **1**. After doing **k times**, the total sum is equal to **n**.

![image](https://user-images.githubusercontent.com/54589605/229593178-08f36cd9-065c-4bc8-8513-bfe952a97276.png)

> If **s** is incrementing by **s= s + i^2**. Then, the **time complexity** will be **Theta(cube(n)) -> Theta(n^(1/3)**.

![image](https://user-images.githubusercontent.com/54589605/229594030-c427c7bf-1497-45d5-a63a-11f8c22b6ff1.png)

> **j** is based on **i** loop. **YES**. If a for loop **j** is incremeneted by **3** then **time complexity** is **n/3**. If a for loop **j** is incremeneted by **10** then **time complexity** is **n/10**. If a for loop **j** is incremeneted by **20** then **time complexity** is **n/20**.

> So, in the below question **j** is incremented by **i** then **time complexity** is **n/i**. There is **dependency**. So, if **i=1**, then the **j** loop will repeat, **n/i -> n/1 -> n** time.  So, if **i=5**, then the **j** loop will repeat, **n/i -> n/5** time.  So, if **i=n**, then the **j** loop will repeat, **n/i -> n/n -> 1** time. The **series** we got is by considering **both, i and j**.

![image](https://user-images.githubusercontent.com/54589605/229597235-984ca85c-a5e0-4f3a-bf99-41612ef02c8c.png)

* n/1 + n/2 + n/3 ............. + n/n -> n[1/1 + 1/2 + 1/3 + ........ 1/n] 

> This is a **logarithmetic series**. So we get **n * log n -> n(log n)**. The **constant factor**, **[1/1 + 1/2 + 1/3 + ........ 1/n]** is equal to **log n**.

* [1/1 + 1/2 + 1/3 + ........ 1/n] -> log n

> As **1/n** is there so **log n**.

* [1/1 + 1/2 + 1/3 + ........ 1/log n] -> log(log n)

> As **1/log n** is there so **log(log n)**.

> So, whatever is there at the end **1/whatever**, then we do **log** of it so, **log(whatever)**. That's the **logic**.

> They are **inner** loops. They are **dependent** on each other. They are based on **one variable**.

> **int i** means **i** is declared and **memory** is allocated for it.

![image](https://user-images.githubusercontent.com/54589605/229601850-49e40c3c-e57e-4f38-b368-cf247af0f3d5.png)
![image](https://user-images.githubusercontent.com/54589605/229601964-cf7df09f-3a5e-4761-91fd-a92d019d5906.png)
![image](https://user-images.githubusercontent.com/54589605/229602095-6ee91b9e-d3ea-4703-8fdd-180f86e0ca94.png)

> We got **n^3** from the inner most loop and in the next iteration it was **n^3 + 1** which is greater than **n^3**, so the condition of the loop fails and we go to the **second loop**. We check the condition that **n^3 + 1** is less than **n^2** and it is **false**, so we go to the **first/outer** loop. We check condition that **n^3 + 1** less than **n** and it is **false**. So, we get out of all the loops. We got **1** itiration in **first loop**, then **1** itiration in **second loop** and **n^3** iteration in the **third/last** loop. So the **time complexity** is **O(1 * 1 * n^3) -> O(n^3)**.

![image](https://user-images.githubusercontent.com/54589605/229602918-0417a5b8-c2be-4139-959f-2e828b68f631.png)

> If we do like that then **each i** value is localized to their respective **for loop** blocks only. So, they are **different** now. Now, there are **two** declarations. First loop has it's own declaration and the **second and third** loops have their own declaration.

![image](https://user-images.githubusercontent.com/54589605/229603089-a59164c5-9196-43fd-831e-d5845205c438.png)
![image](https://user-images.githubusercontent.com/54589605/229603054-cc0bc2ad-df4f-4e60-89ef-66f854c750b4.png)

> If we write **int i** in every for loop, then there are **three** declaration and each and every loop is **different**. It is like **i, j and k**. It is like **three** different variables. One person don't see the **other person**. Everyone is individual. Their scope is **inside** their respective **for loop** blocks.

![image](https://user-images.githubusercontent.com/54589605/229603558-0ec35f2e-78d6-4f94-a8cc-881e366f4db6.png)
![image](https://user-images.githubusercontent.com/54589605/229604245-288c988d-fa18-4bab-a0ac-2cb00b7f7c48.png)

> Now, there is only **one i**.

![image](https://user-images.githubusercontent.com/54589605/229604504-ea0d11a5-8166-4cf2-a294-48ed0cc1bc22.png)
![image](https://user-images.githubusercontent.com/54589605/229605386-2b910a46-f155-448b-a652-5a1ffba17d48.png)
![image](https://user-images.githubusercontent.com/54589605/229605859-6267f4da-66bd-4286-abec-17cd32c2679c.png)

> It is forming an **infinite loop**. So, it is not an **algorithm**. It is a **program** which is going to  **infinite loop**.

![image](https://user-images.githubusercontent.com/54589605/229606268-a822465d-caac-47ea-9a83-c2b59e5c8a2d.png)

> Inner loops affecting outer loops.

![image](https://user-images.githubusercontent.com/54589605/229610287-aecda8f1-f14b-4c88-a8a1-23693cb27b8f.png)
![image](https://user-images.githubusercontent.com/54589605/229610310-03c68713-57d0-409f-8ca4-eae1d1b5a897.png)
![image](https://user-images.githubusercontent.com/54589605/229610337-e9fde60f-c3c2-4ae7-bf2e-a165a911d2a6.png)
![image](https://user-images.githubusercontent.com/54589605/229610357-63d12144-f145-4051-b844-201b1395b768.png)
![image](https://user-images.githubusercontent.com/54589605/229610373-5b502678-b0f8-4708-bd7e-d910a2b9d58f.png)


[**IMPORTANT**]
> **Practice** all of the questions. Before starting the new topic. Do some **practice** questions and revise them again.

## Asymptotic Notations

> Approximate answer

1) Big-O Notation -> (**<=**)
2) Omega Notation -> (**>=**)
3) Theta Notation -> It means **equal**. It means **Big O(<=)** as well as **Omega(>=)** also. If both(Big-O and omega) satisfied then it is **theta**.

> If between two people <= and >=, both are possible. Then, they are **equal**. If both are **True**, then they are **equal**. 

![image](https://user-images.githubusercontent.com/54589605/231459382-4c202308-2b11-44dc-804f-5118a5db48bf.png)

> If we know **Big-O** then we know how to apply **<=**. If we know **<=**, then we also know **>=**. As we know both(**<=** and **>=**), then we can apply **theta**. 

> If we learn **Big-O**, then automatically **all** will come.

> If we used **Theta** for one problem, then we can use **Big-O** as well as **Omega** for the same problem. **Theta** means **Big-O** as well as **Omega** only. 

![image](https://user-images.githubusercontent.com/54589605/231461655-2466978b-7f27-4f76-b0c5-8119a53f523a.png)
![image](https://user-images.githubusercontent.com/54589605/231462675-ab0129e5-85c1-4963-bbbc-35009ce892f8.png)

* Time and Space complexity cannot be **negative**.

![image](https://user-images.githubusercontent.com/54589605/231463083-bc937018-244f-41a0-b8e9-8a4f2ff6698d.png)

## Big-O Notation(<=)

* O -> <= [Less than or equal too]
* o -> <  [Less than]

![image](https://user-images.githubusercontent.com/54589605/231464989-cafdd352-b73e-44bb-937a-5517092b8aa2.png)

> **Big-O** means **right side** person would be **more or equal too** when compared with the **left side** person.

> In **Big-O**, **more or equal too** is on the **right side**. 

> According to **Big-O**, **right side** is **more/greater/bigger or equal too** than the **left side**.

![image](https://user-images.githubusercontent.com/54589605/231469636-b90040ec-603d-46ee-b7d5-69655dca5f15.png)

## Example

> We want to prove **right bigger** but frankly in the question, **left** is bigger.

![image](https://user-images.githubusercontent.com/54589605/231471403-9b66972c-0e8f-410c-990f-be5735920aff.png)

> The **2n** on the **left side** is far bigger than the **n + 5**. So, we will take **c=2**. Now, **n + 5 <= 2n**, so the **right side** is **bigger**. When comparing **left and right** side, **right side** is bigger with the help of **constant, c**. That's the meaning of **Big-O**.

![image](https://user-images.githubusercontent.com/54589605/231472294-b8c72faa-3f94-48b6-a8fa-72372f6e31ba.png)
![image](https://user-images.githubusercontent.com/54589605/231474437-ab0449d2-ce95-42ba-a0f9-eb77314a36a4.png)
![image](https://user-images.githubusercontent.com/54589605/231476493-3e7eaff7-802a-4585-a4d2-1b5a066c93a5.png)
![image](https://user-images.githubusercontent.com/54589605/231477937-9e2fcc06-2b19-49ee-bdb4-f91b18258e3a.png)

> In **Big=O**, we can take the support of **one** person, which is the **constant, c** and using that **constant, c**, we can prove that **right side** is **bigger or equal too**.

* **right side** is **bigger or equal too** -> **Big O**.

> In **example 2**, we can see that **right side** is **bigger** and we want to prove that **right side** is **bigger** only. So, **we don't need the help of the** **constant, c** here. We can set **c=1**, as support of **constant, c**, is not needed.

> From which value of **n** onwards, this relation will hold? Minimum value, start checking from **n0=1**. May or may not work. **Left** is **1** and **right** is **6**. So, **1(one)** onwards it is working. So, **right side** is **bigger**, proved. It is working from **zero(0)** also but don't write **zero(0)** when analyzing **algorithm**, **minimum one input is required**, so from **one** onwards start checking.

![image](https://user-images.githubusercontent.com/54589605/231481969-f28ac272-1acb-4725-8da1-42fe35754262.png)

> So, it is working **one(1) onwards**, and not **one(1) only**.

![image](https://user-images.githubusercontent.com/54589605/231482186-6d4974c7-c6e3-446e-9c9c-15c878a10a59.png)

> So for **Big-O** notation, it is the **starting** boundary. **From which point onwards it is working**, then is no **until** point here, until **infinite**. There is no **ending boundary** to it. Just say, the **starting point** and **from that point onwards, it is working**.

![image](https://user-images.githubusercontent.com/54589605/231483165-a6ec8330-4c8d-411d-8c18-7271eec4ee5a.png)

> From **1** point onwards, it is working. The constant value is **c=1** and **n0=1**. In place of **c** anything is ok, but is should be **constant**. Greater than **zero(0)**, we can take **anything**.

![image](https://user-images.githubusercontent.com/54589605/231485311-af4739fe-6b64-4fd5-8db6-a7b28cf6a236.png)
![image](https://user-images.githubusercontent.com/54589605/231485852-b607f18a-d5c8-47c5-bc68-7d4a00190317.png)

> The line **n= O(n+5)**, means that when comparing **n** with **O(n+5)** then **O(n+5)** is **bigger or equal too**, **n**, after taking **constant, c** help from some **n0** onwards. **Right side** is **bigger**.

> Even though the **constant, c** is available, we have to take it as **right side** is already **bigger** and we want the **right side** to be **bigger** that's we didn't need any help.


## Recursion-Part-I (7) [13th April 2023]

> **Big-O** means **right side** is **greater**.

> **Omega** means **right side** is **smaller**.

## Questions

![image](https://user-images.githubusercontent.com/54589605/231685712-f14fbe0b-1e42-4a85-8b59-de4af086664d.png)
![image](https://user-images.githubusercontent.com/54589605/231686479-07342880-7e32-45df-a26d-af7e9f0048f3.png)

> With respect to **c**, **n0** value will **change**. If we take **bigger c** value then **n0** value will be **smaller**. 

> **n0=3** means **3 onwards** upto **infinite**. Starting boundary is **n0=3** but there is no **ending boundary**.

![image](https://user-images.githubusercontent.com/54589605/231694994-9a4bdedc-c654-4e48-b7f0-82b8a75511c1.png)
![image](https://user-images.githubusercontent.com/54589605/231695183-1088a399-f0cb-45c9-b543-8bf4438c41b3.png)

> Starting boundary is **n0=10** but there is no **ending boundary**.

![image](https://user-images.githubusercontent.com/54589605/231688210-8bd04214-1a35-4b73-947c-26058dc4eda3.png)

> **f(n)= O(g(n))** means that comparing **f(n)**, **g(n)** will be **greater or equal too** after taking **constant help**. After comparing left and right, right will be **greater or equal too** after taking **constant help**, some **n0** onwards.

![image](https://user-images.githubusercontent.com/54589605/231690377-714b1934-42d3-45d1-b831-cffdd087d91d.png)
![image](https://user-images.githubusercontent.com/54589605/231690539-a0ddc063-d04a-4774-aba4-1d2aacc1839b.png)

> **n** is a function and we cannot take a **function**. Constant help is only allowed.

> The constant(c) cannot take a function **n** as on the left side it is **n * n** and on the right side is **c * n**. Only way it is possible if **c=n** but that is not allowed in notations, we cannot take a **function**.
 
![image](https://user-images.githubusercontent.com/54589605/231691836-9cb4ac0a-2090-4a11-8401-2b17ae8f1958.png)

> Using **Big-O**, we cannot prove any person is **bigger**. We can take only **constant** help and prove whatever possible. By using **constant** help if we can prove **right side** is **bigger** then that is **Big-O**.

> There is a limit for everything, we can only use **constant** help. More than **constant** help is not allowed. 


## Omega Notation(>=)

> In **Omega**, **less or equal too** is on the **right side**.

> By taking **constant, c** help, we can prove that **right side** is **less or equal too**. That is **Omega**.

* **right side** is **less or equal too** -> **Omega**.

![image](https://user-images.githubusercontent.com/54589605/231696283-2dd5ae72-b306-40fe-87c0-8834c2cc4b92.png)

> Not necessary that **c** value should be in **integers** only it can be in **fractions** as well like **1/2 or 0.5, 1/4 or 0.25**. More than **zero(0)**, take anything, which is a **constant**. Less than **zero(0)** not allowed and more than **zero(0)** anything which is **constant** is allowed. 

> **n0** indicates **inputs**, so it has to in **integer** and cannot be in **fractions**. We cannot have **1.5** inputs it should be either **1** or **2** inputs but not **1.5** inputs.

![image](https://user-images.githubusercontent.com/54589605/231698060-84cff2a3-ffd9-4bb6-a7d7-ccfb7b57a613.png)

> As it is **Omega**, we want to prove that the **left side** is **bigger** or directly that the **right side** is **smaller or equal too** as it is the **opposite** of **Big-O**.

>  We want to prove that the **left side** is **greater** but to be frank, the **right side** is **greater**.

![image](https://user-images.githubusercontent.com/54589605/231702689-008e17aa-b172-43af-9c6e-182fb92449a7.png)

> Whenever **c** value changes, then automatically **n0** value also changes. We don't need to find out every **c and n0** value. Find out **one pair** of **c and n0** value.

![image](https://user-images.githubusercontent.com/54589605/231703200-10bc7f82-d997-4e65-9a19-ec7b9951a4f1.png)

> One **c** value is **enough**. After fixing **c** value, adjust **n0** value accordingly.

![image](https://user-images.githubusercontent.com/54589605/231706580-2389733c-7f81-4f54-9e97-99a5f5d3c2b5.png)

> **n = Omega(n+5)** means that when comparing **n** with **Omega(n+5)**, we can prove that **n** is **bigger or equal too**, **n+5** with the **constant help** of **c**.

> Without any help, **n + 5** is **bigger**.

> After taking **constant help**, we proved **n** is **bigger**. **Omega** means **left side** is **bigger or equal too**.

![image](https://user-images.githubusercontent.com/54589605/231708907-f54d580f-1eff-4705-bb26-3eb1ec055921.png)
![image](https://user-images.githubusercontent.com/54589605/231709685-4f89887a-6fe0-4d73-b8a0-51d3da9d41cd.png)

> **c** cannot take a **function**. How small the function is, **c** cannot take a **function**. It can only take **constant** values.

![image](https://user-images.githubusercontent.com/54589605/231710063-88d5db24-e96e-45e0-9af1-019459a89837.png)

> For only few people it is possible to prove with **constant help** and not for all.

![image](https://user-images.githubusercontent.com/54589605/231712069-b4d26761-6b33-4521-a3ce-ba92f8cad741.png)

> Bigger one(n^2 here) will **decide** the answer. Think of the **bigger ones** they will **decide** the answer. Don't worry about the **smaller** ones.

![image](https://user-images.githubusercontent.com/54589605/231712165-8d30bc15-3f98-4806-b33d-7c0e7f32316a.png)

> Comparing **n^2** and **n^2 + n + 1**, we proved **n^2** is **bigger** by taking **constant help** that the **left side** is **bigger**.

## Summary

* With the help of **constant** prove **right side** is **bigger or equal too** is **Big-O**.
* With the help of **constant** prove **left side** is **bigger or equal too** is **Omega**.

> We cannot take **function help**, we have to take **constant help** only to prove them. There is no **requirement** of **every c or every n0**. Just find **one(1)** pair of **c and n0**.

> Until **constant** help is **only possible**. If not possible with **constant** help or more than **constant** help is needed then **Big-O or Omega** is not possible there.

![image](https://user-images.githubusercontent.com/54589605/231714728-a3db7f75-a6f8-4502-b814-6a54fccf4160.png)

![image](https://user-images.githubusercontent.com/54589605/231906104-834a66aa-8262-40a6-ac46-19132abefd0e.png)

> From **c=1/2 and n0=5 onwards**, the **omega** notation is working.

![image](https://user-images.githubusercontent.com/54589605/231906337-c7802369-0621-4b53-8a45-7d0ab9a39e01.png)
![image](https://user-images.githubusercontent.com/54589605/231906672-9b6691e0-6c7b-4df6-9391-48792204260e.png)

> Here also, we proved that for **c=1 and n0=1 onwards**, the **Big-O** notation is working.

> For the given two functions **f(n) and g(n)**, we have proved that **f(n)** is **bigger** by taking the constant help of **c=1/2 and n0=5 onwards**, the **omega** notation is working.

> For the given two functions **f(n) and g(n)**, we have also proved that **g(n)** is **bigger** by taking the constant help of **c=1 and n0=1 onwards**, the **Big-O** notation is working.

> So for some value of **c and n0**, **omega** notation is working. So for some value of **c and n0**, **Big-O** notation is working.

* **c=1 and n0=1 onwards**, the **Big-O** notation is working.
* **c=1/2 and n0=5 onwards**, the **omega** notation is working.

![image](https://user-images.githubusercontent.com/54589605/231907332-afeff6b4-7834-4a0a-81c5-23fc03167a96.png)

> To eliminate the confusion of two **c** values we have taken **c1** for **omega** and **c2** for **Big-O**.

> So we can see that we have **c1=1/2 and c2=1** and **n0=5 and n0=1** respectively. As for **n0** values they are overlapping from **n0=5** which is the **common point**, so we will use **n0=5** as both **Big-O and omega** are working fro **n0=5** onwards.

> Hence, we can say that **c1=1/2 and n0=5**, we can say that **omega** is working and for **c2=1 and n0=5**, we can say that **Big-O** is working. So **Big-O and omega** both are possible.

> Then, we can say that **n = Theta(n+5)**, as we have proved that between **two people** both **Big-O and omega** are possible for some **c1=1/2** value, **c2=1** value and **n0=5** value. Then we can say **Theta** possible.

![image](https://user-images.githubusercontent.com/54589605/231908749-7dbb24e7-1b8e-42cb-bbaa-5e8b7cbb6cad.png)

## Theta Notation

> **Theta** notation is very simple, please prove **Big-O and omega** notation possible. **Both** should satisfy, if **one** fails then we cannot say guranteed.

![image](https://user-images.githubusercontent.com/54589605/231909143-6bff60a8-1480-423e-9c01-21b5b3c9c45e.png)

> In the **first point**, we have to find **c1** value where **omega** notation is working and along with it find the **n0** value which onwards **omega** is working.

> In the **second point**, we have to find **c2** value where **Big-O** notation is working and along with it find the **n0** value which onwards **Big-O** is working.

> After finding **c1 and c2** value we have to find the **common point** in **n0** where both **omega and Big-O** are working. If we find **n0=1 and n0=5**, then the **common point** would be from **n0=5**.

![image](https://user-images.githubusercontent.com/54589605/231909695-adb07659-96c4-4080-8c16-e53a7b34e66d.png)
![image](https://user-images.githubusercontent.com/54589605/231909842-004ac36d-b124-41a8-bca6-7f9ff2c5f03a.png)
![image](https://user-images.githubusercontent.com/54589605/231910556-498bf20d-e046-4174-87ce-123145dc95a4.png)

> To say **Theta**, **omega and Big-O** are possible. It is an **AND** operator, **both**, should be possible.

![image](https://user-images.githubusercontent.com/54589605/231911077-d1d2050e-8e64-4b2a-a598-0f654d7bf282.png)
![image](https://user-images.githubusercontent.com/54589605/231911887-b2670ce7-48fa-4d15-a67f-65dbe2c8bcc6.png)

> Sometimes **c1 and c2** maybe **same**.

![image](https://user-images.githubusercontent.com/54589605/231913041-0aed30fc-934e-406e-a49f-6eaf9b51cdbe.png)

> If any one of the them(Big-O and omega) fails, then **theta** also fails/not possible. That's the reason for **AND(&&)** operator.

![image](https://user-images.githubusercontent.com/54589605/231913216-f3b3510e-85aa-48c9-aa35-e44ed43d3040.png)

> If one fails, then **stop**. If **both pass**, then only **theta** is possible.

> **Theta** means **<= and >=** both should be possible because of **AND operator**, which means they should be **equal**. **<= and >=** both are satisfied which means they are **equal**. 

> But in the above question, **n** and **n^2** were not **equal**, that's why they failed.

![image](https://user-images.githubusercontent.com/54589605/231913579-50460486-4973-43e0-8b16-84aea672c22e.png)

> **Theta** means **equal**. But, **n** and **n^2** were not **equal**, that's why they failed or **theta** failed for them.

> If asked to find **theta** among **two** people, then we don't need to do/find **Big-O and omega** between them. We just need to verify that **both are equal** or not. 

> We don't need to do definitions also. **Theta** means **equal**. We just need to verify that **both are equal** or not. If they are **not equal**, then **theta** fails.

![image](https://user-images.githubusercontent.com/54589605/231913929-91ce6c26-52ac-4343-8b78-0b985fc86f97.png)
![image](https://user-images.githubusercontent.com/54589605/231914330-825936ff-08e7-4dfe-b171-cee62b4bcdfa.png)

> Here, in **both sides**, we have **n** which means both are **equal**. As they are **equal**, hence, **theta** is possible.

![image](https://user-images.githubusercontent.com/54589605/231914597-c0fa94ea-4c17-4064-ba14-eacc30ee28f7.png)
![image](https://user-images.githubusercontent.com/54589605/231915919-af202874-40a1-473c-a09b-5dbb875c3269.png)

> In this case, we have to see the **bigger values** which is **n^2**. As **n^2**, is present on both sides, hence both of them are **equal**. So, **theta** is possible.

> We have to compare the **bigger values**. **Smaller** values will be taken care of by the **constant(c)**. Just compare the **bigger values**. **Theta** possible means **Big-O and omega** both are possible. 

> These **two** are **equal** because we are neglecting the **Smaller** values. They are **mathematically not equal** but they are **asymptotically equal**. By neglecting the **Smaller** values/terms, **bigger** values are **equal**.

![image](https://user-images.githubusercontent.com/54589605/231916402-575910bf-9b98-46e1-91ce-f7a301d529e8.png)

> **Theta** means **asymptotically equal**, which means by neglecting the **Smaller** values/terms, **bigger** values are **equal**.

![image](https://user-images.githubusercontent.com/54589605/231916565-0024fafc-33aa-4b17-8a95-3d8275ab4a7e.png)

> In the above question, they are **mathematically equal** as well as **asymptotically equal** also. **Mathematically equal** means they will be **asymptotically equal** also but **asymptotically equal** doesn't mean they are **mathematically equal**.

![image](https://user-images.githubusercontent.com/54589605/231916941-be779ec7-2e6d-4b8a-a6da-ee529ad07b53.png)

> Both the sides are not **exactly or mathematically equal** but they are **asymptotically equal**, as **bigger** person is **same** for **both the sides**.

## Trick to find **Theta** notation [**IMPORTANT**]

> We have to check the **bigger** values/function on **both sides**. If the **bigger** values/function on **both sides** are **equal**, then **theta** is **asymptotically equal** and possible. 

![image](https://user-images.githubusercontent.com/54589605/231917675-9418171e-03b6-4c8a-86a3-177199316781.png)
![image](https://user-images.githubusercontent.com/54589605/231917733-9f8119c4-a9a6-4ad1-87f6-31d7a482142e.png)

> If without any **constant help**, **both sides** are **equal**, then **c1=1 and c2=1**. No need of any help. This is **mathematically equal**, so it is **asymptotically equal** also.

> If **theta** is possible which means that both **Omega and Big-O** are also possible. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/231918510-6b64bf8a-2b04-4c3b-b97d-622fe602392a.png)

>  As it is **Big-O**, the **right side**, is **bigger or equal too** left side. So, **g(n)** is **bigger** after taking **constant(c)** help.  **g(n)** is **bigger** after some **n0** point. From **n0**, after comparing **f(n) and g(n)**,  **g(n)** is **bigger** after taking **constant(c)** help.

> We have started from **1** and not from **0** because **n0 >= 1**. Some **minimum** input is required.

* The line with **Blue color** is **g(n)** function.
* The line with **Red color** is **f(n)** function.

![image](https://user-images.githubusercontent.com/54589605/231919498-07cc6598-4f19-43e2-889c-5c40e7676d4f.png)
![image](https://user-images.githubusercontent.com/54589605/231919612-e0e4dd56-2afb-4f42-9f24-3051c90ed1d3.png)

> It keeps on **changing**, we cannot tell for sure which is **greater**. Sometimes **g(n)** function is **greater**. Sometimes **f(n)** function is **greater**. We cannot tell for **sure**. We are unable to express which is **smaller** and which is **greater**. 

![image](https://user-images.githubusercontent.com/54589605/231920156-8a76f1ad-5388-45fb-8c62-d6a5b4b04aff.png)

> After a certain point, **g(n)** function is clearly **greater** after taking some **constant help(c)**.

> The **certain point**, is called as **n0** and the value of **n0=4** onwards,  **g(n)** function is **greater**.

> This is called as **Big-O** notation.

![image](https://user-images.githubusercontent.com/54589605/231920433-351fdc82-d030-4051-b069-caf5d6da8e94.png)

> Before **n0**, we cannot say for sure what is the **relation**. We have some **doubts**. From **n0** onwards, we can clearly say that **g(n)** function is **greater** after taking some **constant help(c)**.

![image](https://user-images.githubusercontent.com/54589605/231920492-cbaf0649-a19f-4381-8e4a-3412183a014f.png)
![image](https://user-images.githubusercontent.com/54589605/231920585-fc19618e-8855-41db-8e53-80f0af773261.png)

> In **diagram 2**, **f(n)** is **bigger**.

> We can directly say that after comparing **f(n) and g(n)**, we can say that **g(n)** is **smaller or equal too** after taking some **constant help(c)**. Which means **f(n)** is **bigger**. 

> Always talk about **right side**. Right side means **g(n)**. To whoem we are keeping **constant(c)**, we have to talk about them. As **c** is on the **right side** so we are taking about **g(n)**. So, **g(n)** is **smaller** after taking some **constant help(c)**.

![image](https://user-images.githubusercontent.com/54589605/231921461-28f703f3-dfe9-433b-b830-989e365f4a41.png)

> From **n0** point onwards we can say that **g(n)** is **smaller** after taking some **constant help(c)**.

> We have to keep **c** for **g(n)** only and not for **f(n)**.

![image](https://user-images.githubusercontent.com/54589605/231922367-e0941fe5-e87e-4c1a-9af0-cf193aa166d0.png)

> For some **constant(c1)**, **f(n)** is **bigger**, so it is **omega** notation.

> For some **constant(c2)**, **g(n)** is **bigger**, so it is **Big-O** notation.

![image](https://user-images.githubusercontent.com/54589605/231927546-c3b7cfee-f178-4ad2-80cb-8e2bfb69a821.png)

> For some constant, **f(n)** is **bigger** and for some constant, **g(n)** is **bigger**. Difference is **only constant**. Otherwise how is it possible. If **difference** is function, by changing **constants**, how someone becomes **smaller** and someone becomes **bigger**. 

> This means, difference is only **constant**. Bigger functions are **same**.

![image](https://user-images.githubusercontent.com/54589605/231928043-1b70ae1f-e23a-4818-9fa4-910371012065.png)

> If **g(n) = n + 5** and **f(n)= n**. Then, **theta** is possible as **difference is only constant**. One person is **n+5** and another person is **n**, **difference is only constant** and the difference will be taken care of by **c1 and c2** constants.

> By changing only constant, sometime **g(n)** is **bigger** and sometime, **g(n)** is **smaller**. This means that, **difference is only constant**. That's the **meaning of theta**.

> **Theta** is nothing but sandwitching **f(n)** between **two g(n)s**. Therefore, by **constants**. This is called as **theta**.

> These two, **f(n)** and **g(n)** are working from **n0** onwards only. Before, **n0** anything can happen. After **n0**, we got clarity what is **happening/going on**.

![image](https://user-images.githubusercontent.com/54589605/231929265-173ab310-b5f7-4b61-b949-38d8efbbee2f.png)


## Doubts

![image](https://user-images.githubusercontent.com/54589605/231929742-73ea385a-c446-4bd8-beac-ba1dd0d27ab2.png)
![image](https://user-images.githubusercontent.com/54589605/231930173-e99b2a32-c17f-4b01-a9c1-2c54443501f5.png)

* RIC -> PYQs.

> RIC then PYQs.

![image](https://user-images.githubusercontent.com/54589605/231930669-ebfac401-a2ec-408c-a4ac-17b1653a0cdb.png)
![image](https://user-images.githubusercontent.com/54589605/231930684-3d7f47b4-b26b-4667-92b0-f389b81e3b7f.png)

> Do the above ones, it is sufficient.

![image](https://user-images.githubusercontent.com/54589605/232482124-76d15d55-fe5e-4519-92fd-265cff2d30b6.png)
![image](https://user-images.githubusercontent.com/54589605/232482146-e7340cf4-6f29-4ea3-ba7f-43d3e69623ae.png)
![image](https://user-images.githubusercontent.com/54589605/232482176-db9c2d38-04ff-433c-b824-addda28a5bbf.png)
![image](https://user-images.githubusercontent.com/54589605/232482193-f85e4e01-3d95-4f22-a07a-6ecea39c9499.png)
![image](https://user-images.githubusercontent.com/54589605/232482218-2e49e577-a5c8-4e79-bc19-367bd3a90577.png)
![image](https://user-images.githubusercontent.com/54589605/232482239-9a35e270-b354-4c69-956f-7adae611b1fe.png)
![image](https://user-images.githubusercontent.com/54589605/232482263-d64cc02c-df1a-49a0-8e5f-692e44690e85.png)
![image](https://user-images.githubusercontent.com/54589605/232482281-c88c73c4-03fe-435e-9ae8-1fe83cc78065.png)





## DAC-PART-I (8) [17th April 2023]

## Big-O Notation(O, <=)

> **Big-O** means **right side**, should be **bigger or equal too**.

> Equal and greater poeple are **OK**. Smaller people are **not OK**.

![image](https://user-images.githubusercontent.com/54589605/232393589-25f43e3d-e83a-4b61-b912-08f6d02c0fb9.png)

> In **Big-O** notation, on the **right side**, how are allowed?

> **Bigger and equal** people. They are called as **Upper bounds**.

![image](https://user-images.githubusercontent.com/54589605/232394064-a5268f2f-555f-4188-b0e2-d064e4585396.png)

> Big-O means right side will be **more or equal too** left side. Big-O will give **upper bounds**.

![image](https://user-images.githubusercontent.com/54589605/232394637-d100f173-1995-4130-aa3d-1be589c18b7f.png)

* n^2 = O(n^3) -> Upper Bound
* n^2 = O(n^2) -> Tighest Upper Bound(TUB) 

> When both the sides are **equal**.

![image](https://user-images.githubusercontent.com/54589605/232395269-f917fd94-1700-4a12-9a3f-1b1db407eb36.png)

> In case of **Big-O**, we are giving **upper bound**. Upper bound means **equal or more**.

* A=O(B)

> **A** is the **actual** here. **Left side person** is always **actual**. That's why we don't talk about the **left side** as it is anyways **actual** only. We will always talk about **right side** person only. **B** is **upper bound**. The **upper bound** maybe be **tight upper bound(n^2)** or maybe not **tight upper bound(n^3,N^4,n^10)**.

![image](https://user-images.githubusercontent.com/54589605/232398069-a7549496-f3fe-4580-80fc-364c192ee0f2.png)

> All of them are **upper bounds**. **Equal(n^2= O(n^2) )** is called as the **tightest upper bound**. **Not equal** is know as **not tightest upper bound**.

![image](https://user-images.githubusercontent.com/54589605/232400104-9ccc1f6d-32bb-468f-bd3b-6e6083f90332.png)

* A=O(B)

> **B** is the **upper bound**, which may or may not be **tightest upper bound**. **Dilemma is there**.

![image](https://user-images.githubusercontent.com/54589605/232402122-75fb4aec-1e75-45e0-8f88-0da529b75a20.png)

> In **small o**, there is only **less than** and **no equal too**. That's why only the **not tightest upper bound** are there. 

> **Small o** means **strictly bigger**.

> In **small o**, the **not tightest upper bound** are there on the **right side**.

> In **Big-O**, all are there but in **small o**, the **not tightest upper bound** are there only. So, in **Big-O**, there is some **dilemma**, whether it is **equal** or **more**. But in **small o**, there is **no dilemma**, as only the **not tightest upper bound** are there only.

* If the time complexity of some algorithm is **small o of n^3 or o(n^3)**. This is the **right side**. What will be the actual **time complexity** on the **left side**?

> The **left side** should be **strictly smaller** as we are using **small o** instead of **Big-O**. The left side person should be **n^2 or n or log n etc**.

* **Small o** means **strictly bigger**.
* **Big-O** means **bigger or equal too**.

![image](https://user-images.githubusercontent.com/54589605/232404276-6095d6ac-ad89-428b-8da5-4f6241dab656.png)

* A=o(B) [Small o]

> **B** is **not tightest upper bound**. **No dilemma**.

> **Big-O** has dilemma which is maybe **tightest upper bound** or not. To remove it then we should go with **small o** as it has **no dilemma**.

> If we have **dilemmas**, then we can use **upper as well as lower bounds**.

![image](https://user-images.githubusercontent.com/54589605/232406025-b0e1feee-bfa0-466e-b63d-164f3f817f10.png)

* **Big-O** having **two** operators,**< and =**.
* **small-o** having **one** operator,**<**.

* If **small-o** is satisfied then the **Big-O** will automatically be satisfied.

* If **Big-O** is satisfied then the **small-o** may or may not be satisfied.

![image](https://user-images.githubusercontent.com/54589605/232409630-3dcc6900-e7dd-46f0-9b52-6efbe904b959.png)

## Omega Notation(>=)

* Lower Bound 

> **Omega** means **right side**, should be **smaller or equal too**.

> In **lower bound**, some are **tighest lower bound** and some are **not tighest lower bound**.

* A= Omega(B)

> It means **B** is **lower bound** but it is ambigious/in dilemma that **B** is either **tighest lower bound** or  **not tighest lower bound**.

![image](https://user-images.githubusercontent.com/54589605/232413597-a8b4edc7-bde5-4692-a0c5-3032b10ce356.png)

> **Equal** person(n^4= Omega(n^4)) is allowed because of the **Equal too**. But it brings the **ambigious/ dilemma**.

> We can remove the **dilemma** by using the **small omega(w)**.

## Small Omega(w, >)

![image](https://user-images.githubusercontent.com/54589605/232414475-741dbb99-677b-4193-b831-3c5d50cfdc84.png)

* If **small-omega(w)** is satisfied then the **Omega** will automatically be satisfied.

* If **Omega** is satisfied then the **small-omega(w)** may or may not be satisfied.

> **small-omega(w)** is the **subset** of **Omega**.

![image](https://user-images.githubusercontent.com/54589605/232414954-07e046e9-a62b-4a20-be58-85edb047e2f5.png)

> It is **minimum**, which means **lower bound**.

* n^4 = Omega(n)

> **Omega(n)** means that the **left side** is **more or equal too than n**.

![image](https://user-images.githubusercontent.com/54589605/232415508-40bf956c-5be1-4fdc-ac3b-bed7697a4330.png)
![image](https://user-images.githubusercontent.com/54589605/232415854-ef4fe1fe-ba03-47c1-a4f0-c6767403b44b.png)

* = Omega(6)

> If we say **Omega(6)**, then the **left side** should be **more or equal too 6**, which is **6,7,8....etc**.

> **Omega(6)** means that, we want to say that it is **6 or more than 6**, anytime.

* = w(6)

> If we say **small omega or w(6)**, then the **left side** should be **more than 6**, which is **7,8,9....etc**.

> **Small omega or w(6)** means that, we want to say that it is **after 6, at anytime**.

![image](https://user-images.githubusercontent.com/54589605/232416740-966bcfdb-3b77-4db3-8ebd-f8a66c4cc362.png)

* **Omega** is from **6 and onwards**.
* **Small omega or w**, **7 onwards**.

![image](https://user-images.githubusercontent.com/54589605/232418968-8a2cd0b2-de52-4f60-b904-e348d604c217.png)
![image](https://user-images.githubusercontent.com/54589605/232420262-31a3212a-dacd-4672-8dac-43dec9bb3f6b.png)

## Summary

* Strictly less than 7 or Before 7 -> **Small o**.
* 7 or less than 7 -> **Big-O**, as it is **upper bound**.
* 7 or after 7 -> **Omega**, as it is **lower bound**.
* Definitely after 7 only -> **small omega w**.
* Guranteed less than 9 -> **small o**.

![image](https://user-images.githubusercontent.com/54589605/232421937-485961a4-74b8-4824-8223-df51935959db.png)

> **Tighest upper or lower bound** are not possible in **small o or small omega**, as they don't have the **equal too** operator. 

> **Tighest upper or lower bound** are possible only in **Big O and Omega(Big Omega)**.

![image](https://user-images.githubusercontent.com/54589605/232422565-ad834736-2dc6-427a-82e8-9fe4e9dfe47d.png)

* Tightest Upper bound

## Theta Notation

> If between **two** people, **Big-O and Omega** are possible, then **theta** is also possible.

* A = Theta(B)

> **Theta(B)** means it is the **tightest upper bound** as well as the **tightest lower bound**.

> Theta possible means **Big-O and Omega** are possible.

![image](https://user-images.githubusercontent.com/54589605/232423668-0d864f95-51f0-4b4b-90f3-de2ba1f3c239.png)

> If **left and right** side are **not equal**, then **theta** is not possible.

![image](https://user-images.githubusercontent.com/54589605/232424058-689883c7-2be1-4137-93f8-0695180b2e09.png)

> It is **not possible**, if **left and right** side are **not equal**. One of the **sides** is **True** and one of the sides is **False**.

> If **both** are **equal**, then only possible.

> If between **two** people, **Big-O and Omega** are possible, then **theta** is also possible. If **theta** is possible which means that there is no doubt at all that they both are **equal**. **Equal** means **tightest upper bound** as well as the **tightest lower bound**

## Summary

* Want upper bound may or may not be tight -> Go for **Big-O**.
* Want upper bound which is not tight -> Go for **small-o**.
* Want all lower bounds -> Go for **Omega**.
* Want not tighest lower bound -> Go for **small-omega(w)**.
* Want tighest upper bound and tightest lower bound -> **Theta**.

> On all of them **left side** is the **actual** side.

![image](https://user-images.githubusercontent.com/54589605/232426300-0e8fadc8-519e-44ca-96fb-17ea02e26daa.png)

* As it doesn't go more than **n^2**

> Which means it is **upper bound**, so it is **Big-O(n^2) or O(n^2)**.

* As it doesn't go less than **n^2**

> Which means it is **upper bound**, so it is **small-o(n^2) or o(n^2)**.

![image](https://user-images.githubusercontent.com/54589605/232427466-12f5f406-4572-431b-9e04-8bb551d8bdc1.png)

## DAC-II (9) [17th April 2023]

## Complexity Classes

> **Constant** cannot change.

> When we say **Theta(1)**, it is not Theta(1), the **actual one(1)** is on the **left hand side**.

> Any constant can be written as **Theta(1)**.

![image](https://user-images.githubusercontent.com/54589605/232486492-3be678d6-dd48-417d-901d-95756899e404.png)

> Whichever takes **less time** is **better**.

* In terms of **time complexity**, **constant or Theta(1)** is better.
* In terms of **growth**, **log or logaredmic** is better.

* Bigger algorithm -> Worst algorithm
* Smaller algorithm -> Best algorithm

![image](https://user-images.githubusercontent.com/54589605/232492430-a92d37bb-6fc2-405d-a376-79693e46f195.png)

> As of now, **linear or Theta(n)**, is the **Bigger algorithm** and hence the **Worst algorithm**.

![image](https://user-images.githubusercontent.com/54589605/232492932-e2bc5ae4-dfa2-4cfb-b83f-bc53af8ce1b5.png)

> As of now, **exponential or Theta(2^n)**, is the **Bigger algorithm** and hence the **Worst algorithm**.

> As of now, **constant or Theta(1)**, is the **smaller algorithm** and hence the **best algorithm**.

* Whichever will take **less time** is **better**.
* Whichever will take **less space** is **better**.

![image](https://user-images.githubusercontent.com/54589605/232494980-be58eb49-f007-4b3f-af57-3e38f36b2a55.png)

> Definition of **polynomial** is **n^c**, where **c** is some **constant** and **c>0**, we cannot take any **negatives**. No integers, nothing, **fractions are allowed**.

* n^1 -> polynomial
* n^2, n^3 -> polynomial
* n^100 -> polynomial
* n^(1.414) -> polynomial
* n^(1.5) -> polynomial [1.5, is a constant and greater than zero(0)]
* n^0 -> Not polynomial [As, c should be greater than zero(0)]
* n^(0.5) -> polynomial

![image](https://user-images.githubusercontent.com/54589605/232496667-d829191c-e59c-4bef-9eac-568c88237155.png)

> The main ones are **constant, log, polynomial, exponential**.

> Inside **polynomial**, we have **n^1, n^2, n^3,....**, which are **linear, quadratic, cubic,....** respectively.

![image](https://user-images.githubusercontent.com/54589605/232497942-c77b56de-c50c-430e-93bf-545441d21f59.png)

> Definition of **exponential** is **c^n**, where **c** is some **constant** and **c>1**. They are **2^n, 3^n,4^n...**.

* (1.1)^n -> exponential
* 5^n -> exponential
* (51)^n -> exponential
* (1.01)^n -> exponential

![image](https://user-images.githubusercontent.com/54589605/232499031-085607f5-6d33-4afb-8014-be491e89f0f7.png)

> The **smallest function** is **constant**.

> The **smallest function** is from **constant, log, polynomial(linear, quad, cubic), exponential**. **Exponential** is the **biggest** function.

![image](https://user-images.githubusercontent.com/54589605/232499775-effeeeff-a702-4aa8-84f7-a873fb44d2e0.png)

> **linear, quad, cubic** are polynomials only but **special type** of polynomials, as they have **names** also.

![image](https://user-images.githubusercontent.com/54589605/232507821-63eb4795-15ab-4854-ad71-2dae69da038a.png)

* If asked, if less than **constant** possible?

> **YES**, possible. They are called as **decreasing functions**.

> Examples of **decreasing functions** are **1/n, 1/(2 * n)**.

> The **smallest/minimum**, time complexity of any algo is **constant or Theta(1)**. If no. of inputs increasing then the time is decreasing, how is that possible, atleast it should be **constant**, how time decreases. Less than **constant** time, how possible.

![image](https://user-images.githubusercontent.com/54589605/232527621-ff1650d7-9663-4267-a64a-c9a88c534db3.png)

> They are used for **all**.

> Time complexity or space complexity **decreasing**, possible? **NO**. **Minimum** is **constant**. No meaning of **decreasing**. Just remember it is **one of the functions**.

* Decreasing function < constant < log < (linear < quad < cubic) [Polynomial] < exponential.

![image](https://user-images.githubusercontent.com/54589605/232532909-06d35433-1c2c-430d-a495-4347810b4a79.png)

* n^n is **bigger**
* n! is **bigger**.

![image](https://user-images.githubusercontent.com/54589605/232536065-ffec6245-094b-4a91-ba53-4b0c131db639.png)

> Out of **n^n and n!**, **n^n** is **bigger**.

![image](https://user-images.githubusercontent.com/54589605/232536454-80cbe5af-77d4-43c5-a526-1c4986e576bc.png)
![image](https://user-images.githubusercontent.com/54589605/232536754-3024dca1-7aa5-4c6d-925a-c3e171950193.png)

> **2n** is **bigger** and it is **bigger** by a **constant**.

![image](https://user-images.githubusercontent.com/54589605/232536857-7cd9ff35-578f-4f75-a4c8-41e57d60890f.png)

> As **n!** is **bigger** by a **function** then **theta** not possible. So it is only **2^n= O(n!)**, Big-O. It is **bigger** by **function**. If it was **bigger** by **constant**, then **theta** possible.

![image](https://user-images.githubusercontent.com/54589605/232537758-4b7f378e-61e3-4f56-9991-a58db8f6312d.png)

> As **n^n** is **bigger** by a **function** then **theta** not possible. So it is only **n!= O(n^n)**, Big-O. It is **bigger** by **function**. If it was **bigger** by **constant**, then **theta** possible.

* n^n = Omega(n!)

> Whenever **Big-O** is there, by **reversing** the functions, we can write **omega**.

![image](https://user-images.githubusercontent.com/54589605/232539643-1d91b955-388e-4b33-8719-a6938da22bc5.png)

> We can **reverse** them and then we can use **omega** notation. If we reverse the **function**, then we can **reverse** the symbols also.

![image](https://user-images.githubusercontent.com/54589605/232540967-baf3b309-5b23-4b0d-8e4a-784df029fb88.png)
![image](https://user-images.githubusercontent.com/54589605/232541014-0118ebf6-00a2-476e-a15e-8a0fd741ad81.png)
![image](https://user-images.githubusercontent.com/54589605/232542330-12c33d89-dfd9-4d6e-82b3-8aa7d6422f62.png)

> As **omega** is not possible, that's why **theta** is also not possible. **Big-O** is only possible. 

> **Big-O and omega** possible means, **difference** is **constant**, then **theta** possible.

> In the **above** ones, difference is **not constant**, it is **function** that's why **theta** not possible.

![image](https://user-images.githubusercontent.com/54589605/232541701-2b434c9b-a1bb-4d53-ac5d-5b7e350f85f5.png)
![image](https://user-images.githubusercontent.com/54589605/232541786-0b3db813-e4b5-491d-a6f0-39c8b306ab1b.png)

* constant difference.

![image](https://user-images.githubusercontent.com/54589605/232541986-0a1dd5ca-9756-447f-986c-6d34aed4d66d.png)

![image](https://user-images.githubusercontent.com/54589605/232542423-4056974b-b8ab-4ef1-8c49-1592774948fc.png)

> **n^n** is **bigger** than **2^n**.

> Both **n^n and 2^n** have **powers** and they look **complex**. So, whenever complex functions are given and  we have to find which is **bigger** and which is **smaller**. Apply **log** on both the sides.

![image](https://user-images.githubusercontent.com/54589605/232543082-d02af8c6-9ae0-480a-bc21-5c95eb9c6d81.png)

> After taking **log** on both sides, we got **log n : 1** and **log n** is **bigger** so, **n^n** is **bigger**.

![image](https://user-images.githubusercontent.com/54589605/232543527-e18162b7-f1ec-4fc2-92aa-7a6087cb344d.png)

> **n^3** is **bigger**. Don't apply **log** there **easy questions**. 

> If we apply **log**, then we get **1 : 1**, which is **wrong**.

* Do not apply **log bliendly**. **YES**.

> Apply **log** to complex problems only.

![image](https://user-images.githubusercontent.com/54589605/232548364-7d83dd0d-55c4-49e5-be2f-733441a2dffa.png)

## Doubt_Clearning_Session (10) [18th April 2023]

> Base is **bigger**, **small** value.

> Base is **smaller**, **bigger** value.

> So **log n base 2** is **bigger** compared to **log n base 3**.

[**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/232773731-2236ee93-110f-43bb-800d-1fc09b043167.png)
![image](https://user-images.githubusercontent.com/54589605/232773796-ea3633bb-31ce-464f-b369-399dd2feaa90.png)

> **c** is **some common** base.

* log a base b -> log a base c/ log b base c

![image](https://user-images.githubusercontent.com/54589605/232774203-10d95547-ddd4-418a-9aa3-ff1fb22f8efa.png)

* log 64 base 4 -> log 4^3 base 4 -> 3
* log 64 base 2/ log 4 base 2 -> log 2^6 base 2/ log 2^2 base 2 -> 6/2 -> 3

> Between **two** people, if the difference is only **constant**, then we can write **theta**.

> If two people differ by only **base** which is nothing but **constant** only and not functions.

> Bases are only **constants** means, the **difference** is also **constant** only. Rest is **same** only. Only **base** differ and they are **constants** only, so **difference** is **constant** only. So, we can write, **theta**.

![image](https://user-images.githubusercontent.com/54589605/232777461-6bcb896a-4e99-4f75-b62c-8d0c6f00fdc9.png)

* If in a loop, **i** is incremented by ** i * 2**. How many **times**, the loop is repeating?

> **log n base 2**.

* If in a loop, **i** is incremented by ** i / 3**. How many **times**, the loop is repeating?

> **log n base 3**.

> One program's time complexity is **log n base 2** and another's is **log n base 3**. Asymptotically those **two** algorithms are **same**. They **differ** by **constants** but logic-wise they both are **same**.

> In a question, they asked for **time complexity** and the answer is **log n base 2**. In the options there was **log n base 2** and we **selected** that.

> If **log n base 2**, not there in the **options**, but **O(log n base 3)** is there in the **options**. Then we have to select **O(log n base 3)** as the **correct option** as **log n base 2** not there. Because the **difference**, is only **constant**.

> If **theta** is there, then **Big-O and omega** possible.

> Whatever is there in terms of **log** in the options just select that, because **base** are **constants** and don't worry much about them.

> If the answer was **log n base 2** and the options only had **log n**, then we should select that as the **correct option**, as **bases** are **constants** only.

> **log n base 20** and **log n base 30** are **asymptotically same** but **mathematically not same**.

![image](https://user-images.githubusercontent.com/54589605/232781758-6b94e57c-04a2-4233-8d5c-38f33ab8c84e.png)
![image](https://user-images.githubusercontent.com/54589605/232782175-fdccfd30-4383-49d9-bea7-9e4fea63e054.png)

> If two people are **log n**, therefore, **Big-O, omega and theta** are possible.

![image](https://user-images.githubusercontent.com/54589605/232783559-12834096-3f7f-4d11-8467-dbfe183ebc4a.png)
![image](https://user-images.githubusercontent.com/54589605/232784111-e4a13e1a-4943-4908-a6b0-3b54a069df45.png)

> **3^n** is **bigger**. But it is not bigger by **constants** but is is bigger by **exponential function** which is **(1.5)^n**.

* 2^n = O(3^n) [YES]
* 2^n = Omega(3^n) [NO]
* 2^n = Theta(3^n) [NO]

> **Omega** is not possible because **right side** is **bigger** by **fuction** and not **constant**.

> Remember, **3^n** is **bigger** by some **function** and not **constant**.

![image](https://user-images.githubusercontent.com/54589605/232787036-262db8ba-4fc1-4c49-aeb5-1c7d0dc0c616.png)

> Don't apply **log** in GATE exam. It is a **trap**. [**IMPORTANT**]

> **Worst case**, If applying **log** anyways, then remove/cancel the **common things**.

> **Common** means **writing one interms of another**.

### strling of n!

![image](https://user-images.githubusercontent.com/54589605/232790512-583716f1-59fc-4933-aa5c-43a06e12a930.png)
![image](https://user-images.githubusercontent.com/54589605/232790534-b81fd7c7-6055-47d6-b9f6-452bc7f5e41f.png)
![image](https://user-images.githubusercontent.com/54589605/232790722-1643ba7a-0556-4166-b2d7-4d1e124add8a.png)

> **n^n** is **bigger** but with **function** difference and not with **constant** difference. So, **Big-O** is only possible. **Omega and theta** are not possible.

![image](https://user-images.githubusercontent.com/54589605/232791210-747e7ea4-aa23-4ccb-94b1-1f9a56c44cb0.png)
![image](https://user-images.githubusercontent.com/54589605/232791552-ef4c476e-bad1-4ba6-8890-991b29f26acf.png)

> **n^n** is **bigger** but with **function** difference and not with **constant** difference. So, **Big-O** is only possible. **Omega and theta** are not possible.

![image](https://user-images.githubusercontent.com/54589605/232792535-a101ed9e-39c2-45de-98c6-00a2e167d8fc.png)

> **Before** applying **log**, **theta** is not possible.

![image](https://user-images.githubusercontent.com/54589605/232792592-8d90a77b-7e65-4328-8dea-48cbd79773f7.png)
![image](https://user-images.githubusercontent.com/54589605/232793182-51774b85-846e-41cf-a64a-7514357be8df.png)

> **After**, applying **log**, on both sides, which are **n! and n^n**. We got **n log n** on both the sides. As they are **same**, hence **theta** is possible.

> **Before** applying **log**, **theta** is not possible, but **After**, applying **log** **theta** is possible. This is because of **strling's approximation**.

> This is only for **n!**. Not applicable for others.

> On **6th point's**, part **1**, there is no **n!** there. So, **strling** will not **come**.

> On **6th point's**, part **2**, there is **n!** there. But **before** applying **log**, they both are **not equal**. Only **Big-O** possible. **Theta** is not possible.

> On **6th point's**, part **3**, there is **n!** there. But **before** applying **log**, they both are not **equal**. But **after** applying **log**, they both are **equal**. **Theta** is possible.

![image](https://user-images.githubusercontent.com/54589605/232795488-e7597a42-2149-4c48-b917-adee7365aa09.png)

> There are **two** people, **before** applying **log**, **theta** is not possible. **After** applying **log**, **theta** is possible, because of **strling approximation**. 

> **Strling** keyword will come whenever **factorial or n!** is given. [**IMPORTANT**]

> According to **Strling**, **n!** is not equal to **n^n**. **n^n** is **bigger**, **theta** not possible. But **after** applying **log**, they(n! and n^n) both are **equal**. **After** applying **log**, **left side**, became **n log n** and **right side** also became **n log n**. They both are **equal**, because of **strling**.

![image](https://user-images.githubusercontent.com/54589605/232801649-63a50cc0-5c4b-474f-b2d3-e609743528ec.png)

> On the **3rd last step**, from **1/2 log(2 * pie * n)**, we took **log n** and from **n logn - nloge**, we took, **n logn**, because **n logn** is **bigger**.

> In the **2nd last step**, **log n + nlog n**, we took, **nlog n** because it is **bigger** than **log n**.

![image](https://user-images.githubusercontent.com/54589605/232803378-7b13c256-d55e-41b9-99ec-d115ade9870d.png)

> **Before** applying **log**, left side which is **n!** is **n^n/e^n** and the right side is **n^n**. **Right side** is **bigger**, it is **bigger** by **e^n or exponential** times.

> **After** applying **log**, both are asymptotically **equal**, because of **strling**.

![image](https://user-images.githubusercontent.com/54589605/232804248-9e06855b-75dd-4027-9d3e-1f568501cf79.png)
![image](https://user-images.githubusercontent.com/54589605/232804880-d0878aad-e6f3-4f8c-8ba9-3a54d910f5fc.png)

> **Before** applying **log**, **theta** is not possible. Only **Big-O** is possible.

> **After** applying **log**, **theta** is possible. They both became **equal**.

![image](https://user-images.githubusercontent.com/54589605/232805131-a9a252a3-f037-42b2-b509-4321ef7d1498.png)
![image](https://user-images.githubusercontent.com/54589605/232805274-5ea618be-179f-42a2-89ce-fdc882863121.png)

* If asked to see if **theta** is possible or not? What is the relationship between these two people?

> **We will not apply log** and give answer.

> Before log, theta is not possible.

> After log, theta is possible.

> They are asking without applying log, if both are **equal** or not. **SAY NOT**. They are **not equal**.

> After applying log they are equal.

> After applying log, sometimes they are **equal**. Please avoid applying **log**. Until and unless they are **complex** people/questions, don't apply **log**.

> Before and after applying log sometimes behaviour changing or not. Because of behaviour changing, don't apply log.

![image](https://user-images.githubusercontent.com/54589605/232809398-3f78a340-0850-4e51-a9e8-35ca8b6e17b2.png)

> Before log, theta not possible. But after log, **maybe sometimes**, theta is possible.

* A= Theata(B)

> Don't blindly apply log.

![image](https://user-images.githubusercontent.com/54589605/232810217-5dbbf0ec-e328-4a3a-8cc2-d4c2b237a557.png)

* n^2 = n^3
* n^2 = (n^2 * n) [Cancelling/removing the common things/terms]
* 1= n [Now, applying log]
* log 1 = log n
* 0 = log n 

> We can see that after **careful** application of **log**, **theta** is not possible.

![image](https://user-images.githubusercontent.com/54589605/232812614-7e05900b-e39b-4de8-b6c2-3249b57b0c7b.png)

> Behaviour changing asymptotically. Mathematically nothing changes.

> If A < B. After applying **log** also, it is **A < B** only.

* A < B -> Mathematics. No constant, c.

> If we take some constant help, c, then it is asymptotic.

![image](https://user-images.githubusercontent.com/54589605/232814205-15c25737-3f53-4411-8c36-27e1393ece04.png)
![image](https://user-images.githubusercontent.com/54589605/232814483-e837b271-c61c-4e5d-bd25-fd302e02ac8b.png)
![image](https://user-images.githubusercontent.com/54589605/232815080-639cbbcf-aa18-44a8-a700-e3dd9ead3117.png)
![image](https://user-images.githubusercontent.com/54589605/232817842-c85b3d3d-867c-4c62-a0cb-1405c9cd27ea.png)

> After applying **log** carefully, **theta** is not possible.

![image](https://user-images.githubusercontent.com/54589605/232824974-4ac668f7-9b96-448a-a4a7-bd3028f000e3.png)
![image](https://user-images.githubusercontent.com/54589605/232826389-34bc2c4c-4b52-4408-93a3-5586088012e6.png)
![image](https://user-images.githubusercontent.com/54589605/232826558-0a8872cf-9bd6-4ff3-b484-bef36f9b3a34.png)
![image](https://user-images.githubusercontent.com/54589605/232841118-b628ea74-68a1-4fe1-a80f-b777158f56b0.png)
 
> **n * root(n)** means **n * n^(1/2)**.
 
![image](https://user-images.githubusercontent.com/54589605/232840835-5be58d22-2233-410d-8d20-e19e6669471a.png)

* n * sqrt(n) -> n * n^(1/2) -> n^1 * n^(1/2) -> n^(3/2) -> n^(1.5)

![image](https://user-images.githubusercontent.com/54589605/232842426-1912d987-f21b-49d9-be4b-759637b8b2a6.png)

> In **powers**, **constants** matters. We cannot ignore them. In the **power**, everything matters, we cannot ignore everything.

![image](https://user-images.githubusercontent.com/54589605/232843484-156580f5-4904-4210-b568-f06568241362.png)
![image](https://user-images.githubusercontent.com/54589605/232844455-2049318d-3c8c-418d-81ef-8cc0a21bda71.png)
![image](https://user-images.githubusercontent.com/54589605/232844489-3f1a77ca-4c1d-4c91-a02e-57b37f3b3609.png)

> In the **power**, anything is fine, cannot be ignored.

![image](https://user-images.githubusercontent.com/54589605/232844911-84b7a7f8-acbc-4ea8-bfee-043555e4e1e0.png)

> **Exponential** is **bigger** than **polynomial**.

![image](https://user-images.githubusercontent.com/54589605/232845199-b1d37e82-c2fb-43b1-9717-ca9ac97ac774.png)

> **D** is saying that **2^n** is not equal to **n^x**, which is **correct**.

![image](https://user-images.githubusercontent.com/54589605/232845526-2371c2b5-5be3-437d-842e-fac2de384dae.png)
![image](https://user-images.githubusercontent.com/54589605/232846052-6158ea33-a2f8-4d2c-9701-9636b52c0107.png)

[**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/232846175-aef3acaf-e801-4646-8807-a116cba393e7.png)

* a^(log b base c) = b^(log a base c)  [**IMPORTANT FORMULAE**]

> In the **power**, **log** is there, apply the above formulae.

* 64^(log n base 2) -> n^(log 64 base 2) -> n^(log 2^6 base 2) -> n^(6 * 1) ->n^6

![image](https://user-images.githubusercontent.com/54589605/232846940-5934a42f-4de3-48ef-8d61-903fc76a3600.png)
![image](https://user-images.githubusercontent.com/54589605/232847268-d1a708ce-d662-4a48-a892-8d86e00c1ec6.png)
![image](https://user-images.githubusercontent.com/54589605/232847441-698621c5-bbfd-4a9a-bb6f-1367fbc5417a.png)

> If **theta** is possible, then **small-o and small-omega(w)** has no meaning or are not possible.

## Doubt Clearing Session (11) [19th April 2023]

![image](https://user-images.githubusercontent.com/54589605/233063312-ac1be5ca-6418-48cf-af29-d7f4e387617e.png)

> In **option (a)**, both the sides the bigger value is **2^n** and the difference is constant only. So **Big-O**, possible.

![image](https://user-images.githubusercontent.com/54589605/233065160-e7f7ef53-a21e-489e-b2f7-70ac3a39ad13.png)

> In **option (d)**, both the sides the bigger value is **2^n** and the difference is constant only. So **Theta**, possible.

![image](https://user-images.githubusercontent.com/54589605/233067056-0328a61f-cca4-4020-81fd-d0e275a38d86.png)

![image](https://user-images.githubusercontent.com/54589605/233065327-61c6387d-2660-4ac2-b5fe-eac50c59017c.png)
![image](https://user-images.githubusercontent.com/54589605/233065016-d794f2f1-e454-44f0-9bb8-359c3290188d.png)

> **Gave it by mistake**. It is **false** as the **bigger values** are not the **same**, on both the sides. Left side is **2*(2n)** and on the **right side**, it is **2^n**. The differenece is **function** and not constant. So, **theta** not possible.

![image](https://user-images.githubusercontent.com/54589605/233067334-4e2f781d-03c6-4dcf-a21d-ed90789f58fd.png)
![image](https://user-images.githubusercontent.com/54589605/233067544-45a97f99-58ad-4fd7-8a2b-938cff1c9915.png)

* True

![image](https://user-images.githubusercontent.com/54589605/233067784-d5f00133-4b2e-4e2b-b6e3-0b3e64a0ee25.png)

> In **option (a)**, **omega** is also possible along with **Big-O**. As both, **Big-O and omega** are possible, then **theta** is also possible. As **theta** is possible and it means **equal**, that's why **smal-o and small-omega(w)** are not possible.

![image](https://user-images.githubusercontent.com/54589605/233069108-beae3a80-34eb-48ea-951e-9dcfaf74d556.png)

> In **option (b)**, both the sides have the **same bigger** values but they differ by **functional** difference and not by **constants**. That's why **Big-O** not possible. Hence **option (b)**, is **False**.

![image](https://user-images.githubusercontent.com/54589605/233069264-ba6f568c-23c9-4ccc-b39b-b63cb7f8bb2a.png)

> **Omega** is possible as omega is **>=**. As **Big-O** is not possible, so **theta** is also not possible. As **theta** represents **equal**, so **equal** is not there. Hence, the **small-omega(w)** is also possible. 

> **Omega and small-omega(w)** are possible for **option (b)**.

![image](https://user-images.githubusercontent.com/54589605/233070338-657610e0-7c5b-48cd-94e2-4455fc66760c.png)

> In **option (c)**, both the sides have the **same bigger(2^n)** values but they differ by **functional** difference and not by **constants**. **Omega** is possible as omega is **>=** but **Big-O** is not possible as big-O is **<=**. As, **big-O** is not possible, hence **theta** is also not possible. Hence **option (c)**, is **False**.

![image](https://user-images.githubusercontent.com/54589605/233071312-09875bc6-b15a-43b7-aeab-98ca55e9cc5f.png)

* T
* T
* T
* F

![image](https://user-images.githubusercontent.com/54589605/233071521-26fbd00e-1829-43f7-baa6-27d566814732.png)

> In **option(a)**, it is **True**. When **theta** is possible, **small-o and small-omega(w)** are not possible.

![image](https://user-images.githubusercontent.com/54589605/233073955-f49a076e-0e68-4c78-b694-bb0a08bc6954.png)
![image](https://user-images.githubusercontent.com/54589605/233074104-1e65ec5f-7e8b-4afc-9728-561bbe3002b4.png)

> **1/n** is **less than 1**, when **n > 1**. These are **decreasing functions**.

> In **option(b)**, it is **True** for **normal or increasing** functions but it is **false** for **decreasing functions**.
 
![image](https://user-images.githubusercontent.com/54589605/233075077-3bc56940-d221-4ed7-b464-9cea91713dcd.png)
![image](https://user-images.githubusercontent.com/54589605/233075521-a6928dc3-8462-46e4-981a-93061469c027.png)

> As nothing is mentioned in the question, we have to consider **both or all**, **increasing as well as decreasing**, functions.

> In **option(b)**, **big-O**, failed for **decreasing functions**. **Omega** failed for **increasing functions**.

> **One**, fail is **enough** to say that **option (b)** is **False**.

> In **option(b)**, everything **failed**. So, sometimes, **two** are **not comparable**.

![image](https://user-images.githubusercontent.com/54589605/233076770-2da29b5b-dde5-4856-86b7-66c91f530f78.png)
![image](https://user-images.githubusercontent.com/54589605/233077592-7abd475a-6fb4-4e13-a370-dd596eda1059.png)

> When nothing is mentioned in the question, we have to consider/take **both or all**, **increasing as well as decreasing**, functions.

> If **mentioned** then take accordingly.

![image](https://user-images.githubusercontent.com/54589605/233079838-4e1dd86b-a25e-44b6-b23e-b19a7524eab4.png)

> In **option(b)**, it is only mentioned **increasing functions** and **f(n) >= 1 and n>=1**, then **option(b)** will be **True** as **Big-O** will be possible.

![image](https://user-images.githubusercontent.com/54589605/233080003-1e0e8d8c-6d4a-48d8-afd3-cd65d4ac0f5a.png)

> In **option(b)**, it is only mentioned **decreasing functions** and **f(n) <= 1 and n>=1**, then **option(b)** will be **False** as **Big-O** will not be possible.

![image](https://user-images.githubusercontent.com/54589605/233081061-6fd564b5-1ddd-4014-ae9c-b3ed8e05fbb9.png)

> In **option(c)**, whatever is on the **left side**, that thing's **half** is on the **right side**. If **n** is on the left side, then **n/2** is on the right side.

> The difference is by **constants** only, so **Big-O and omega** are possible and hence, **theta** is also possible.

![image](https://user-images.githubusercontent.com/54589605/233081272-d119322b-e7e2-4fd8-a897-598b05189646.png)
![image](https://user-images.githubusercontent.com/54589605/233081519-8445736c-49c2-4acc-8cf2-42e91e000fc3.png)

> In **option(c)**, it is **True**.

![image](https://user-images.githubusercontent.com/54589605/233082023-197f57a8-fc69-402b-81e5-4de687c6e975.png)
![image](https://user-images.githubusercontent.com/54589605/233081923-9b6dd6ab-2a99-4957-898d-931ae4c5e984.png)

> In one case, **Big-O** is possible and in one case, **Big-O** is not possible. As it has failed in **one** case, it is **fail** only. So, **Big-O** is not possible.

> In **option(c)**, it is **False**. **Big-O** is not possible. The difference is by **function** and not by **constant**.

![image](https://user-images.githubusercontent.com/54589605/233082827-8a5a10f8-2dda-490e-a79b-ec9e384b6169.png)

* 2^n <= c * 2^(n/2) [<=, means **less than equal too** sinn]
* 2^(n/2) * 2^(n/2) <= c * 2^(n/2)
* 2^(n/2) <= c

> So, the **left side** is **bigger**. This also shows that **Big-O** is not possible. With **c** we cannot manage, **2^(n/2)**, the difference is by **function** and not by **constant**.

> One case **fail** also, **fail** only.

> **Option (c) and (d)**, **are different** in the sense that in **Option (c)**, whatever in **left**, keep it in **right** also but **divide it by 2**. In **Option (c)**, the **difference**, is not related with **n**, it is **constant** difference.

![image](https://user-images.githubusercontent.com/54589605/233084565-d9ecfbf6-797d-4b35-9334-114063a9bdda.png)

* For **Option (c)**

> In **Option (d)**, whatever in **left**, keep it in **right** but where ever, **n** is there, replace it with **n/2**. It(n) is creating problem, if it is in the **power**. If it is normally there, then **no problem. If **n** is there in the **power**, then we are **decreasing**.

> If **n** is there on the **left** side then it is **n/2** on the right side. **No problem** as the **difference** is **constant** only. **Big-O** is possible.

> If **2^(2n)** is there on the **left** side then it is **2^(2 * (n/2)) -> 2^n** on the right side. **Problem** is there as the **difference** is **functional** and not **constant**. So, **Big-O** is not possible.

> **Option (D)** is creating trouble, if **n** is there in the **power**. If **n** not there in the **power**, then there is **no problem**.

![image](https://user-images.githubusercontent.com/54589605/233085119-28ef90cc-9418-46c7-b959-b3725a420b96.png)
![image](https://user-images.githubusercontent.com/54589605/233085174-c37afb22-c44f-4dd6-b3b7-8b9f9958e297.png)
![image](https://user-images.githubusercontent.com/54589605/233086873-0e4db431-da39-4f84-968f-02bec92c9a04.png)

* For **Option (D)**

* What about **omega** in **Option (D)**?

> If **n** is there on the **left** side then it is **n/2** on the right side. **No problem** as the **difference** is **constant** only. **Omega* is possible.

> If **2^(2n)** is there on the **left** side then it is **2^(2 * (n/2)) -> 2^n** on the right side. **Problem** is there as the **difference** is **functional** and not **constant**. So, **Big-O** is not possible, but the **left** side is already **bigger**, so **omega** is possible.

> Hence **omega** is possible in **Option (D)**. 

> In **Option (D)**, **omega** is **True**. **Theta** is not possible because **Big-O** is not possible. So, **small-omega(w)** is also possible.

![image](https://user-images.githubusercontent.com/54589605/233088426-022e914c-f57c-4503-a1b8-65d8ee707cd5.png)
![image](https://user-images.githubusercontent.com/54589605/233088565-90183611-98e8-4612-b8e2-e02d20e1cbe1.png)

> Answer is **small-omega(w)**, as **small-omega(w)** means **omega** also.

* **Red line** is **sin** wave
* **Blue line** is **cos** wave

![image](https://user-images.githubusercontent.com/54589605/233126999-4733431e-f6db-4c83-b834-60538e7363cc.png)
![image](https://user-images.githubusercontent.com/54589605/233127287-9730a2d6-1d28-46b3-8960-81492029bcbb.png)

* **f(n)** is with **green color**.
* **g(n)** is with **pink color**.

> We neglected the bases because they are the **same** which is **n** for **f(n) and g(n)**.

> If **bases** are **same**, then only look at the **powers**.

![image](https://user-images.githubusercontent.com/54589605/233128903-d3b423c4-a49d-4b81-98d5-72ca1fb19149.png)

> Base is **same**, see the **power**.

![image](https://user-images.githubusercontent.com/54589605/233129170-89ea266b-ddec-4195-999e-68560107eb8b.png)

> At **0**, **f(n) and g(n)** are at **1** only. They both are **same**.

> At **270 and 360**, **cos and sin** values are the **same**. From **270 to 360**, in between them, **cos** value is **bigger** as **cos 300 = 0.5 and sin 300 = - 0.8 + 1 = 0.2**. **Cos 300** value is **bigger**. 

![image](https://user-images.githubusercontent.com/54589605/233130653-e5c78f37-e8c5-45a0-b104-d6cb6f52a113.png)

* At **0**, both **same**.
* At **90**, **f(n)** is **bigger**.
* At **180**, **f(n)** is **bigger**.
* At **270**, both **same**.
* At **360**, both **same**.

> Sometimes **f(n)** is **bigger**, sometimes, **g(n)** is **bigger**, sometimes, both are **same or equal**.

> So **both** are **not comparable**.

![image](https://user-images.githubusercontent.com/54589605/233131504-58a7cbf8-6905-4328-a513-309d839c292e.png)
![image](https://user-images.githubusercontent.com/54589605/233131656-e72cb0f9-810d-490a-96f8-d4b4159212c1.png)
![image](https://user-images.githubusercontent.com/54589605/233131894-1a152b30-cd7d-4899-bf39-e42b988b3347.png)

* **Green** is **f(n)**
* **Red** is **g(n)**.

![image](https://user-images.githubusercontent.com/54589605/233134699-3c2b375f-de14-49d6-bb5a-afdbab3697ec.png)
![image](https://user-images.githubusercontent.com/54589605/233134778-aad6b835-07dd-4109-92ab-dc1aec941ed7.png)

> They are **not comparable**.

![image](https://user-images.githubusercontent.com/54589605/233137344-31fff011-8243-463f-9c3c-9a90f0c85376.png)
![image](https://user-images.githubusercontent.com/54589605/233139208-1891c78c-82a4-4416-b4d6-2c19fc756f04.png)

> There is **no dilemma**. **g(n)** is **bigger**.

> This will happen for every **360**.

* **Red** is **g(n)**
* **Green** is **f(n)**

> They are **not equal** at any point in time. 

* f(n) = O(g(n)) [True, possible and comparable]
* f(n) = o(g(n)) [Not equal]

![image](https://user-images.githubusercontent.com/54589605/233141522-52584a29-55df-4dbd-b566-626900d81782.png)
![image](https://user-images.githubusercontent.com/54589605/233141583-f2317fcc-cece-4aa4-bf05-f40c4e782afc.png)
![image](https://user-images.githubusercontent.com/54589605/233141820-42d2e35e-7b2f-42c8-8382-3a21d2448e24.png)

> We will not see **small-o or small-omega(w)**, in **GATE** exam. It is for **understanding**.

> Given functions are **trignometric** functions.

![image](https://user-images.githubusercontent.com/54589605/233142562-984771ff-bca0-441e-98ba-1c0c375d3629.png)
![image](https://user-images.githubusercontent.com/54589605/233142600-a975c394-a3d7-4be0-91a1-06a65e4d37ca.png)
![image](https://user-images.githubusercontent.com/54589605/233142984-a09a46d6-a69d-4c88-9703-52c3ca172883.png)


![image](https://user-images.githubusercontent.com/54589605/233142303-f34c1241-216a-4092-baf2-7ffe54830680.png)
![image](https://user-images.githubusercontent.com/54589605/233142335-61a2dab2-ad59-4a96-a1fa-0487edfb8e98.png)

* Next part of **algo**.

## DAC-III (12) [20th April 2023]

> Every **function** has **two** behaviour.

![image](https://user-images.githubusercontent.com/54589605/233239420-df29c4bc-ae12-4c14-9123-b4b4e7e82360.png)
![image](https://user-images.githubusercontent.com/54589605/233239435-daf074e4-d7ea-4f4d-9bd2-012d7a97118e.png)
![image](https://user-images.githubusercontent.com/54589605/233239392-ce4bee75-a90f-44df-95c2-ab9cefa72e6a.png)

> Asymptotic notation means we will bother about **ending**. Just see **ending** part, ignore **starting** part.

> From **100** onwards, **g(n)** is **bigger**.

![image](https://user-images.githubusercontent.com/54589605/233240664-f7cbf929-7f3b-417e-948a-7691d341b12c.png)

* f(n) = O(g(n)) , where **n0=100**.

### Doubt [**IMPORTANT**]

* Link -> https://t.me/c/1432493727/104087

![image](https://user-images.githubusercontent.com/54589605/233244609-53cd922a-ad8d-44de-81d0-a4261aba58b1.png)
![image](https://user-images.githubusercontent.com/54589605/233244636-61e810c1-b330-482b-b5ad-848fa22e82bd.png)
![image](https://user-images.githubusercontent.com/54589605/233244672-a5a5f633-b6e6-47bc-ad7e-b67e69d72718.png)

In the first image it is not comparable but in the 2nd image it is comparable? Why? In the first image the ambiguity was from 270 360 which is at the end. In the 2nd image the ambiguity is from 0 to 99 and it is at the start. That's why? or I am missing something?

![image](https://user-images.githubusercontent.com/54589605/233244702-f4579fb4-a6e4-418f-a1da-7d08aab41d1b.png)
![image](https://user-images.githubusercontent.com/54589605/233244834-864607bf-9e2a-474b-9b07-231d63d601e7.png)
![image](https://user-images.githubusercontent.com/54589605/233244964-ecc08f61-3739-41d1-8687-0d1e147ddbd8.png)

> As in the **first** image, the values where sometimes **bigger** and sometimes **smaller**. It was not certain for sure. That's why it was **not in relation**.

> In the **second** image, from **0 to 99**, **f(n)** is **bigger** but from **100 to 700**, **g(n)** is clearly **bigger** than **f(n)**. That's why we have mentioned that **n0 =100**.

* f(n) = O(g(n), when **n0 =100**.

![image](https://user-images.githubusercontent.com/54589605/233249392-1324c509-49ea-4ff6-aed0-7dc663837259.png)
![image](https://user-images.githubusercontent.com/54589605/233249777-00a0b522-92be-424f-a75e-e8ddba6f0e29.png)
![image](https://user-images.githubusercontent.com/54589605/233249876-89dfb9e3-570f-44ce-8c73-77c65cb6f0b0.png)
![image](https://user-images.githubusercontent.com/54589605/233245619-ef1dca71-9d66-4906-87f7-7e97bcf6b3ee.png)

> Before **100**, it is **ambigious or do not have clarity**, but after **100**, we have **clarity** that **g(n)** is clearly **bigger**.

![image](https://user-images.githubusercontent.com/54589605/233246450-e0980c41-f326-426b-a856-d2fdb887ca2e.png)

> From **0 to 99**, **f(n)** is **bigger** than **g(n)**. So, **n0=1**.

* f(n) = Omega(g(n)), where **n0=1**.

> From **700 onwards**, we are getting clarity that **f(n) and g(n)** are **greater than equal too**.

* f(n) = O(g(n)), where **n0=700**.

> As **both**, **Big-O and omega** possible, then we can say that **theta** is also possible.

* f(n) =Theta(g(n)), where **n0=700**. 

> **n0=700**, since one point is from **n0=1** and another is from **n0=700**. So the **common point** is from **n0=700**.

![image](https://user-images.githubusercontent.com/54589605/233247514-cea7e86a-7637-4305-8391-e6e42af7576f.png)
![image](https://user-images.githubusercontent.com/54589605/233248309-2d74b081-0803-4753-86cb-41fd800fadfc.png)

> All of them **Big-O, omega and theta**, all are **correct**, if given in the **options**.

> As **theta** is possible, we cannot say **small-o and small-omega(w)** are possible.

> Every function having **two** behaviour.

![image](https://user-images.githubusercontent.com/54589605/233248582-2ab7a944-9060-495e-9f43-ae49c3af3df0.png)

1) Reflexive property -> Mirror Image. Both the **sides**, it is the **same person**.

  * f(n) = O(f(n)) -> True
  * f(n) = Omega(f(n)) -> True
  * f(n) = Theta(f(n)) -> True
  * f(n) = small-o(f(n)) -> False [Since, Theta is **True**]
  * f(n) = small-omega(w)(f(n)) -> False [Since, Theta is **True**]

![image](https://user-images.githubusercontent.com/54589605/233250068-436d04fb-2136-4df4-8d6d-da6e69857a6f.png)

2) Symmetric property -> If f(n) = O(g(n)), then, g(n) = O(f(n)). If, A = O(B), then, B = O(A).

![image](https://user-images.githubusercontent.com/54589605/233250303-43a8f200-9a6e-4270-8d0a-59b21cc80071.png)
![image](https://user-images.githubusercontent.com/54589605/233250589-5f537aee-4ec7-4685-9071-85a27ebd8bd5.png)

* n^2 = O(n^5)
* n^5 = O(n^2)

> Symmetric property means that if **first two conditions** are **True**, then the **next two conditions** are **True** or not.

> Not possible.

  * If f(n) = O(g(n)), then, g(n) = O(f(n)) -> False
  * If f(n) = Omega(g(n)), then, g(n) = Omega(f(n)) -> False
  * If f(n) = Theta(g(n)), then, g(n) = Theta(f(n)) -> True
  * f(n) = small-o(f(n)) -> False [Since, Theta is **True**]
  * f(n) = small-omega(w)(f(n)) -> False [Since, Theta is **True**]

> Remember, **theta** possible between **two** people, means that the **two** people are **equal**. We can **reverse** also.

* If, A = B
* Then, B = A [Theta case]

* **Big-O and omega** are not possible, then how is **theta** possible. It is **normal theta** or **conditional theta**?

> It is **conditional theta**, it has nothing to do with **Big-O and omega**. If **first two conditions** are **True**, then the **next two conditions** are **True** or not. It has nothing to do with **Big-O and omega**.

> In **normal theta**, if **Big-O or omega**, either **one of them** is not possible, then **theta** is also not possible.

![image](https://user-images.githubusercontent.com/54589605/233251857-517ae7e2-2802-4c4d-89b2-741dc3def743.png)
![image](https://user-images.githubusercontent.com/54589605/233251940-a0e0dae7-f4c0-4f6a-95aa-d890454ffcce.png)

* Only, **theta** is possible. As it is **conditional theta** and not **normal theta**. **Conditional theta** has nothing to do with **Big-O and omega**. 

![image](https://user-images.githubusercontent.com/54589605/233252171-ef0a267d-f07d-42a9-814f-9fc41089f4b6.png)


3) Transitive property -> If **first two** conditions are satisfied, then the **third** condition should be satisfied as well. If **first two** conditions are satisfied, then only we will go to **third** condition.

> If **first two** conditions are **not satisfied**, then we will not go to **third** condition.

![image](https://user-images.githubusercontent.com/54589605/233252702-200c3bd7-a0ca-4bc6-8677-c56c20e75d25.png)
![image](https://user-images.githubusercontent.com/54589605/233253589-e183d937-5145-4a55-bf2e-dad6a4b28e87.png)
![image](https://user-images.githubusercontent.com/54589605/233253700-e49441b5-ec07-4420-8433-a3213248a796.png)
![image](https://user-images.githubusercontent.com/54589605/233254013-72c8800a-6db1-4e34-a50e-918320ccb03b.png)
![image](https://user-images.githubusercontent.com/54589605/233254067-eb4bb598-a7e0-4c10-ae5d-78c1cb735dcf.png)

* n^2 < n^5
* n^5 < n^9
* n^2 < n^9 [small-o]

* n^9 > n^5
* n^5 > n^2
* n^9 > n^2 [small-omega(w)]

> **Transitive** property is satisfied by **all** of them.

![image](https://user-images.githubusercontent.com/54589605/233254334-017541ec-c545-4394-959b-b80f873bd399.png)

> **Theta** is possible, then how **small-o and small-omega(w)** are possible. **Theta** is **conditional theta**, here.

> In **direct theta**, **small-o and small-omega(w)** are not possible.

![image](https://user-images.githubusercontent.com/54589605/233254697-13febf9f-2d80-42d7-b950-6e95be35d9d7.png)

> Comparing **f(n) and d(n)**, **d(n)** is **bigger**.

> Comparing **g(n) and e(n)**, **e(n)** is **bigger**.

![image](https://user-images.githubusercontent.com/54589605/233256314-ad90a7ae-decc-4c34-a8be-0f216ebf0479.png)
![image](https://user-images.githubusercontent.com/54589605/233256723-31f7c6de-edbd-4fec-a93f-b6606320f65a.png)
![image](https://user-images.githubusercontent.com/54589605/233256808-39488f98-42c1-4c30-b3e1-c7c7a2fa5a7a.png)

* n^5 + n^9 = O(n^15)

> Big-O means right will be **bigger or equal too**, left.

> If we **add** on the **left side**, then we should **add** on the **right side** also.

![image](https://user-images.githubusercontent.com/54589605/233256987-b4f22e7b-1040-4ae5-a37c-d091eceef8d7.png)
![image](https://user-images.githubusercontent.com/54589605/233257647-07cb30eb-82d8-4d73-a348-412bd2bce3c5.png)


* If we **multiply**, **left side** people. What will happen to the **right side** people.

> Previously we **added**, **left side** people. In **Big-O**, **left side** people are **smaller**, **right side** people are **bigger**. If we **multiply**, **left side** people, even though they are **small**, sometimes they will cross **right side** people, **individually**.

* n^5 = O(n^7)
* n^9 = O(n^12)

> On **multiplying**, **left side** people, who are **n^5 and n^9**, we got **n^(5+9) -> n^14**. If we just keep, **d(n) or e(n)** individually, then they will not work out. If we **add** the **right side** people, then we get **n^7 + n^ 12 -> n^12** and it doesn't work out.

![image](https://user-images.githubusercontent.com/54589605/233258599-2047fae7-1977-4e19-b98f-c68eb715a8c9.png)

>  If we **add** the **right side** people, then we get **n^7 + n^ 12 -> n^12** and it doesn't work out

> We **multiplied**, the **left side** people, so **no doubt**, we have to **multiply**, the **right side** people also.

> If  **left side** people are **multiplied**, then, we have to **multiply**, the **right side** people also. Then, it will **always**, work out.

![image](https://user-images.githubusercontent.com/54589605/233258808-9505b936-3f28-4db7-8096-47b7ef691514.png)
![image](https://user-images.githubusercontent.com/54589605/233258863-2c6a5547-c276-430e-890e-1d7e6a676ffb.png)

* If **left side** people are **multiplied**, then **multiply**, the **right side** people also.
* If **left side** people are **added**, then **add**, the **right side** people also.

> **VERY VERY IMPORTANT**.

## Note

1)
![image](https://user-images.githubusercontent.com/54589605/233259135-3a02ea5e-fe93-4b98-92a0-835e03b98413.png)
![image](https://user-images.githubusercontent.com/54589605/233259174-290aa8b4-88bf-4dee-960e-c4be05e4941c.png)

> Taking **maximum** is **addition**, followed by **big-O**.

2)
![image](https://user-images.githubusercontent.com/54589605/233259294-d2995c10-1857-426c-bc01-bb3f82cbd2e6.png)

> If **left side** people are **multiplied**, then **multiply**, the **right side** people also.

3) 
![image](https://user-images.githubusercontent.com/54589605/233259518-35af5966-a8d3-4a40-896a-e6c90b900bd8.png)

> Left side is **decreasing**, right side is also **decreaing**, no problem.

![image](https://user-images.githubusercontent.com/54589605/233259574-61e59e43-1768-4057-b470-aada69220407.png)

> Left is **decreasing**, in the **same way**, right is **decreaing**, so no problem.

> **Same way decreasing** and **Same way increasing**, so no problem.

![image](https://user-images.githubusercontent.com/54589605/233259777-75afaeb4-67df-422a-8d8c-6ac188843f6e.png)

> If we do the **same work**, on **both**, the **left and right** sides, then the **behaviour**, will **not change**.

![image](https://user-images.githubusercontent.com/54589605/233259992-0b538e45-fec4-4b32-9191-903791de9a0f.png)

![image](https://user-images.githubusercontent.com/54589605/233260832-1424fa5c-6392-44cc-ace5-3c01e2101142.png)

> Both the people are having the **same upper bound**, but **no relation** between them. It can be **reverse** also. First is **n^8** and the second is **n^5**. The reverse will be that the first is **n^5** and the second is **n^8**. 

![image](https://user-images.githubusercontent.com/54589605/233261257-4a260fb7-5b05-4b19-b708-d7aac91e2c48.png)

> So, we cannot say anything between **T1 and T2**.

> In **option(a)**, if we **add** left side poeple, then we have to **add**, right side people also.

![image](https://user-images.githubusercontent.com/54589605/233261440-15a62e4d-b1cf-41a6-b24b-ffc7a0d77a5b.png)
![image](https://user-images.githubusercontent.com/54589605/233261465-5b292bc3-1c22-4326-87d7-e769c383a7da.png)

> Between **T1 and T2**, we cannot say anything.

> This is an **MSQ** question.

> **MSQ** question sometimes have **one answer** only.

![image](https://user-images.githubusercontent.com/54589605/233261843-4f36d011-7e19-4fdb-9dea-f7735d74fdbf.png)

* T1(n) = Theta(f(n))
* T2(n) = Theta(f(n))

> When we say **theta**, **T1(n) and Theta(f(n))** are **equal**. **YES**.

> When we say **theta**, **T2(n) and Theta(f(n))** are also **equal**. **YES**.

> So, **T1, T2 and f(n)**, all are **equal**, **YES**.

* A = B
* C = B
* A = B = c

![image](https://user-images.githubusercontent.com/54589605/233262178-ee85d7ab-afd8-436d-89af-72367e9b8ce6.png)

> All(A,B and C) are **Equal**.

> Now **answer** is **all**. **All** of the **options** are satisfied. **Theta** means all **True**.

![image](https://user-images.githubusercontent.com/54589605/233262381-ff85f52c-1612-4917-8896-f2084e6cb902.png)
![image](https://user-images.githubusercontent.com/54589605/233262409-d7edbe5d-2be7-4f84-a250-8f6c64e4c40d.png)

* T1(n) = Omega(f(n))
* T2(n) = Omega(f(n))

> With **omega** also, we cannot get any **relation** between **T1 and T2**.

> Both the people are having the **same lower bound**, but **no relation** between them. It can be **reverse** also. First is **n^10** and the second is **n^8**. The reverse will be that the first is **n^8** and the second is **n^10**. 

![image](https://user-images.githubusercontent.com/54589605/233262945-760d9df1-9fd0-4c58-9a51-41bf100f2d41.png)

> So, all are **wrong**. No option is **correct**.

![image](https://user-images.githubusercontent.com/54589605/233263060-dca8279a-884a-45d1-a5dc-95dbb2d1c5af.png)

* Big-O -> only option **a** is correct.
* Omega -> All are **wrong**. No option is **correct**.
* Theta -> All are **correct**.

![image](https://user-images.githubusercontent.com/54589605/233263485-486678f2-6e6a-435a-a844-86b7ccbf1ab1.png)

> From the **above**, **4** statemenets we have to conclude that the following statements are **True or False**.

![image](https://user-images.githubusercontent.com/54589605/233264468-26f230ec-8f18-43dc-8233-00a4a5684b03.png)
![image](https://user-images.githubusercontent.com/54589605/233264486-54dfcd7a-caff-4f68-bf0e-b96c187b3456.png)
![image](https://user-images.githubusercontent.com/54589605/233264718-44125568-fe73-4a9d-a4ff-d1853ba78229.png)

> Between **two people**, **reverse** as well as **directly** also possible. Which means they are **equal** and **theta** is possible. 

> Between two people, **directly** possible, which means **<=** is possible but **reverse** is not possible, which means **equal** is not possible/there. So it is **small-o** instead of **big-O** as **reverse** is not possible, so, **equal** is not possible/there.

![image](https://user-images.githubusercontent.com/54589605/233265377-d49c4bdd-3e87-4999-a9ce-a7d08c5faf67.png)

* If **direct and reverse** possible then they are **equal**.
* If **direct** is possible then it is **<=** and **reverse** is not possible, so, **equal** is not there. So, it is only **<** only.

![image](https://user-images.githubusercontent.com/54589605/233265616-1b105ee0-3eb1-46f8-baf2-d2a424d22b3a.png)

* A = O(B) [Possible]
* B = O(A) [Not possible]

> Between two people, **A = O(B)** is possible and **B = O(A)** is not possible, then **reverse** is not possible. Which means **A < B**. **Theta** not there, so **equal** is not there. Only **<**(less than) is there.

![image](https://user-images.githubusercontent.com/54589605/233266037-ea64810a-b16a-40f9-8cc6-882378fe8b9f.png)

* f(n) < g(n) = h(n)

> **f(n)** is **smaller**. **g(n) and h(n)** are **bigger** as they are **equal**.

> In option **a**, left side is **smaller** and right side is **bigger**, so **big-O** is possible. Option **a** is **correct**.

> In option **b**, on the left side among **f(n) and g(n)**, **g(n)** is **bigger**, so it will dominate the **left side**. So, **g(n) = O(h(n))** is possible, as they are **equal**. Option **b** is **correct**.

> In option **c**, on the left side, **f(n) and g(n)** are **multiplied**, one **smaller** and one **bigger** respectively are **multiplied**. On the right side, **g(n) and h(n)** are **multiplied**, both are **bigger** are **multiplied**. 

> So **both** the sides are **not equal**. Hence **theta** is not possible. Option **c** is **not correct**.

![image](https://user-images.githubusercontent.com/54589605/233267260-d779fc13-be74-47ff-874c-26da3eff2da0.png)

> In Option **c**, if we keep **Big-O**, instead of **theta**, then, option **c** would have been **correct**.

![image](https://user-images.githubusercontent.com/54589605/233267503-dd80ec19-1e57-406a-8ea9-e64649feef81.png)
![image](https://user-images.githubusercontent.com/54589605/233267644-7f48ad79-e1c6-4570-ac12-b5e196f9f432.png)

> In Option **d**, left and right side, both are **bigger**. So they are **equal**, hence **theta** is possible. So, Option **d** is **correct**.

* A, B and D are **correct**.

![image](https://user-images.githubusercontent.com/54589605/233764629-14b6796c-7142-426a-b3f8-79d613be1f6a.png)
![image](https://user-images.githubusercontent.com/54589605/233764633-fe897356-eade-44bd-85ce-bc174af6a579.png)


## GT-III (13) [20th April 2023]

## Recursion

> Function calling itself is known as **Recursion**. [**Point One**]

> It maybe close to **starting**. It maybe close to **ending**. Most of the time, calling is in the **middle**.

![image](https://user-images.githubusercontent.com/54589605/233365940-d98e8200-35ed-421a-89be-8d49b76ff3af.png)
![image](https://user-images.githubusercontent.com/54589605/233366241-2d367a46-4dbf-475c-9e99-983c03d0a436.png)

* Fact(6) -> 6 * Fact(5)
* Fact(5) -> 6 * Fact(4)

> At anywhere we know, **go back**. Worst case, is **fact(1)** and everyone knows, **fact(1) = 1**.

![image](https://user-images.githubusercontent.com/54589605/233366468-ee619eba-2f5f-49a4-be14-0f25ef40dc50.png)


* Coming down -> Function calling(PUSH operation)
* Going up -> Return(POP operation)

> **Fact(1)** is the **first** function completed and **popped**. Then, **fact(2)** is **popped**.

* **Fact(6)** -> **Fact(5)** -> **Fact(4)** -> .... -> **Fact(2)** -> **Fact(1)** [Sequence of **PUSH**]

* **Fact(1)** -> **Fact(2)** -> **Fact(3)** -> .... -> **Fact(6)** [Sequence of **POP**]

> How many **push** operations, that/those many **pop** operations as well.

> If **push** operations is **7** and **pop** operations is **6**, then there is **no meaning**.

> If **push** operations is **7** then **pop** operations should be **7** only, otherwise something is **stuck** in the **stack**.

> For getting the value of **Fact(6)**, we need all of them from **Fact(5) to Fact(1)**. We need to **store** them in **one data structure** and that data structure is **stack**.

* Among all of them, **Fact(6)** is called **first**.
* Among all of them, **Fact(6)** is completed **last**.
* Among all of them, **Fact(1)** is called **last**.
* Among all of them, **Fact(1)** is completed **first**.

> That's the meaning of **stack**. Stack is **LIFO**, **last in first out**.

> Why stack and why not **queue**, because in queue, **Fact(6)** is called **first** and **Fact(6)** is completed **first**, which doesn't give the **desired result**.

> That's why **stack** used.

> For **recursion** programs, **stack** data structure is used. [**Point Two**]

![image](https://user-images.githubusercontent.com/54589605/233371190-50db29ba-eea4-446d-9493-99b59c3a6e28.png)

> We are completing **Fact(6)**, using **Fact(5), 4, 3, 2 and 1**.

> We are completing **Fact(5)**, using **Fact(4), 3, 2 and 1**.

> We are completing, **bigger** problems, with **smaller** problems. **Recursion** is nothing but solving **bigger** problems, in-terms of **smaller** problems. [**Point three**]

![image](https://user-images.githubusercontent.com/54589605/233372140-a215d383-e9b4-45e7-91d7-6d8b333677fc.png)

> **Divide and Conquour** is nothing but **recursion**.

![image](https://user-images.githubusercontent.com/54589605/233373752-c8e0a8ec-4f6c-4513-b701-09923959e324.png)
![image](https://user-images.githubusercontent.com/54589605/233375372-17e939b2-5d83-466a-96d1-64d81107a3d3.png)


> Every **function call** is a **PUSH** operation.

* Stack Overflow -> Stack Error Message, when **memory** full.

> Every **recursive** program, must have or should have **termination** condition. Otherwise we will get an **error message while running**, which is **Stack Overflow**.           [**Point Four**]

> **Stack Overflow** is a **run-time** error message. It is not **compile** time.

> Some **compile** time, errors are **type mis-match**, **semi-colo missing**, **undeclared variable**, **multiple declaration**.

* In a given recursive program, termination condition is not given. What will happen?

A) Infinite loop -> **NO**. Space is **limited**. Not possible.

> The program will **stop** at some point in time by giving an **error message** that is **Stack Overflow**. [**Correct Answer**]

![image](https://user-images.githubusercontent.com/54589605/233379463-e5048c47-ba51-477a-bf76-f967a99c816a.png)
![image](https://user-images.githubusercontent.com/54589605/233379876-d1ac27c6-258e-4c17-b507-dbd81e082e95.png)

* Recursive program

![image](https://user-images.githubusercontent.com/54589605/233381167-148509de-7232-41dd-8c22-156e65d5c30b.png)
![image](https://user-images.githubusercontent.com/54589605/233381529-a2701d50-09b4-453f-8f36-bb24a1d93457.png)

> **White** color is **going down**, which means **POP** operations which is **return** statements.

> **Red** color is **going up**, which means **PUSH** operations which is **function call**.

* Whenever **recursion** is going on, **many** function calls are there. From **one** function call to **another** function call, what will be the **difference**.

> The **function name**, remains the **same**. Everywhere **f(n)**.

> The **function code**, remains the **same**.

> The **local variables name**, remains the **same**.

> The **no. of local variables**, remains the **same**.

> The **value of local variables**, will **change**.

> Whenever **recursion** is going on, **many** function calls are there. From **one** function call to **another** function call, **parameter value** will **change** but not the **no. of parameter, parameter name, function name, function code**, these will not change. [**Point Five**]

> Somethings should **change**, if **nothing** is **changed** then it will never **terminate**.

![image](https://user-images.githubusercontent.com/54589605/233387648-628bbce9-c17d-4572-a169-875192d9705d.png)

* Parameter value is only **changed**, rest are the **same**.

![image](https://user-images.githubusercontent.com/54589605/233387768-00205e1e-a456-491d-a438-08a0a1b16de1.png)
![image](https://user-images.githubusercontent.com/54589605/233388226-d00fb78e-8162-40c5-9f8a-43f728977cf6.png)
![image](https://user-images.githubusercontent.com/54589605/233388816-f3b9bdfb-0f11-4d29-86ea-b5f5ab65a740.png)

* It is **Non-recursion**.

> The **above** program with **for loop**, will call the **fact(n)** function only **1 time or once** to calculate the **factorial of 6**. Inside loop, running many time but the function **fact(n) or fact(6)** when **n=6** is called **1 time or once**.

> **Fact(6)** is not calling anyone else. **1 time or once** function call.

> **1 time or once** function call, means **1 PUSH** operation.

> So, in the **Non-recursion** program, only **1 PUSH** operation is required as there is **1 time or once** function call. Whereas in the **recursion** program, **6 PUSH** operations are required as **6** function calls are required.

> In terms of **space**, most of the time **non-recursion** programs are **better**.

>  Most of the time, **recursion** will take **more space**, because of **more** function calls.

>  Most of the time, in **non-recursion**, it will take **less space**, because of **less** function calls.

* For **every recursion**, **non-recursion** is possible. [**Point Six**]

![image](https://user-images.githubusercontent.com/54589605/233392404-c4211085-f66c-4417-b9a9-c95d7a58e13a.png)

> Most of the time, **recursion** program takes **more** stack space and **non-Recursion** program takes **less** stack space. [**Point Seven**]

![image](https://user-images.githubusercontent.com/54589605/233393302-9b356f7d-c181-47bb-b58b-217fa7d96cb2.png)

> **Non-Recursion** program takes **less** stack space than **recursion** program for most of the time but in **some cases**, they will take the **same** amount of time.

> Comparing **recursion and non-recursion**, recursion will take **more stack space**, **most** of the time, comparing with **non-recursion** because of **more** function calls.

> Sometimes, **equal** also. [Explained later]

> **Space complexity** for **non-recursion** programs is **constant**.

> For every problem, **space complexity** is **constant**.

> **Space complexity** for **recursion** programs is not **constant**, we have to find it out.

![image](https://user-images.githubusercontent.com/54589605/233403169-38317b01-64d6-4936-a714-5c7c7c429844.png)
![image](https://user-images.githubusercontent.com/54589605/233404014-8cdc13ed-9c7e-40a1-9a17-3ede093132a7.png)

* Non-recursion program

> **Time complexity** is how many **times**, loop is running. **Time complexity** means loop.

> In the above program, there is **loop**. **YES**. The loop is running **n times**. So, the **time complexity** of the program is **O(n)** as loop is running **n times**.

![image](https://user-images.githubusercontent.com/54589605/233404058-52a06cd9-f64c-487e-911d-78974cdcc720.png)

* Recursion program.

> There is **no loops** but the function is calling itself, **n times**. So, the **time complexity** of the program is **O(n)** as the function is calling itself, **n times**.

> So, indirectly, the **time complexity** of both the **recursive and non-recursive** programs are the **same** which is **O(n)**.

![image](https://user-images.githubusercontent.com/54589605/233404822-88096c50-e054-4699-b03e-eec688c693ac.png)

> So, internally, it is doing the **same** thing only. Everytime **one no.** multiplication.

* 5 * 4 * 3 * ... * 1.

![image](https://user-images.githubusercontent.com/54589605/233405145-d03450af-94d6-4c86-9dbc-0fc67eedfda5.png)

> We are doing the **same***, everytime **one no.** multiplication in **non-recursive** programs as well.

![image](https://user-images.githubusercontent.com/54589605/233405379-0636ad4b-fcfd-441d-94c6-fd34936ab0c5.png)

> Different ways of writing.

> Calling myself, it is **loop** only.

> Indirectly **loop** in **recursion** programs and direct **loop** in **non-recursive** programs.

* Which will take more time? **recursion** or **non-recursive** programs?

> They will take **same** amount of time**.

![image](https://user-images.githubusercontent.com/54589605/233405909-c46cb4f0-70d2-4667-8654-91420a4010de.png)
![image](https://user-images.githubusercontent.com/54589605/233406146-2d457975-80b4-4c76-a840-7d8bd20a0b70.png)

> **Time complexity** is based on **logic** and not on **recursion or non-recursion** program.

> **Recursion or non-recursion** programs will not decide **time complexity**, but the **loops or logic** will decide, **time complexity**.

> **Time** point of view, no **discrimination** between **recursion and non-recursion** programs. **Time** is **same** for **both**.

> **Space** point of view, there is **discrimination** between **recursion and non-recursion** programs, because in **recursion**, more **function call** and more **PUSH** operation. In, **non-recursion**, less **function call** and less **PUSH** operation.

[**Point Eight below**] 

> **Recursion and non-recursion** programs will take **same time**, because of **same logic**. If different logic, then both will have different logic, then different time. If logic changes, time will also change.

> **Logic** will decide, **time complexity** and not **recursion and non-recursion** programs.

> **Space complexity** is based on **recursion and non-recursion** programs, because in **recursion**, **more** function calls. In **non-recursion**, **less** function calls. Sometimes, **both** maybe **equal**, but most of the time, **recursion** having more space.  

* In **non-recursion** programs, **1 time or once**, **PUSH** operation and **1 time or once**, **POP** operation .
* In **recursion** programs, **n times**, **PUSH** operation and **n times**, **POP** operation.

> Mathematically, **recursion** will take **more time**. **n time** PUSH and **n time** POP, so, **2n** operations. But in **non-recursion**, one time loop and **n**, one time **PUSH** and one time **POP** but loop is **n** time.

> Asymptotially, **2n and n** are **same**, so, they will take **same time** because of **same logic**. But mathematically, **recursion** having some **over-head**.

> Forget about **constant**, even though **recursion** having some **over-head**, in-terms of **PUSH and POP**. That is **negligible** because of **some constant**.

![image](https://user-images.githubusercontent.com/54589605/233410838-1083022e-e8c6-4b1a-9963-aba3587027a3.png)

## Recurrence Relation

> Recursion program having **two** part.

![image](https://user-images.githubusercontent.com/54589605/233414629-fd9a6634-f388-4c9b-8094-0214196fba1e.png)
![image](https://user-images.githubusercontent.com/54589605/233414849-a791e7eb-1a42-40d6-8aa2-7962da1b513d.png)

* This is called as **recurrence relation** for **fact(n)** value.
 
* For every **recursive** program, **recurrence relation** is possible? 

> **YES**.

## GT-IV (14) [21st April 2023]

* For every **non-recursive** program, **recurrence relation** is possible? 

> **YES**.

> Every **recursive** program, contains **two** parts, **base condition** and **function calling itself**.

![image](https://user-images.githubusercontent.com/54589605/233677216-13e9bec0-11ff-460b-80bf-7e9ffa684535.png)
![image](https://user-images.githubusercontent.com/54589605/233678878-7cd48818-45f4-4209-b392-59e4fad7aa0e.png)

## Recurrence Relation Time Complexity

![image](https://user-images.githubusercontent.com/54589605/233681596-685141b3-f645-4c6a-b33b-437a0322ab25.png)

* **T(n)** is time complexity of **fact(n)**.

> In the **return or else** part, there is no **loops**. Recursion is there.

> **Multiplying** one number, takes **constant** times. That's why we have put **+ c** with **T(n-1) + c**.

![image](https://user-images.githubusercontent.com/54589605/233686524-0205f184-fab2-4730-be75-ba4d59207152.png)

> With **time compleixty**, the **loop** key-word should come immediately.

> In **time compleixty, recurrence relation** and **value, recurrence relation**, one thing is **common**, which is **recursion**. Only **names** will **differ**.

![image](https://user-images.githubusercontent.com/54589605/233687407-f2fd77e1-f17b-435d-84a6-a469d53ea92d.png)

> Until and unless, we see **loops(for or while)**, don't write **n**.

> As a **programmer**, we will take care of **first level**, remaining **recursion** will take care.

## Recurrence Relation of multiplication

> We have to calculate, no. of multiplication.

> We have **one only** multiplication in the **2nd part** of the recursion. 

> Don't worry about **all** the levels. Just do the **first level**. Whatever we are able to see, do that only. Don't do everything. Remaining thing will be do by **recursion**.

> In the **first level** only, we can see **one only** multiplication.

![image](https://user-images.githubusercontent.com/54589605/233690417-8f457f98-97f6-40d2-8d47-e7fa705b07f4.png)

> In **every** area, **recursion** is common. Remaining things a little bit differ.

* If we want to find the **time complexity** of any **recursion** program?

> First, write the **recurrence relation for time**.

![image](https://user-images.githubusercontent.com/54589605/233693592-6bf7b41c-63cf-43a5-a43d-3593c46ae086.png)

* If we want to find the **no. of multiplication** in a given **recursion** program?

> First, write the **recurrence relation for no. of multiplication**.

![image](https://user-images.githubusercontent.com/54589605/233694076-c5b259cd-9a3f-4567-9639-d435a3c69446.png)

## Solving Recurrence Relations

1) Substitution method
2) Recursive Tree method
3) Master's theorem

![image](https://user-images.githubusercontent.com/54589605/233694864-dde1d058-98b7-4218-a20d-0cf212e8df2e.png)

## Substitution method

![image](https://user-images.githubusercontent.com/54589605/233695177-ecb1378a-6019-4a35-ade3-9e3afdecaa4f.png)

* We want to find the **time complexity** of **above** program?

> We will use the **recurrence relation of time**.

> Don't think much about **if** condition, it is for **termination** purpose. Think about **else** part.

![image](https://user-images.githubusercontent.com/54589605/233697080-3aaee42e-c026-4904-bb18-6c3e216283e9.png)

> Among **T(n-1) and C**, **T(n-1)** is the **recursion**. **C** is the **non-recursion**.

> We have to **expand** the **recursion**, **non-recursion** cannot be expanded.

![image](https://user-images.githubusercontent.com/54589605/233697401-e82c49ef-a401-4792-b906-37b345b07a44.png)
![image](https://user-images.githubusercontent.com/54589605/233697573-31f71b9b-ec2d-4fd4-95fd-847a455f7e36.png)

> Every level, **one** constant is coming.

![image](https://user-images.githubusercontent.com/54589605/233698222-6264a3f6-3e69-411d-b1e4-dfa9b4aabd3a.png)

> **T(n-k)** is the **recursive** term.

> To stop the **recursion** on the **recursive** program, we need the **termination or base condition**.

> We want to stop **T(n-k)**, so **n-k = 1** and we need to find the value of **k**, which is **n-k = 1 -> n = k + 1 -> k = n-1**. So, **k** value is **k = n-1**.

> **T(1)** is **constant** time or **O(1)**.

> The **bigger** function is **n**, so asymptotically it is **O(n)**.

![image](https://user-images.githubusercontent.com/54589605/233700147-cc09d5ca-12f4-4f48-88a6-e2dc307db478.png)
![image](https://user-images.githubusercontent.com/54589605/233700407-b4b5c1d3-885b-4cc9-b6c3-0ea3aa03d24b.png)

> **Substitution method** means **substitution, substitution and substitution**, until **termination** happens. For **k** value of **k=n-1**, termination happened.

> We will **expand** the **recursive** term.

![image](https://user-images.githubusercontent.com/54589605/233758367-d50470c5-87ab-4b44-bb8e-88cf15239ee1.png)

> The above **recurrence relation** is for **time**, that why we got **time**.

> If the **recurrence relation** is for **value**, then we would get **value**.

> If the **recurrence relation** is for **no. of multiplication**, then we would get **no. of multiplication **.

### Value

![image](https://user-images.githubusercontent.com/54589605/233758709-d9b4f641-f9cf-4db0-b8d2-2e0a6df0e97b.png)

> If we solve the **above** one then we will get **value**.

> **Recursion** is **important**.

![image](https://user-images.githubusercontent.com/54589605/233758736-c210dcc9-673c-4d39-86c4-e49c6313fe58.png)

> Expand only **recursion**.

![image](https://user-images.githubusercontent.com/54589605/233758859-2fac867d-d4e2-4c0a-8817-ef507ad83e7b.png)

> If we substitude **3** times, then we will get **3** non-recursive terms.

![image](https://user-images.githubusercontent.com/54589605/233758972-090d3a66-5d71-4a38-85bf-74ccb6f4af38.png)

> Always substitude for **3** times.
 
![image](https://user-images.githubusercontent.com/54589605/233759087-4269be1f-92ce-4c94-9aa0-0a0556f44a5d.png)

> If we substitude **2**, then everything will come in-terms of **2**.

![image](https://user-images.githubusercontent.com/54589605/233759198-6f9b5dfa-faae-4259-b989-edf9d4cef98b.png)

> After going **3** times, we will go for **k** times.

> To stop **T(n-k)** recursion, we have to put **n-k=1**, as **1** is the **termination condition** here and we get the value of **k**. The value of **k** is **n-1** and we substituted **n-1** in place of **k** in the equation.

> After substitution, only the **first** term is having **T** and the 2nd term is not having any **T**. Only the **first** term having **T** and the rest terms not having **T**.

![image](https://user-images.githubusercontent.com/54589605/233759412-2b65d574-5d99-4aee-812d-a127932ed198.png)

> This is the **recurrence relation** for **value** and we got **value** which is **n!**.

* If we written for **value**, value will come.
* If we written for **time**, time will come.
* If we written for **no. of multiplication**, multiplication will come.

* All of the **recurrence relation** came from the **same program**.

* One **recursive** program, having many **recurrence relation**.

* Explain **substitution method**.

> Substitude the given function again and again, until **termination** condition will happened.

1) Substitude the given function for **3** times.
2) We have to find the **pattern** for substitution. After **3rd** step, we will stop and observer to find the **pattern**.

![image](https://user-images.githubusercontent.com/54589605/233759917-32d1f2c2-405c-43ce-87a2-012fa5448bf0.png)
![image](https://user-images.githubusercontent.com/54589605/233759935-7dc06382-d6d9-46d8-8870-3976e84c0129.png)

* We did with **recursion**.

> We are **substraction by 1**, that's why we getting **one-one** difference.

> If we are **substraction by 2**, then we will get **two-two** difference.

> Whatever we substract, accordingly the **difference** will come.

![image](https://user-images.githubusercontent.com/54589605/233704226-467672ee-2cae-47b0-927a-b0b86bb9b4ad.png)
![image](https://user-images.githubusercontent.com/54589605/233704487-e4838f75-f246-4b7a-af33-153d37c79582.png)

> If we substitude **3**, then everything will come in-terms of **3**. As, we did in **3**, that's why **T(n-3)** came. That **3** is **3** times.

> To stop **T(n-k)**, we have to put **n-k=1**, as **1** is the **termination** condition and it is **T(1)** and we get the value of **k**. The value of **k** is **n-1** and we substituted **n-1** in place of **k** in the equation.

> So we got **n!**. **n!** is the **actual answer**.

> If **n!** is not there in the options then, **n! = O(n^n)** and **n! = omega(2^n)**.

* **n^n** is **bigger** compared to **n!**.
* **2^n** is **smaller** compared to **n!**.

> **Big-O and omega** are not **exact** they are **upper and lower** bound respectively.

![image](https://user-images.githubusercontent.com/54589605/233705313-2b5853f1-6026-4b99-a776-e7778edf4e42.png)
![image](https://user-images.githubusercontent.com/54589605/233760329-55cf651a-0cad-446e-a84f-920ec3cf3585.png)

> If **n!* is not there in the options then, **upper bound** with **O(n^n)** or **lower bound** with **omega(2^n)**, will be there.

* One recursion program in **GATE** exam will be given. Find the **time complexity** of the recursive program.

> Write **recurrence relation** for **time**.

![image](https://user-images.githubusercontent.com/54589605/233760472-74046fec-b169-4614-a8cd-7c23e43b6bd8.png)
![image](https://user-images.githubusercontent.com/54589605/233760485-84ec8ae1-bb5c-4b60-a753-54ca4570d372.png)
![image](https://user-images.githubusercontent.com/54589605/233760493-2e5be1b3-7591-4585-bf8b-bf62fa0850dc.png)

> There are **3** methods but out of all of them **substitution** method is the **most** powerful.

> **Substitution** method  will solve every problem.

> For every **recursion** program, write it's **recurrence relation** and after that, solve it using one of the **3** methods.

## Fibonacci Series

![image](https://user-images.githubusercontent.com/54589605/233760752-75171d36-7081-4ead-9926-bcf000abdad2.png)
![image](https://user-images.githubusercontent.com/54589605/233762479-02aba72a-0233-4f36-bae3-504045580e1e.png)

> Previous **two** summation will give **next**.

> Fibonacci series having **two** termiantion conditions.

![image](https://user-images.githubusercontent.com/54589605/233762646-c7d54a1e-9cb5-4340-ae46-73d45347fab9.png)
![image](https://user-images.githubusercontent.com/54589605/233762811-f88b5a48-7914-4ae2-9b8f-91ff447a8d90.png)

> We are substituting **two** times. So **Binary tree** coming.

![image](https://user-images.githubusercontent.com/54589605/233762872-f6d32a93-bcd2-4364-83b5-b00a51f6e236.png)

* Binary Tree.

![image](https://user-images.githubusercontent.com/54589605/233762838-974f71bd-644b-4006-bff1-a917f08bcedc.png)

> It was **uniary** tree in the **previous** problem, as we were substituting only **one** time.

* Write **3** recurrence relations(value, time and additions) for the **fibonacci series** program.

![image](https://user-images.githubusercontent.com/54589605/233764649-988fb885-2194-43c7-b95c-78168b4d500b.png)
![image](https://user-images.githubusercontent.com/54589605/233764653-82063169-8bc8-41c5-a785-42cdaa0ccd6b.png)

> Above **3** recurrence relations(value, time and additions) for the **fibonacci series** program.

* Wrong. **n=1 and n=0** should be **together**, like is **below** shown by **sir**.

![image](https://user-images.githubusercontent.com/54589605/233766292-f9859931-e76c-4570-8941-8aa6cb1d80a5.png)



## GT-V (15) [22nd April 2023]

> If **loop** is there, then only write **n**. Otherwise simply write, **+ c***.

> Recursion people, everywhere same. Remaining things will only **differ**.

* Write as it is, the **else** part, it is the **recurrence relation for value**.
* Thinking about **loop**, it is the **recurrence relation for time complexity**.
* Thinking about **addition**, it is the **recurrence relation for addition**.

![image](https://user-images.githubusercontent.com/54589605/233765377-0ecfb03a-7d50-451d-b78d-8932e09a4c23.png)
![image](https://user-images.githubusercontent.com/54589605/233766305-887431a6-5ac9-49d6-9525-e3748a2d1028.png)
![image](https://user-images.githubusercontent.com/54589605/233766357-de3a5576-d315-492f-be0c-79903d629cff.png)

> Beacuse **one** addition(+) is there in the **else** condition.

> As there is no addition(+) is there in the **if** condition, that's we put **zero(0)**.

> In the **else's** place there is **no loop**, that's why time complexity is **constant**, so, **+ c** in the **recurrence relation for time complexity**.

> In **recurrence relation for value**, nothing to discuss, as it is. 

![image](https://user-images.githubusercontent.com/54589605/233766508-378b8e99-1f37-4550-862e-3075644e895b.png)

> We have to solve **recurrence relation for time complexity** to get the **time**.

> In the above recurrence relation, more than **one** function calls is there.

> It is taking time using **substitution method**, that's why we are using **recursive tree method**.

## Recursive Tree method

![image](https://user-images.githubusercontent.com/54589605/233766841-12f6b0d3-8e75-498d-9538-777123a13b12.png)
![image](https://user-images.githubusercontent.com/54589605/233766959-52b93d54-7e17-4912-a732-e6aa65be82ff.png)

> As there is more than **one** function calls, that's why we are using **recursive tree method**.

> More than **one** function call, **recursive tree method** is **better**. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/233767027-ef04f944-a5d4-45ce-8a1c-e14d02eda417.png)

* Tree better.

> We will use **substitution** method when there is only **one** function call.

> **One** function call is there, that is also a **tree**, which is a **1-ary tree**.

> For **three** function call, **recursive tree method** is **better**. **3-ary tree** will come here.

![image](https://user-images.githubusercontent.com/54589605/233767306-7af90827-e822-40d7-bbef-8e812c0242e2.png)

* Recurrence Relation for **time complexity**.

> We cannot write **T(n/2) - T(n/2)**, since there is **no meaning** of **time complexity** substraction. As there are **two** function calls, we have to **add** the **time complexities**, even though there is **minus(-)** sign in between them. That's why we had to write, **T(n/2) + T(n/2) + c**. **+ c** is the **constant** time required to do the **substraction**.

> As it is if we **write**, that is called as **value**. **T(n/2) - T(n/2) - n**, this is called as **value**.

![image](https://user-images.githubusercontent.com/54589605/233767839-53869811-90c4-4b6b-a7e4-c33e804a2520.png)
![image](https://user-images.githubusercontent.com/54589605/233767886-ee8f74d2-c566-4dbf-8b8a-5ffeb84a50b5.png)

> Simplification is possible and now it looks like **one** function call, instead of **two** function calls. We can do **substitution** method for that reason.

> But in **T(n-1) + T(n-2)**, simplification was not possible and it remained as **two** function calls, so we couldn't do **substitution** method there and had to use **recursive tree method**.

![image](https://user-images.githubusercontent.com/54589605/233768003-45d0df7a-5f42-4f13-a630-676854845534.png)

> In **recurrence relation for time complexity**, we would never see **minux(-)**.

> **Minux(-)**, would be possible for other **recurrence relations**.

> Until, **3** rounds/steps are **over** and the pattern is **identified**, don't do simplification. Keep it, as it is.

![image](https://user-images.githubusercontent.com/54589605/233768449-b775285e-82d5-4c38-a033-f56e23231369.png)

* 2 rounds are done.

> After **3 rounds are done**, whatever came, it is in-terms of **3** only. Everything is in-terms of **3**.

![image](https://user-images.githubusercontent.com/54589605/233768756-ba9e12cb-f5e0-409d-9e8b-c56a2b1c6f2d.png)
![image](https://user-images.githubusercontent.com/54589605/233768858-822f5309-caa5-4f66-8581-2510b30632f4.png)

> Until identified the **pattern**, don't do simplification.

> After **k** times, **recursion** is still there. To stop the recursion, **T(n/2^k=1**, since **1** is the termination condition.

![image](https://user-images.githubusercontent.com/54589605/233769141-968aa22c-daf8-494c-882e-7805f9fe1278.png)
![image](https://user-images.githubusercontent.com/54589605/233769221-ef01b77f-bba9-466e-9b98-5989c871c6da.png)

> If **termination condition(if condition)** not given in **GATE** exam, then take some **termination condition(if condition)** for **stopping** purpose. We can take some **constant**.

![image](https://user-images.githubusercontent.com/54589605/233769264-1c09fb1b-9fac-4612-83c1-c7a0c3974f44.png)
![image](https://user-images.githubusercontent.com/54589605/233769301-0d024c99-251a-4e20-8bc8-90daecd4d2ee.png)

> Out of those **three** all are **right/correct**. Anyone we can use. All **three** we can use.

![image](https://user-images.githubusercontent.com/54589605/233769555-1054dff3-5e71-44a8-ba76-05e0e3b666d3.png)
![image](https://user-images.githubusercontent.com/54589605/233769716-d7a7b581-d66b-4c9a-a4ae-23aa1d1d4971.png)
![image](https://user-images.githubusercontent.com/54589605/233769800-dce07ec1-9b15-4568-8afc-38ac920f515f.png)

* GP series formula. [**IMPORTANT**]
* Sum of **n** terms in the GP series.
* [a * (r^n -1)]/(r-1) -> Formula
* a -> 2^0 [First element]
* r -> 2  [First element]
* n -> log n terms. [No. of terms]

![image](https://user-images.githubusercontent.com/54589605/233769642-97ddc9d0-96b0-4441-a666-68d022e22f44.png)
![image](https://user-images.githubusercontent.com/54589605/233769653-111f55cc-15d5-437b-811e-a327c01e28b1.png)

* Log formula

![image](https://user-images.githubusercontent.com/54589605/233769671-cb66edf1-f278-4860-80cc-b9c3cd56abcd.png)

* O(n)

![image](https://user-images.githubusercontent.com/54589605/233769780-2b2935fa-53d4-4cf3-bf71-98ea38bbb7e5.png)

## Steps for **Substitution method** [**IMPORTANT**]

1) Substitution method is **easy**, if we do first **three** rounds properly.

2) First **three** rounds, don't do any simplification. Keep it as it is.

3) Do **three** rounds properly. Automatically remaining all will come.

4) After **three** rounds are over, observe **pattern**.

5) After **pattern** found, go **k** times.

6) After **k** times are over, find **k** value.

7) Some **series** will come, **solve** it.

![image](https://user-images.githubusercontent.com/54589605/233770029-14819136-2042-4b17-96d0-8c4f70656cf4.png)
![image](https://user-images.githubusercontent.com/54589605/233770040-fb1363aa-6407-42a0-8a16-b7399ad77269.png)

> Time complexity cannot be **negative**. Time complexity is about **loops**. Small small **minus(-)** operations will take **constant** time.

> How substracting **two** numbers can be **negative**. It cannot be **negative**.

> Substracting, multiplying, adding **two** numbers is **constant** time.

> Time complexity means **time** only. It cannot be **negative**.

![image](https://user-images.githubusercontent.com/54589605/233770160-2277cac2-17c4-4bfa-ac84-ab43d9effcb2.png)

> Until **yellow** part it is substitution method. Afterwards, normal mathematics.

> The actual answer is **n + c * (n-1)**. **n** is the **larger** function.

> Left and right side, **larger** function is same we can write **theta** also, which is **theta(n)**.

> We could write, **O(n^2)** also, as **big-O** means **right** side is **bigger**.

> We could write, **Omega(1)** also, as **omega** means **right** side is **smaller** or **left** side is **bigger**, same thing.

![image](https://user-images.githubusercontent.com/54589605/233770673-1f5c3a3b-b22c-4553-899b-6f278df02402.png)

> All are **correct**.

![image](https://user-images.githubusercontent.com/54589605/233770685-76df770a-b146-4bc3-8bcf-5fc1cd18be60.png)

* YES. 

![image](https://user-images.githubusercontent.com/54589605/233787571-8999712b-f02c-4028-95bb-7ae9fb5f61e5.png)
![image](https://user-images.githubusercontent.com/54589605/233787452-41d8c2d6-b4de-4783-b60d-5072aa03b510.png)

* O(n^(log 7 base 2).

![image](https://user-images.githubusercontent.com/54589605/233788388-ae6b1034-2736-49af-9bd1-ef933ccc4a72.png)
![image](https://user-images.githubusercontent.com/54589605/233788650-6fe4c4b7-4ec5-4bb9-b100-539656ab77b4.png)

* All are **correct**.

> Explained how to solve, **Even no. squared series**. [**IMPORTANT**]

> Explained how to solve, **'N' natural no. squared series**. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/233789454-850bcaae-ff22-44fc-aa4f-69057b3cbc80.png)

* **'N' natural no. squared series** formula **minus(-)**, **Even no. squared series**, we get **odd numbers**
* n*(n+1)*(2*n + 1) - [(n/2) * [(n/2 + 1)] * [(2 * n)/2 + 1]] -> **O(n^3)**
* **O(n^3)**

![image](https://user-images.githubusercontent.com/54589605/233788875-da75f67e-4d17-49f9-ae0f-0b55a89b6ae0.png)

> **Recursion** means we are doing **many** times. Everytimes, **one term** will come.

> If at all, the **recurrence relation** is for **time complexity**, then **every term** is the **time** for that specific level.

> If at all, the **recurrence relation** is for **value**, then **every term** is the **value** for that specific level.

> When solving **recurrence relation**, we are getting **some series** inside. Sometimes, we will get **GP**. Sometimes, we will get **AP**.

![image](https://user-images.githubusercontent.com/54589605/233788973-2412c316-19ee-4224-8a91-f71f74cd669b.png)

> Above **recurrence relation** is for **time complexity** or **time** purpose. Level to level, **time** is **increasing**. It is a **binary** tree.

> Level to level, function calls are **increasing**, so **time** also **increasing**.

> Whenever we are solving **recurrence relation** is for **time complexity** or **time** purpose, every time, we are getting **one** term, that **term** is **time** at that **level**.

> Whenever we are solving **recurrence relation** is for **value** purpose, every time, we are getting **one** term, that **term** is **value** at that **level**.

![image](https://user-images.githubusercontent.com/54589605/233789603-ae8bd576-5932-484c-8c0e-f1f77b99ed52.png)
![image](https://user-images.githubusercontent.com/54589605/233789658-355a089e-4ef5-4c85-b41b-97294122d29b.png)

> The actual answer is **Theta(n^3)**.

> All **three** with **green ticks or check marks** are **correct**.

> Out of the **three**, only **one** is available.

* Assume that all **three** are available and we can choose **one only**? Which one we should choose? 

> **Theta**, because **theta** means **big-O and omega** are also possible. **Theta** means we selected **all**.

> If, **MSQ**, then select **all three**.

> If, **MCQ**, then select **Theta**.

![image](https://user-images.githubusercontent.com/54589605/233789850-4a6c1cd8-d7de-4239-9dec-c0681fd011ae.png)
![image](https://user-images.githubusercontent.com/54589605/233789860-0ed01533-0865-420d-99e1-73de6eb50614.png)
![image](https://user-images.githubusercontent.com/54589605/233789908-027eb96a-2406-4204-b2d6-c5df235fb106.png)

> If, **MSQ**, then select **all** of them.

## Practice

![image](https://user-images.githubusercontent.com/54589605/233789962-c46e5afe-52f8-485a-9e40-dbf34d5c2072.png)

## Doubt_Solving_Session (16) [22nd April 2023]

> In the **first** question, first level cost is **n**. The no. of levels is **log n** because **T(n/2)**. So, the total cost is **n * log n**. **n * log n** is the **upper bound**. It will not go more/further than **n * log n**. 

> If we are **substracting by 2** from every level, then the total **no. of levels** is **n/2**.

![image](https://user-images.githubusercontent.com/54589605/233798106-642de703-7a34-4742-9632-cda154cef166.png)

> **Two** times, we have substituted and we have **two** non-recursive terms.

![image](https://user-images.githubusercontent.com/54589605/233798149-a0a3c8b6-0640-468f-9490-f4b53d69de81.png)

> In the **first level**, **n** is the  non-recursive term.

> In the **second level**, **n/2** is the  non-recursive term.

> The **non-recursive terms** are different for both the levels.

![image](https://user-images.githubusercontent.com/54589605/233798501-6cf106fe-fad7-4fb3-9051-706c7d54b96e.png)

## Notes

### GP Formula [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/233798538-4f4bb479-9704-4133-afd6-4d6b9869eed7.png)

![image](https://user-images.githubusercontent.com/54589605/233798831-e2e624da-9924-4dee-9bb3-d90e9fd50ff0.png)

> If **r** value is less than **1**, then **r^n** will still be **decreasing**. It will **decrease** more.

![image](https://user-images.githubusercontent.com/54589605/233798855-75b61a92-35f3-4e7b-bce0-d69f102f950c.png)

> If we doing **r^n** which is **function** time squaring, then it is closer to **zero(0)**.

![image](https://user-images.githubusercontent.com/54589605/233799694-b46847eb-1b8d-4a62-95c1-c92df16102ba.png)

> GP series, where **r** value is less than **1**, then the total answer is **O(1)**.

![image](https://user-images.githubusercontent.com/54589605/233798974-8e086430-8ad5-4e8a-9129-daceb9838aa8.png)
![image](https://user-images.githubusercontent.com/54589605/233798990-76ca0c09-7cc5-43ee-acd9-2d61898efb18.png)

* O(n).

> It is a **GP** series and **r** value is less than **1**. In a **GP** series if the **r** value is less than **1**, then whatever the **answer will come**, it will be a **constant**. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/233799093-bd3fa76e-76d9-4891-895b-a5c38b60b8a1.png)
![image](https://user-images.githubusercontent.com/54589605/233799105-e0964632-54ed-45fe-a9fe-8f24303b5928.png)
![image](https://user-images.githubusercontent.com/54589605/233799123-f833db4b-3b72-4f63-8616-9651ad1970e8.png)

> If the exact answer is **n**, then we can write **upper bound** as **O(n * logn)**.

![image](https://user-images.githubusercontent.com/54589605/233799184-7e669bff-16f4-42a8-8326-77af95a44435.png)

> If a series is a **decreasing GP**, then the answer is **constant or O(1)**.

> If the **k** value is **log n**, then the **tree** contains **log n**  levels. The function is a **unary** tree, because of **one** function call.

> **log n**  level tree means stack size is **log n**.

> That **k** indicates, **stack size**.

![image](https://user-images.githubusercontent.com/54589605/233799656-382d187b-c493-44a9-93ea-8852cbf4d722.png)

> First level cost itself is **n**.

> Last level cost itself is also **n**.

* **Decreasing GP series** -> Whatever is the **first** term, final term is also **same**, because the people who came afterwards, they are **very small**, that's the reason.

* **Decreasing GP series** is a **GP** series where the **r** value is less than **1**.

> First term is almost the **answer** as later terms are almost **negligiable**.

> **GP** series, where the **r** value is less than **1**, it is called as **decreasing GP series** and the **final answer** is **constant**.

![image](https://user-images.githubusercontent.com/54589605/233800015-6b4fff64-699c-41af-b6e0-9968d4d271f6.png)

> If **constant**, then how we got **O(n)**, because **n** is outside of the series and **n * 1 -> n** only.

> **Recursion** means **tree** there and the **tree level** is **log n**.

> It is a **unary tree** because of **one** function call, which is **T(n/2)** everytime.

## Summary

> From the above problem, the **total sum** of a **decreasing GP series** is **1**.

![image](https://user-images.githubusercontent.com/54589605/233814340-b92070df-b303-41a5-9555-c658abe25879.png)

* No problem. **T(1)** is **10** now.

![image](https://user-images.githubusercontent.com/54589605/233814381-db6551f9-addd-4532-a593-b40a02ce5e3f.png)
![image](https://user-images.githubusercontent.com/54589605/233814410-eda3c456-5940-4c66-b8ee-57008474e8d5.png)

* No problem. **T(10)** is **10** now. Differ by only **constant**.

> We can take anything as the **termination** condition, because it differs by only some small **constant**

> **Termination** condition cannot have a **function**, it has to be a **constant**.

![image](https://user-images.githubusercontent.com/54589605/233815059-75e73a4a-fbed-4afc-b095-a8b881312330.png)

> In the above question, we got **n** as the non-recursive term for the **first level**.

> In the above question, we got **n** also as the non-recursive term for the **second level**.

> We got **n** as the as the non-recursive term for **first and second** level. 

## Note

* **First and second** level non-recursive term are **same**, which means **same** terms are coming. It is not a **series**. Further also, **same** will come. Series will not come.

* If **First and second** level non-recursive terms **differ**, which means **series** coming.

* If **First and second** level non-recursive terms **same**, which means **same** coming.

> Recursion having clear behaviour, either **everytime changing** or **everytime same or not changing**. 

## Note

* If **base** same, then **powers** we have to **add**.  [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/233815380-802e4a6c-8cb6-410e-9b14-136b2dd8bfac.png)
![image](https://user-images.githubusercontent.com/54589605/233815461-938a05b1-4b5c-4bd2-b025-ee06a6674ec5.png)

* **Third** term also is **n**.

* **First and second** level **same**, means **third** will also be **same**. This is **recursion**, a clear behaviour is followed.

![image](https://user-images.githubusercontent.com/54589605/233815537-d8000013-4a05-4de9-b63a-16fa3a71aa3d.png)
![image](https://user-images.githubusercontent.com/54589605/233815578-669cfdcd-dfa5-420e-92d4-dbe62c3bb85d.png)

> Everything should be in-terms of **three** only.

![image](https://user-images.githubusercontent.com/54589605/233815788-7290f49b-5fe9-4aa9-b584-3d0fbd3eef58.png)
![image](https://user-images.githubusercontent.com/54589605/233815794-d7bd8606-2d0c-4455-82ea-fcd9c4fdd615.png)

> **Theta** means **big-O and omega** also there.

![image](https://user-images.githubusercontent.com/54589605/233815852-895090fe-baaa-4402-a0c6-b607ba3697c2.png)

* Practice

* Recursive program time complexity, how to calculate?

1) Write Recurrence relation for **time**. Many Recurrence relation possible.
2) Using one of the **three** methods(substitution, master's,recursive tree method) to find the time complexity of the recursive program.

> If we apply everytime **sqrt(n) or n^(1/2)** in a loop, then we will get **log(log n)** as the **time complexity**.

![image](https://user-images.githubusercontent.com/54589605/233816232-4e7aacbf-b783-4ed6-a67e-a3239d21406c.png)

* i - 2 -> **n/2**
* i / 2 **OR** i * 2 -> **log n**
* everytime **root** operator **OR** i^(1/2) -> **log(log n)**.

* First non-recursive term is **n**. Every time **root or n^(1/2)**, then the **no. of levels** is **log(log n)**.

> **One** level cost is **n** and total levels is **log(log n)**. So, the total cost is **n * log(log n)**.

![image](https://user-images.githubusercontent.com/54589605/233816294-eb887dfe-82ee-4d79-a135-0680c274ccdb.png)

> Sometimes, it will **work**. Sometimes it will not **work**. May work and may not work. 

![image](https://user-images.githubusercontent.com/54589605/233268911-be152691-b35c-4371-8de6-3339c3790e29.png)
![image](https://user-images.githubusercontent.com/54589605/233816593-4d75210b-9c54-4670-bd4e-2af16bc05d26.png)
![image](https://user-images.githubusercontent.com/54589605/233816640-dd7494f8-078a-4771-a12f-505edf2c1d75.png)
![image](https://user-images.githubusercontent.com/54589605/233816820-169579ef-4903-478d-9e68-68a1dc972d4b.png)
![image](https://user-images.githubusercontent.com/54589605/233816823-450dc81c-6ff0-44af-a7ff-fed732f73d0d.png)

* All the **four** statements are **related**.

![image](https://user-images.githubusercontent.com/54589605/233816854-df58b724-7006-4a79-adff-cbb03c3b2d75.png)
![image](https://user-images.githubusercontent.com/54589605/233816887-b7ede2fa-7d73-4d4c-9509-0d553d511054.png)
![image](https://user-images.githubusercontent.com/54589605/233816942-8122d152-b95e-4249-9cba-116d8a04bafb.png)

* We can use any **one** of the above **four** statements as they all are **related**.

![image](https://user-images.githubusercontent.com/54589605/233817709-3c6e6c72-29f9-488b-bee2-18ee6f4dbef8.png)

> In **first and second** level, non-recursive term is **different**. The non-recursive term in the **first** level is **n** and on the **second** level is **n-1**.

* **Different** means **series** coming.

![image](https://user-images.githubusercontent.com/54589605/233817855-389c5de3-4355-470d-9771-ad5eb4792784.png)
![image](https://user-images.githubusercontent.com/54589605/233818010-bc7dfbf1-80a9-42b3-aa1f-613402420b7b.png)
![image](https://user-images.githubusercontent.com/54589605/233818046-23344188-c621-4fd7-a0f3-9303a8d0acdb.png)

* The **first part(2^0,2^1,2^2......,2^(n-2),2^(n-1)** of every term is a **GP**.
* The **second part(n-0, n-1, n-2,.....,3, 2, 1** of every term is an **AP**.

> It is a combination of **AP and GP** series.

![image](https://user-images.githubusercontent.com/54589605/233818137-fa3f7412-a9ea-4b95-98d2-97bf3492fbd5.png)

## Solving **AP and GP** series combination. [**IMPORTANT**]

> In the **GP** series, **r** value is **2**.

> In the **AP** series, **r** value is **1 or -1**. **2nd term** minus(-) first term. (-1 -0) -> (-1). Common difference is **1**.

1) Whatever is the **r** value in the **GP** series, here is it **2**, multiply it with the whole/total **series**. The power increases by **1**.

![image](https://user-images.githubusercontent.com/54589605/233818524-f0e647e3-fb72-4a73-b8c0-66c125d023ab.png)

2) After **multiplication** is over, **substract**, **T(n)** with **2T(n)**, which is **T(n) - 2T(2)**.

![image](https://user-images.githubusercontent.com/54589605/233818654-6296a828-ccf9-4757-bda3-860c08ca9e84.png)

* **AP and GP** series combination became **GP** series.

![image](https://user-images.githubusercontent.com/54589605/233818718-5a2e05b1-dd95-4ea3-bea3-e0386626d262.png)

* We got **Theta(2^n)**.

![image](https://user-images.githubusercontent.com/54589605/233818994-eb3290f9-a3ca-4709-a00b-cdfff6f141e0.png)

![image](https://user-images.githubusercontent.com/54589605/233819021-3a291c55-bb4d-492b-a224-e84b00755355.png)

* It is another **AP and GP** combination series.
* **First part** of every term is **AP** series and **difference(r)** is **10**. In **AP**, **substract**, second term by first term. **20 - 10 -> 10**. **Third** term by **second**, term and so on, **30 - 20 -> 10**

* **Second part** of every term is **GP** series and **r** is **2^2**. In **GP**, **divide**, second term by first term. **2^11/2^9 -> 2^(11-9) -> 2^2 -> 4**. **Third** term by **second** term and so on.

1) Multiply with the **r** value of **GP** series, so that the **powers** are **equal** and **substraction** will be **easier**.

![image](https://user-images.githubusercontent.com/54589605/233819236-b7252aaf-7e9e-4ec8-a9e3-dbf9144c8dc6.png)
![image](https://user-images.githubusercontent.com/54589605/233819262-7c117227-b1ce-4987-887b-38e3b2ce0e49.png)
![image](https://user-images.githubusercontent.com/54589605/233819273-c4fdca7f-4d60-473a-a69e-9f455af4b43f.png)

* If we are multiplying by **r** value, then all **powers** are **shifted** one position to the right, so that **GP** term powers are **equal** and we can easily **substract** the **AP** term. So, **AP** series is **cancelled** and we are left with **GP** series only.

![image](https://user-images.githubusercontent.com/54589605/233819338-965c61b8-297c-4816-9987-6ecb87d88949.png)
![image](https://user-images.githubusercontent.com/54589605/233819347-ed6e4b1c-261b-47f9-88c3-cac84a6b9504.png)

![image](https://user-images.githubusercontent.com/54589605/234887810-428b32d7-2bb9-4c78-9da0-c2ad0f74cc94.png)
![image](https://user-images.githubusercontent.com/54589605/234887828-59710426-16ff-4db0-a4ff-8fd21d72e953.png)
![image](https://user-images.githubusercontent.com/54589605/234887858-00cbbe1d-2fad-4008-9899-5c39082065d1.png)
![image](https://user-images.githubusercontent.com/54589605/234887897-bdb8a9fc-8d8f-44a6-8bab-94ac605b03cb.png)
![image](https://user-images.githubusercontent.com/54589605/234887931-da40d86d-b3cf-4009-8521-754bf57a311e.png)
![image](https://user-images.githubusercontent.com/54589605/234887952-e20b9f3a-c772-424d-bf48-191338d648e6.png)
![image](https://user-images.githubusercontent.com/54589605/234887973-186bf37e-e62e-4a5b-993c-4049e38af6f3.png)
![image](https://user-images.githubusercontent.com/54589605/234887991-25669ed9-27cd-4e16-a422-e956b0952c1d.png)
![image](https://user-images.githubusercontent.com/54589605/234888008-371e01a7-576b-41f0-bdaa-bb712517e0fe.png)
![image](https://user-images.githubusercontent.com/54589605/234888018-0f6d3787-d94a-4d41-a105-279543a77b7b.png)
![image](https://user-images.githubusercontent.com/54589605/234888049-47baec89-cd5f-4ca8-8f44-2672fff4201a.png)
![image](https://user-images.githubusercontent.com/54589605/234888081-4c6c8233-4ed1-4f68-8035-48938fc80c19.png)
![image](https://user-images.githubusercontent.com/54589605/234888102-2c052c8e-5d7e-46c3-83ae-f16dec2affc8.png)
![image](https://user-images.githubusercontent.com/54589605/234888131-da3180de-d513-4f39-b7c9-08e1f356e4ba.png)
![image](https://user-images.githubusercontent.com/54589605/234888155-698718b0-9847-42c7-96d9-f52ec9cdb31c.png)
![image](https://user-images.githubusercontent.com/54589605/234888207-fa4eec87-27eb-4c7d-a756-701830dbd610.png)
![image](https://user-images.githubusercontent.com/54589605/234888228-ec07d27b-8dff-4822-9122-d2ab52658880.png)
![image](https://user-images.githubusercontent.com/54589605/234888257-afe5bdb6-e09f-42d8-9ab5-40305685f941.png)


## Practice

![image](https://user-images.githubusercontent.com/54589605/233819352-857d2b46-889c-4790-b8a0-35ea2dc715a5.png)

* **Solved below**.

## GT-VI (17) [27th April 2023]

![image](https://user-images.githubusercontent.com/54589605/234893008-43b883e5-88ee-46d6-8de5-2310ba05ed85.png)
![image](https://user-images.githubusercontent.com/54589605/234894122-cbfca89f-4745-4782-95ad-ed91efa1ff29.png)

## Recursive Tree Method

* More than **one** function call.

> We are **dividing** by **two**, so we will see **log n** levels. The first level cost is **n** and every level cost is **n** as well. 

> As first level cost and second level cost is the **same**, which is **n**, which means that they are **same/equal**, so no **series** will be **formed/created**.

![image](https://user-images.githubusercontent.com/54589605/234905749-57ad9573-91b6-442b-ac1b-90b81961504c.png)
![image](https://user-images.githubusercontent.com/54589605/234906326-540da068-7280-4e6f-bdf7-5e29cf0e316e.png)
![image](https://user-images.githubusercontent.com/54589605/234912648-2c440ce0-dd2a-4e37-bfa6-1a93609f6697.png)
![image](https://user-images.githubusercontent.com/54589605/234912911-db2228de-4bbc-48fc-a396-89c68f05959c.png)

> So, the **time complexity** is **n  * log n** which is **n * (log n)**.

![image](https://user-images.githubusercontent.com/54589605/234913630-675d138a-61ab-4895-9c37-24b673188511.png)
![image](https://user-images.githubusercontent.com/54589605/234914175-c29c1502-42f9-42d7-af90-2f15b7a6d7a7.png)

> Because of always **divide by 2**, we got **log n** levels.

![image](https://user-images.githubusercontent.com/54589605/234914706-789c54d8-d5e7-4b3d-848c-e41e375c5d9a.png)


![image](https://user-images.githubusercontent.com/54589605/234916641-387680af-58f7-4c2f-8a59-9d80e6418bf0.png)
![image](https://user-images.githubusercontent.com/54589605/235089348-8cc59b44-c155-485d-9c21-6b8512a8aeff.png)

* **Divide by 5** is nothing but **multiply by 1/5**.
* **Multiply by 4/5** is nothing but **divide by 5/4**.

![image](https://user-images.githubusercontent.com/54589605/235089816-5a472128-dea9-49e0-8500-debfa0a9c0c7.png)

* Second level total cost is **n** also.

> As **first and second** level total cost are **same**, which is **n** only. So in the further levels, it is also **same**, which will be **n** only.

![image](https://user-images.githubusercontent.com/54589605/235090535-90d4a5b1-032e-4875-80a6-5e9a57a32f1d.png)
![image](https://user-images.githubusercontent.com/54589605/235090909-2ddce5a6-88b5-413e-b491-6acf88cd836d.png)

> **Left and right** side values are **different** because we are **dividing** by **different** numbers.

> **Left** base is **bigger** as it is **5**, compared to **5/4**, which is **5/4 -> 1.25**. 

> Whichever **base** is **bigger** that is **smaller**.

> **Base** is **small**, **bigger** value will come.

> **Base** is **bigger**, **smaller** value will come.

> As, **left** base is **bigger** so it has **smaller** value. So **right** is **bigger** as it has **smaller** base.

> **Left** stopped somewhere in the **middle** and **right** is still going.

![image](https://user-images.githubusercontent.com/54589605/235091531-24d400e8-fcb0-4063-91d5-3dec5bbaa618.png)
![image](https://user-images.githubusercontent.com/54589605/235092157-a4da8955-2978-400e-94f9-ef06b4f2fb19.png)

> In the **below** problem, the **base** difference didn't came because in both of them they were **divided by 2** only, so they were **same/equal**.

![image](https://user-images.githubusercontent.com/54589605/235092201-3af3249a-d29a-41c5-a01c-c3db4f4b2134.png)
![image](https://user-images.githubusercontent.com/54589605/235092750-f89b1dd4-a219-4567-bef4-eabe59af6110.png)
![image](https://user-images.githubusercontent.com/54589605/235092839-194d0ad4-a197-4b1b-a5ea-0ba7e7b5c08b.png)
![image](https://user-images.githubusercontent.com/54589605/235093104-8b9f4cb9-9097-40c8-aaf1-c203e1fc4f76.png)

* Every level cost is **n**.

![image](https://user-images.githubusercontent.com/54589605/235093994-d4577086-605c-4aec-a736-381851950898.png)

> We **added** something, so we will get **upper bound**, when we **add** something.

> We are **adding** all to get **n**.

> As we go down, **left** people are **decreasing/missing** so it will be **less than n**.

![image](https://user-images.githubusercontent.com/54589605/235094675-b5d205bb-5a13-4673-b95d-4f921fe9601c.png)

> After **adding** extra with the **white color part** at the bottom of the **left side**, after adding all we got **n**. It is called as **upper bound**.

* **Upper bound** means **right height** as it is **bigger**. So, until **right height** time, we **added 'n'**. 

![image](https://user-images.githubusercontent.com/54589605/235097244-ba485295-582a-4ed6-a826-fbd411e1a8d2.png)

* Right side is **bigger**, that's why **<=**.

![image](https://user-images.githubusercontent.com/54589605/235097525-95fa7f30-1209-4a3e-8859-355877c26f84.png)

> As we have **added** something, that's why it is **upper** bound.

![image](https://user-images.githubusercontent.com/54589605/235097927-66b5faa6-71b9-477d-9ace-410e3f60a93b.png)
![image](https://user-images.githubusercontent.com/54589605/235098134-a1e58097-88fa-43fb-a8fb-d5d0c0f4812b.png)

> If we **cut/substract** it, then we will get **less**. This is called as **lower bound**.

![image](https://user-images.githubusercontent.com/54589605/235098433-f9aefd26-f868-4042-9124-895013e29a49.png)
![image](https://user-images.githubusercontent.com/54589605/235098552-7e10d8b4-f0b2-4702-9058-bf10e7ab1e24.png)

* **Omega** is **lower bound**. Comparing with **actual** answer it is **smaller**.

* If we take **maximum** levels, then we will get **upper bound(O)**.
* If we take **minimum** levels, then we will get **lower bound(Omega)**.

> **Left** height has **lower** levels. So, it has **lower bound(Omega)**. As we have left out **something**, that's why it is called as **lower bound(Omega)**.

> **Right** height has **bigger** levels. So, it has **upper bound(O)**. As we have taken **extra**, that's why it is **upper bound(O)**. 

![image](https://user-images.githubusercontent.com/54589605/235099570-c0869671-2c10-412b-bdf4-f37048b95342.png)

> In the **above** question there was no question of **upper or lower** bound, as both the **left and right** heights were **same/equal**. No, **upper or lower** bound.

![image](https://user-images.githubusercontent.com/54589605/235099950-e7c72fe9-db6c-4871-82cf-cecf80f844d6.png)

> In the **above** question, **left and right** heights are **different**. That's why we cannot find out **exact** answer.

![image](https://user-images.githubusercontent.com/54589605/235100309-5a718cea-ebbd-4b5c-8acd-53327762d4d2.png)

> In the **above** diagrams, it is not possible to give **exact** answers. **Add** something to make a **nice diagram** so that we can give **answer**. 

> If **adding** not possible, then **cut/substract** something, then make a **nice diagram** so that we can give **answer**.

> So, whenever not possible, **add** something to give the **upper bound(O)**. 

> So, whenever not possible, **cut/substract** something, to give the **lower bound(omega)**.

> Whenever not possible, to give **exact** answer, atleast give **upper or lower** bound as **answer**.

![image](https://user-images.githubusercontent.com/54589605/235103739-62795f5a-1262-418f-b1a8-0385ca57a640.png)
![image](https://user-images.githubusercontent.com/54589605/235104314-3a51bebc-2a5d-4339-8d9f-fd6052c6b53e.png)

* **T(n)** is **smaller** than **n * (log n base (5/4))** and **T(n)** is **bigger** than **n * (log n base 5)**.

> So **T(n)**, lies betweeen **upper and lower** bound, as we **add** something to get **upper** bound and we **cut/substract** something to get **lower bound(omega)**.

> **Left** side is **smaller** and **right** side is **bigger**. **In-betweeen** is **In-betweeen**.

* **Left** person is **less than**, **T(n)**.
* **Right** person is **more than**, **T(n)**.

> **Left and right** sides, **differ** by only **constants** only and bigger functions are **same**.  

> So, **theta** is also possible, as they differ by **constants only**.

![image](https://user-images.githubusercontent.com/54589605/235105074-528ddd40-bc71-431b-9902-73880464614d.png)
![image](https://user-images.githubusercontent.com/54589605/235105475-0d2fe7ff-c696-4bf1-b348-63cd90cee175.png)
![image](https://user-images.githubusercontent.com/54589605/235105941-1363277d-d867-46d3-b52c-59c1b7bac2b9.png)

* Differ by **constants** only, so **theta** possible.

![image](https://user-images.githubusercontent.com/54589605/235106078-0a448e06-9b5d-47ad-8f03-9b42a16dd8c3.png)

> **Lower and upper** bound, differ by **constants** only.

![image](https://user-images.githubusercontent.com/54589605/235106512-c0d4e1b7-3dfc-4d21-a19f-e282f2eca4ec.png)

> In the above question, **left and right** height are **same**. So difference at all. Even **constant** also, no difference.

![image](https://user-images.githubusercontent.com/54589605/235106705-d6a9ad74-ac0f-4976-a825-9a3f04944ee3.png)

> In the above question, **left and right** height are not **same** but still **theta** possible as **difference** by **constant** also.

![image](https://user-images.githubusercontent.com/54589605/235107405-39bc43cc-730b-40c9-8820-f12c7b937aaf.png)
![image](https://user-images.githubusercontent.com/54589605/235107549-2d3c92df-be1d-4fea-9240-22de5bf02711.png)

> **Constant** difference so, we can write **Big-O and omega**.

> Same thing can happen for **n * (log n base 5)** also.

> The total levels in the tree is **log n base (5/4)**.

> **Stack space** means **no. of levels** in the Tree. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/235117640-18d26ea8-40fe-4ef4-a293-30bf8976f433.png)

* **Right** is **bigger** because **5/3** base is **smaller** than **5** base.

> First level cost is **n**. Second level cost is **n/5 + (3 * n)/5 -> (4 * n)/5**. So, first and second level costs are **different**, which means **series** coming.

![image](https://user-images.githubusercontent.com/54589605/235118760-92e19530-0ea9-4084-9897-bd64e4c65a16.png)

> To know, which **series**, we have to **expand** upto **3** times, then only we will get clarity.

![image](https://user-images.githubusercontent.com/54589605/235119087-5bcb97b5-8041-433e-a2b8-715a3aa80805.png)
![image](https://user-images.githubusercontent.com/54589605/235119406-2a651988-cf9f-441b-ae12-fa173b6132b9.png)

> To make **series** ok, we have to **add** something, and **adding** something leads to **upper bound**.

> To make **series** ok, we have to **cut/substract** something, and **cut/substract** something leads to **lower bound**.

![image](https://user-images.githubusercontent.com/54589605/235119742-0c20840f-63a5-407b-a77a-127e1e045b6e.png)
![image](https://user-images.githubusercontent.com/54589605/235119887-c6e9d2f5-bda1-421e-8c25-1e20836e7c67.png)

* Upper bound. **Red area** is **extra**.

![image](https://user-images.githubusercontent.com/54589605/235120050-01b07a9b-8e98-416d-8fcc-bf1d1f557d53.png)
![image](https://user-images.githubusercontent.com/54589605/235120188-9c8a4dcb-434e-4dca-bf96-8af3a0953e55.png)

* Lower bound.

![image](https://user-images.githubusercontent.com/54589605/235120253-8b543282-ea65-4f8a-934b-b72eae8c11ae.png)

> **GP** series, and **r** value is **less than 1** as **4/5** is **0.something**. So the whole thing will become **constant or O(1)**.

![image](https://user-images.githubusercontent.com/54589605/235120564-cdd34118-96ce-482a-965d-4cce63c2772c.png)
![image](https://user-images.githubusercontent.com/54589605/235121148-7c7a8aac-ced1-43ad-9ffa-f2a9a3813db3.png)

> Here, in the **above** question, **series** is coming.

> It is a **decreasing GP**. [**IMPORTANT**]

* In a **decreasing GP**, whoever is the first person, is the **answer**, the first person was **(4/5)^0 * n -> n** and we got **n** as the answer as well.

![image](https://user-images.githubusercontent.com/54589605/235121770-07f1161f-a880-4961-bd1c-92438cb395e5.png)
![image](https://user-images.githubusercontent.com/54589605/235121965-8bba2736-ba24-403f-a249-53cc11184cd4.png)
![image](https://user-images.githubusercontent.com/54589605/235122108-2738ccb4-d721-489e-af13-b7b21f8d081f.png)

> Asymptotically, both are **constant or O(1)** but mathematically **above one** is **bigger**.

![image](https://user-images.githubusercontent.com/54589605/235122427-dcd2d76b-e9c2-4e07-82b0-aff03356edef.png)

## Practice

![image](https://user-images.githubusercontent.com/54589605/235122636-4cd711c7-0367-4058-a04d-fc11bd1da708.png)

## GT-VII (18) [28th April 2023]

![image](https://user-images.githubusercontent.com/54589605/235143478-9eeb69c6-4889-451e-baf9-8ce74eb3251d.png)

> For the first level, the cost is **c**, where **c** is a **constant**. **c** is independent of **n**.

> For the second level, the cost is **2 * c**. So, first and second level costs are **different**, which means **series** coming.

![image](https://user-images.githubusercontent.com/54589605/235144637-2d8dd4ee-c1ce-4e6a-b652-f4a488216bdc.png)
![image](https://user-images.githubusercontent.com/54589605/235144822-41a260ef-97fd-4f68-9507-12ee235a0677.png)

* **Right** side or **log n base (5/3)** is **bigger**, since base **5/3** is **smaller** compared to **5** base.

![image](https://user-images.githubusercontent.com/54589605/235145515-3d4ea2ce-b38d-4b67-8b9d-894256f29578.png)
![image](https://user-images.githubusercontent.com/54589605/235146894-bb4a8af9-30f9-445b-95ee-55f16f931c44.png)

> **Big-O and omega** differ by **constants** only, which are the **bases** and they are **5/3 and 5**, which are **constants** only.

> In **n^(log 2 base (5/3))**, we will get **bigger** value for **(log 2 base (5/3)** as **base** is **smaller**. 

> In **n^(log 2 base 5)**, we will get **smaller** value for **(log 2 base 5** as **base** is **bigger**. 

> They differ by **base** only which is **constant** but they are in the **power** of **n**.

> In **power**, **differ** by **constants matter**. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/235148704-90b14f0a-011b-4cb5-9a0b-3b647970b99b.png)

> **n^2 and n^3**, differ by **constants** but **n^3** is **bigger** than **n^2**.

![image](https://user-images.githubusercontent.com/54589605/235147498-84be757f-0a49-4fc5-9fee-dced25c6660b.png)
![image](https://user-images.githubusercontent.com/54589605/235147404-c900b25c-ab9f-42ad-97c1-81e03a7e46bc.png)

> So the **bases** are in the **power** of **n**, so they **matter** and hence we cannot write **theta** possible.

![image](https://user-images.githubusercontent.com/54589605/235149060-648c7d0f-f55e-4550-8cd9-67004db1a19b.png)
![image](https://user-images.githubusercontent.com/54589605/235149220-ee99b84a-2072-495e-81df-1b4a51c7ad80.png)

> Constant difference in power. That's why we cannot write **theta** possible.

> Constant difference is not there, functional difference is there, because in **power**, **constant difference** is **functional difference**.

![image](https://user-images.githubusercontent.com/54589605/235149594-611ec2cb-c9d2-40b5-958e-740df91a285b.png)
![image](https://user-images.githubusercontent.com/54589605/235150360-ca1b7dbf-f00d-4fc7-99ba-f4e2a07ed678.png)

* Everytime **theta** possible?

> **NO**. Above question.

![image](https://user-images.githubusercontent.com/54589605/235152500-cfc2db68-7941-4feb-b209-6e36f2b6c7d7.png)
![image](https://user-images.githubusercontent.com/54589605/235155060-86fc69ae-631f-4426-a322-fa12e18af9c5.png)
![image](https://user-images.githubusercontent.com/54589605/235156535-5026e5bf-f437-4dd0-b9b7-ee46c3e97cb0.png)
![image](https://user-images.githubusercontent.com/54589605/235156874-62f6bf2d-353a-42d7-99e0-fbd4090b4d11.png)

> **Upper and lower** bound, both differ by constants only and the **constants** are **beside** or in **multiply** i.e they are not in **power**, so we can **ignore** them and say that **theta** is possible. 

![image](https://user-images.githubusercontent.com/54589605/235157338-6e1d44b5-34d9-4417-9e04-c7b445f0cac9.png)

> **T(n) = Theta(n^2)**, it is **True**. **Big-O and omega** are possible, so **theta** also possible. **T(n)** is the **actual** person.

![image](https://user-images.githubusercontent.com/54589605/235157879-7840809e-7f5f-462b-900c-20dc65a6d2d7.png)

> Only for **n^2**, **theta** is possible. For others, **theta** is not possible.

![image](https://user-images.githubusercontent.com/54589605/235158171-5f7de8ce-fc59-4ab7-bb42-b7868fff5608.png)
![image](https://user-images.githubusercontent.com/54589605/235158248-ba0b702d-67d6-4505-a337-07875c49eaea.png)
![image](https://user-images.githubusercontent.com/54589605/235158927-45952564-cb5b-44ed-a285-f7e0a5792996.png)

> **log n base 2** will give **upper bound** because **base 2** which is the **smallest** base.

> **log n base 4** will give **lower bound** because **base 4** which is the **biggest** base.

> In the above question, we can say definitely because it is an **increasing GP** series, where **13/12 -> 1/something** which is **greater** than **1**.

![image](https://user-images.githubusercontent.com/54589605/235160851-db8bdddb-46ff-4ec4-99cd-1d35c076f593.png)

> Everyone is **less** than **leftmost** one and everyone is **more** than **rightmost** one.

![image](https://user-images.githubusercontent.com/54589605/235161184-e6bd3de1-0e76-4f2d-9c1d-91b5fdc9f288.png)
![image](https://user-images.githubusercontent.com/54589605/235162812-e3d90ef8-2436-4789-9738-4d907e24f1e1.png)

> Both the **upper and lower** bounds differ by **bases** only, which are **constant** difference but the constants are present in the **power of n**, and constants present in **power** cannot be **ignored** and they matter. So, we cannot say that **theta** is possible, as the constants are present in the power.

![image](https://user-images.githubusercontent.com/54589605/235163337-e625c801-3d71-4fed-87cb-03c3fe86c11c.png)

> So **functional difference** is there. That's why we cannot write **theta**.

![image](https://user-images.githubusercontent.com/54589605/235164125-9d8c1897-8b49-4ea2-93b7-698ba83f75dd.png)

> After **3 rounds** are over, we got to know that it is an **increasing** series.

![image](https://user-images.githubusercontent.com/54589605/235164412-2264ae8b-c642-42bb-a875-60fbcf7a7be0.png)
![image](https://user-images.githubusercontent.com/54589605/235164973-69f49dc9-0c53-4bdb-9918-fac4d110a07d.png)
![image](https://user-images.githubusercontent.com/54589605/235165088-213278ca-e8a7-48fe-abc3-39b9936c02fb.png)

> It is a **series** and it is **increasing**.

![image](https://user-images.githubusercontent.com/54589605/235165867-20a099ce-8b99-4826-a7c0-16de391ee57d.png)

> Among all of them **middle** one is the **smallest** as it has **log n base 5** levels. Which gives us the **lower bound**. 

> Among all of them **left** one is the **largest** as it has **n** levels. Which gives us the **upper bound**. 

![image](https://user-images.githubusercontent.com/54589605/235166827-ad9afd3c-b699-4282-b765-77878c4ce55e.png)
![image](https://user-images.githubusercontent.com/54589605/235168762-c1fe14a1-d47f-4dd9-859f-06721996c28d.png)
![image](https://user-images.githubusercontent.com/54589605/235168960-761566bb-31f2-441b-bb5b-f868a6f0c12e.png)
![image](https://user-images.githubusercontent.com/54589605/235169040-b311c4e1-a3e9-4bfa-8204-aa6d65906a31.png)
![image](https://user-images.githubusercontent.com/54589605/235169129-aae719b6-23e5-4ca5-879f-76d2d273f37e.png)

> We cannot write, **theta** as **upper and lower** bound, differ.

## Master's Theorem

![image](https://user-images.githubusercontent.com/54589605/235170342-2debd372-6a4f-47d8-a6df-f6c16cb8730a.png)
![image](https://user-images.githubusercontent.com/54589605/235172299-9370cd82-d882-4d39-96e5-99c3b7f85640.png)
![image](https://user-images.githubusercontent.com/54589605/235172871-974c3c9c-e3d4-4902-83cc-58756f394bab.png)

* 'a' value -> 1,2,3, ........
* 'b' value -> 2,3,4,.............., 3/2 also possible. 

> **Integer constants** is not mentioned, only **constants** are mentioned. So, **3/2** also possible.

![image](https://user-images.githubusercontent.com/54589605/235173810-b8587d3a-9a46-47fe-9775-bf11d24351f6.png)

> **n** should be **non-negative** and **integer**. **n** is the **no. of inputs**.

![image](https://user-images.githubusercontent.com/54589605/235192204-64b389b2-f3f6-41cd-99a3-9de1eb08268a.png)

> There is no **minus(-)** operator. Master's theorem is not applicable for **minus(-)** operator. Go to **substitution** method.

> For more than one function call, master's theorem is not applicable. Go to **recursive tree method**.

![image](https://user-images.githubusercontent.com/54589605/235195347-72f68711-89d7-4300-b3f4-191f696fccd4.png)

> If any **recurrence** relation in the above format, then only use master's theorem.

![image](https://user-images.githubusercontent.com/54589605/235195774-66d9bf62-c012-463f-823f-bcbba1bdea87.png)

* Red ticks are **shortcuts**.

![image](https://user-images.githubusercontent.com/54589605/235195906-5383f6fe-57a6-4019-bd5e-c54898fd2cac.png)

> The given **recurrence** relation is in the master's theorem format.

![image](https://user-images.githubusercontent.com/54589605/235196061-5d62a224-2dcf-4059-befa-307cdbcaf060.png)
![image](https://user-images.githubusercontent.com/54589605/235196310-2532b31d-82c9-43b8-aaef-79c75fbe0d9b.png)

> Always talk about **right side** only.

> Right side person is **bigger** compared to left side person.

* Compare **left and right** side, whoever is **bigger**, is the **answer**.

![image](https://user-images.githubusercontent.com/54589605/235197207-e51ffe80-ef09-4b8d-aebf-5fdc01e9ca42.png)
![image](https://user-images.githubusercontent.com/54589605/235197543-198c1c7c-a367-4b90-884c-e8d6430c4a15.png)
![image](https://user-images.githubusercontent.com/54589605/235197856-661ae2f0-b5c9-46de-a592-6315935c8fd7.png)

* Compare **left and right** side, right is **bigger** by **polynomial** time.

* Whoever is **bigger**, is the **answer**.

* If we want to solve a **recurrence** relation using master theorem.

1) First check if it is there in the given format.
2) If Yes, then write **f(n)** on the **left** side.
3) On the **right** side, write **n ^ (log a base b)**.
4) Whoever is **bigger**, is the **answer**.

![image](https://user-images.githubusercontent.com/54589605/235198846-6903bb0b-1b57-47fe-ab62-f267ae44005c.png)

> **Right** side is **smaller**.

> So, **right** side is **smaller** by **polynomial** time.

![image](https://user-images.githubusercontent.com/54589605/235199471-d5beb709-59d4-4b21-aae6-f9e0ec6fc732.png)

> **Right** side is **smaller** by **polynomial** time.

> **Right** side is **small**, to make it **equal**, we multiplied it with **n**.

![image](https://user-images.githubusercontent.com/54589605/235199932-d71f7958-fc7b-49ea-9f7e-e6668d4df456.png)
![image](https://user-images.githubusercontent.com/54589605/235202009-de97fafe-c2e9-4653-a2ba-85f9a1bfe840.png)

> Whoever **bigger** is the **answer**.

![image](https://user-images.githubusercontent.com/54589605/235202239-cffb8d30-e655-4959-8675-809f32d0b282.png)

* Right is bigger.

![image](https://user-images.githubusercontent.com/54589605/235202301-128cc1c1-8706-4a4f-af7c-93ff7b06868a.png)
![image](https://user-images.githubusercontent.com/54589605/235202396-33724b13-26ba-4b17-8632-fb55749c02c7.png)

* Left is bigger.

> In all of the above questions, either **left or right** is **bigger**. How much **bigger/smaller**?, we will get from the **right** side only.

![image](https://user-images.githubusercontent.com/54589605/235202687-eeee49e3-9a98-426b-ab46-7e0fd9173e5f.png)
![image](https://user-images.githubusercontent.com/54589605/235203007-5513b55a-11d5-44a9-b2f7-f86ae5cefc2a.png)

* Because of **big** on the right side, to make it **equal** to the **left side**, we will do **division**. **Division** is nothing but **power substraction**.

![image](https://user-images.githubusercontent.com/54589605/235203178-51081555-834b-40a3-a74c-5e05bd3eed12.png)

* Because of **smaller** on the right side, to make it **equal** to the **left side**, we will do **multiplication**. **Multiplication** is nothing but **power addition**.

* In all of the **above questions**, the **right side person** is either **bigger or smaller** than the **left side person** by **polynomial** times.

* If a **recurrence** relation is given, calculate **left and right** side. After calculation done, whoever is **bigger** is the **answer** but before writing the answer, confirm one more thing. Ask the **right** side, if it is **bigger/smaller** by **polynomial** times. If **YES** then, whoever is **bigger** is the **answer**, **confirmed**.

![image](https://user-images.githubusercontent.com/54589605/235204596-c10c6443-e94b-44c8-91f6-c320dc0a424b.png)
![image](https://user-images.githubusercontent.com/54589605/235204639-275d29f4-396a-4323-a6e0-3aa80da42cc1.png)

* If the condition, **bigger/smaller** by **polynomial** is **satisfied**, then only whoever is **bigger** is the **answer**, **confirmed**.

* If the condition, is **not satisfied**, then we cannot take whoever is **bigger** as the **answer**.

> Master theorem is saying that, comparing **left and right**, if **right** is **bigger/smaller** compared to the **left** by **polynomial** times, then only whoever is **bigger** is the **answer**, **confirmed**.

> Otherwise, we cannot take whoever is **bigger** as the **answer**.

![image](https://user-images.githubusercontent.com/54589605/235206090-220594f6-5011-4716-88a4-bda3906fc6ec.png)
![image](https://user-images.githubusercontent.com/54589605/235206247-3c04bb44-56d1-420b-9efd-4b94e0fe9ce8.png)

> In the **first** case, we are doing **division**.

> In place of **c**, the formula has **E**.

> It is **divided**, because **right** side **bigger** compared to left side.

> **Right** side is **bigger** by **polynomial**, then whoever is **bigger** is the **answer**, **confirmed**.

![image](https://user-images.githubusercontent.com/54589605/235206921-2d65fab0-2525-45a7-a020-408774c1343b.png)
![image](https://user-images.githubusercontent.com/54589605/235207413-72b820eb-1540-4cc3-9fc4-ec079acd5fda.png)

> In the **3rd case**, we are doing **multiplication**, as the **right** side is **smaller** by **polynomial** compared to the left side.

![image](https://user-images.githubusercontent.com/54589605/235207528-6b70a859-1a9f-4d10-8e6f-4abe70aeb57b.png)

> So, the **answer** is, whoever is **bigger** is the **answer**.

* In **case 1**, we are doing **division**, **minus(-)** means **divide**, because **right** side is **bigger**. So, **n^(log a base b)** is **bigger**. So, whoever is **bigger** is the **answer**.
* In **case 3**, we are doing **multiplication**, **add(+)** means **multiply**, because **right** side is **smaller**. So, **f(n)** is **bigger**. So, whoever is **bigger** is the **answer**.

![image](https://user-images.githubusercontent.com/54589605/235208237-c2666efb-a145-450b-8a8d-eb2f7ab9c6e9.png)
![image](https://user-images.githubusercontent.com/54589605/235208671-28389877-e793-4f4c-8c75-64a99669797e.png)
![image](https://user-images.githubusercontent.com/54589605/235208777-c46d4eae-c71e-467b-ae79-67ca5076316b.png)

> **Left** is **bigger**, as we have to **multiply**, **log n** on the **right** side. So, **right** side is **smaller** compared to the left side.

> Right side person is **smaller** than the left side, as right is **smaller**, we have to **multiply**. How much **smaller**? We have to **multiply**, **log n** to make both the sides as **equal**. **log n** is **not polynomial**, it is **logarithmic**.

> Because of the **above reason**, that it is **not polynomial** and it is **logarithmic**, immediately come back and **remove** the previous answer which is **Whoever is **bigger** is the **answer**.**.

> If **bigger/smaller** by **polynomial** then only **master theorem** will work out. 

> If also **bigger/smaller** by **logarithmic** times, then also **master theorem** will not work out.

![image](https://user-images.githubusercontent.com/54589605/235209984-56c8463b-3066-45eb-a92d-2e3a20f7c9f8.png)
![image](https://user-images.githubusercontent.com/54589605/235210432-79ccddc9-debb-46ee-8f6c-25eba293cf9e.png)

> The actual answer is **n * (log n)^2**.

![image](https://user-images.githubusercontent.com/54589605/235210911-9cb5ae1f-d76c-40fa-a5fa-4e3534af7494.png)
![image](https://user-images.githubusercontent.com/54589605/235210981-7b42eba4-b021-4468-bba1-e7921d396800.png)

* Must be **polynomial** times **smaller/bigger**.

> Apply **substitution method** to get **actual/correct** answer.

![image](https://user-images.githubusercontent.com/54589605/235211846-eb2480bd-39ab-4b84-9a95-94555069f2e6.png)

> They are **equal**. Whenever they are **equal**, we have to do one thing.

> Whenever both are equal, go **right** side. In the **right** side, attach some **(log n)^0**, so that both sides are still **equal**.

> Take the **same** thing which is present on the **right** side as the **answer** and add **+1** to the **power** of **log n**. So, the answer will be from **n * (log n)^0** to **n * (log n)^(0+1) -> n * (log n)^1**.

![image](https://user-images.githubusercontent.com/54589605/235213073-8eabc90f-ac28-40d7-a8d9-be03c29734cd.png)
![image](https://user-images.githubusercontent.com/54589605/235213466-890474ba-a5e4-4f8c-ab34-d55f9f6cc88b.png)

* This is the **answer**.

> Whenever **both are equal**, on the **right** side, attach some **(log n)^0**, so that both sides are still **equal**. So, the **answer** is, whatever we have written on the **right** side, take as it is and add **+1** to the **power** of **log n**.


![image](https://user-images.githubusercontent.com/54589605/235212008-f8393dc4-3ed1-46cb-a8d8-9a6f200441eb.png)

* In **first case** of master theorem, it is **big-O**, which means **right** is **bigger**.
* In **last/third case** of master theorem, it is **omega**, which means **right** is **smaller** or **left** is **bigger**.
* In **second case** of master theorem, it is **theta**.

![image](https://user-images.githubusercontent.com/54589605/235213706-44771359-b547-4cd7-bc5c-18d590b17aea.png)

* **Case 1 and case 3** fail because **right** side is not **polynomicall** bigger than the left side and it is not **polynomicall** smaller than the left side. It is **logrithmically** smaller than the left side.  

![image](https://user-images.githubusercontent.com/54589605/235214022-d4cad58c-7c4a-469f-9837-1f8b5b4c6839.png)

> We can attach some **log n** power something on the right side to make **both** the sides as **equal**. 

> We can attach **(log n)^1** on the right side to make **both** the sides as **equal**. 

> Then, the **answer** is take whatever is there on the right side and add **+1** to the power of **log n**.

![image](https://user-images.githubusercontent.com/54589605/235214516-33373ebc-bcc1-485b-839d-590dc8c2d671.png)
![image](https://user-images.githubusercontent.com/54589605/235214641-9f96ff05-4b96-4c52-851e-6cec113e007c.png)

> So the **answer** is **n * (log n)^2**.

* **Case 2** is meant for, between **f(n) and n^(log a base b)**, if **no difference** at all and **logrithmetic** difference(smaller), then go to **case 2**.

![image](https://user-images.githubusercontent.com/54589605/235215276-2b474683-6fab-45a5-affd-92a84ae58e3d.png)
![image](https://user-images.githubusercontent.com/54589605/235215450-db54c540-10cb-47c9-90fe-52dd538b782e.png)
![image](https://user-images.githubusercontent.com/54589605/235215702-48fd82cf-8925-45d1-8b4d-746362d1735c.png)

> **Left and right** side are not **equal**.

> By **multiplying** **(log n)^8** on the right side, we are getting both the sides as **equal**, which means right side is **logrithmetically* smaller than the left side. So, we will go to **case 2**.

> So the answer is take whatever on the right side and **add(+1)** to the power of **log n**. The answer is **(log n)^11**.

![image](https://user-images.githubusercontent.com/54589605/235216410-c0445b31-0fa5-495c-b422-a7128155076f.png)
![image](https://user-images.githubusercontent.com/54589605/235216770-295b3763-c067-4bdb-9221-7fe711264783.png)

* **Case 2** when they are **equal** or the right hand side person is **smaller** by **logarithemetic**.

![image](https://user-images.githubusercontent.com/54589605/235216938-d394f26c-5a85-454d-92f5-74f760ee24d2.png)

> By **multiplying** with **log**, **both** are **equal**. So, right side is **logarithemetically** **smaller** than the left side.

> Only **multiply** no division here.

![image](https://user-images.githubusercontent.com/54589605/235217305-3a492da8-276f-4f93-858d-ea52e2a8a56f.png)
![image](https://user-images.githubusercontent.com/54589605/235217353-d1518a58-c0eb-449b-961c-6efd0ca8c882.png)

> We made **left and right** equal by **multiplying** by **log n**. **Multiplying** means **right** is **smaller**.

![image](https://user-images.githubusercontent.com/54589605/235217631-db35cf18-dee0-4874-8ccc-c743d193f79d.png)

> By **multiplying** with **log n or logarithemetic**, both sides are **equal**.

![image](https://user-images.githubusercontent.com/54589605/235218020-69583458-34b4-4678-a49e-fc18df829fce.png)

> **Case 2** will work for when **both** the sides are **equal** as well, when we take **k=0** value, which is **(log n)^k -> (log n)^0**.

* **Polynomial** time, **bigger/smaller**, then whoever is **bigger** is the **answer**. **Case 1 or 3**.
* If **equal(no difference)** or **logarithemetic** time, **smaller** then **case 2**.

> **Logarithemetic** time, **smaller** because we are **multiplying**.

![image](https://user-images.githubusercontent.com/54589605/235218888-1b2688f8-48ea-4d80-ab4f-4ca0ce328193.png)
![image](https://user-images.githubusercontent.com/54589605/235219624-082aaa2a-0a9e-4df9-89c8-c326aba07159.png)

> Not possible as **a and b** are **constants**.

![image](https://user-images.githubusercontent.com/54589605/235219989-ca9def86-93e3-4d6d-bb65-52a4c6d9a3e3.png)

> **k > 0**, **k** cannot be **negative**.

![image](https://user-images.githubusercontent.com/54589605/235220066-41acbe21-50c1-46c0-8454-7b09bcfc042d.png)

> We cannot take **negatives** as powers.

![image](https://user-images.githubusercontent.com/54589605/235220176-96fdda44-5646-4b0b-b5d1-d77a138e6b41.png)
![image](https://user-images.githubusercontent.com/54589605/235220353-10687e4c-57e1-4ee2-b6ca-46fd58e56626.png)

> **k=-3** then only both sides are **equal**.

> Right side person **bigger** by **logarethmetic** will not work out.

> Right side person **smaller** by **logarethmetic** then only it will work out.

![image](https://user-images.githubusercontent.com/54589605/235220683-50dd5add-fe1b-4f01-bd97-6fd911052b58.png)
![image](https://user-images.githubusercontent.com/54589605/235220716-e853e2f9-023a-4bf4-8c1a-b53ec7cc5734.png)
![image](https://user-images.githubusercontent.com/54589605/235220730-03008096-e002-43d9-b7e5-54bfe3d4cd01.png)
![image](https://user-images.githubusercontent.com/54589605/235220767-c71005eb-05b5-46b8-9a23-113414a98903.png)

* For **Case 2** of master's theorem, it should be **equal** or **right small** by **logarethmetic**.

![image](https://user-images.githubusercontent.com/54589605/235220875-c2c0f3f1-42c4-4de9-ab8b-482f6a82b392.png)

* If **exponential** difference then only **case 1 or case 3**.

![image](https://user-images.githubusercontent.com/54589605/235221310-63e95da7-bd3f-4a99-b34d-2d80a34193a1.png)

> **Right** is **bigger** by **exponential** times. **2^n** is more than **polynomial**.

> **Polynomial** is **ok** and more than **polynomial** is also **ok**. So, **master theorem** will work.

![image](https://user-images.githubusercontent.com/54589605/235221378-572256dd-a505-4adc-bf13-61d8127d04fb.png)
![image](https://user-images.githubusercontent.com/54589605/235221636-a0fec0e0-31ad-4a0d-aad4-94ecaeffc39b.png)

* Whoever is **bigger** is the **answer**.
* n, n^2, n^3 all are **polynomial**.

![image](https://user-images.githubusercontent.com/54589605/235221956-0d03ab12-26b3-4aa1-aa58-4e9c764b0132.png)

> **Right** side is **bigger**, and it is **bigger** by **n * log n**. So, **n * log n** is **polynomial** as **n, n^2, n^3** all are **polynomial**, so **in-between** also, **n and n^2** where **n * log n** stays is also **polynomial**.

![image](https://user-images.githubusercontent.com/54589605/235222258-6dd173c0-fed9-4c84-9483-b5c553fc1bb3.png)
![image](https://user-images.githubusercontent.com/54589605/235222320-cfe44b71-9c32-434f-a936-834acad286f3.png)

> Master's theorem possible. **n and n^2** are **polynomial**, so **in-between** also **polynomial**.

![image](https://user-images.githubusercontent.com/54589605/235222466-5c3d7698-32a0-4b0d-b2e2-d7681aa0daa8.png)
![image](https://user-images.githubusercontent.com/54589605/235222750-bcc99c56-3717-440a-9423-734a5c30dbed.png)
![image](https://user-images.githubusercontent.com/54589605/235222834-b4b1de2f-9d0b-4467-a15f-1859e812e3fd.png)

> **Right** side is **bigger** by **exponential** of **n^(n-1)**.

![image](https://user-images.githubusercontent.com/54589605/235222902-ef02043c-d57f-4c88-9547-42aff0a444c5.png)

* **2^n** is not **constant** and **a** should be a **constant**. 

> Because of this reason **Theta(n^n)** is **wrong**.

![image](https://user-images.githubusercontent.com/54589605/235223151-b536155f-d06b-4dda-8601-c53a36725df8.png)
![image](https://user-images.githubusercontent.com/54589605/235223112-5405ddfd-0e9a-4554-b273-2b6485652b3d.png)

## Questions

![image](https://user-images.githubusercontent.com/54589605/235282049-f260093e-de7b-488c-9055-46256583bb90.png)
![image](https://user-images.githubusercontent.com/54589605/235282053-3e548185-d430-4661-ba11-962713a595ae.png)
![image](https://user-images.githubusercontent.com/54589605/235282055-596cffec-4a8b-409a-a2f3-25caa9f4ceaf.png)
![image](https://user-images.githubusercontent.com/54589605/235282079-4d558c8b-ae00-4709-9c54-41023ce3c2dc.png)
![image](https://user-images.githubusercontent.com/54589605/235282085-d6b26aaf-a3bb-4acc-a59c-6d67f5cb9dc9.png)
![image](https://user-images.githubusercontent.com/54589605/235282088-6347778f-8b59-4283-b289-97fcb0c3e279.png)
![image](https://user-images.githubusercontent.com/54589605/235282090-054c9160-56dd-45af-9d6c-d547faff8dc1.png)
![image](https://user-images.githubusercontent.com/54589605/235282095-b638fd66-43f5-4be8-a1d8-a209575c5739.png)
![image](https://user-images.githubusercontent.com/54589605/235282098-9a3d22be-4ef1-472f-a079-21b3a1ffb8b4.png)
![image](https://user-images.githubusercontent.com/54589605/235282102-178dd3d7-919c-4f30-a8db-bdf80f69c684.png)
![image](https://user-images.githubusercontent.com/54589605/235282105-07628c8b-7338-4f53-8724-f894c4673098.png)
![image](https://user-images.githubusercontent.com/54589605/235282110-343a2dff-a215-456f-a4d9-87a161a3e47f.png)
![image](https://user-images.githubusercontent.com/54589605/235282113-08fcb891-2871-4ee7-a7a8-6d6b3324e232.png)
![image](https://user-images.githubusercontent.com/54589605/235282116-9816f085-bca9-4eda-9798-f92fabd35a69.png)
![image](https://user-images.githubusercontent.com/54589605/235282120-a427f7f4-a897-4690-be2c-aadb0ada4f9c.png)
![image](https://user-images.githubusercontent.com/54589605/235282126-fc30d8f0-5e94-4d9a-944f-8e05a08cb1d4.png)
![image](https://user-images.githubusercontent.com/54589605/235282129-04653e88-f7fb-4f82-97a9-47733ea43976.png)
![image](https://user-images.githubusercontent.com/54589605/235282134-c70c0fd1-6282-4025-8696-05b5df843ac7.png)


## DAC-IV (19) [29th April 2023]

![image](https://user-images.githubusercontent.com/54589605/235282322-61c39e5d-b08b-4230-abcf-591405b429f4.png)
![image](https://user-images.githubusercontent.com/54589605/235282364-0ceac59a-e9cc-4db4-97e2-0cb666fd4d0d.png)

* **No difference** also **case 2** and **log or logrametric difference** also **case 2**.

![image](https://user-images.githubusercontent.com/54589605/235282500-3134efe0-4a81-481d-99c8-221c0c82edca.png)
![image](https://user-images.githubusercontent.com/54589605/235282502-71ca36c1-5f22-40cc-8feb-87cb4cc094b0.png)

> When we say, master's theorem, **divide** should be there, but there is **no divide**.

> **We cannot apply master's theorem**, because **divide** is not there. 

* **Divide** should be there when solving with master's theorem.

> If we convert it into the **required** form then we can apply **master's theorem**.

* The **required format** is **a * T(n/b) + f(n)**.

> Convert into the above required format.

> The purpose of the above question is to help solve questions when **recurrence relation** contain **root operator**, then using **master's theorem**, how we will **solve** it. 

> **Worst case** is we can go for **substitution** method.

> As it is not there in the **master's theorem** form, convert it into the **master's theorem* form, which is **a * T(n/b) + f(n)**.

* Steps to **convert it**.

1) Assume, **n= 2^k**.

![image](https://user-images.githubusercontent.com/54589605/235282824-636ab9d5-53d6-4dda-a9eb-5f79df19df3f.png)

2) Assume, **T(2^k) = s(k)**. We are mapping **T function** to **s function**. In the **power** whatever there in the **T function**, comes to the **s function**. Whatever leftout will go to **s**.

![image](https://user-images.githubusercontent.com/54589605/235282877-cf64f32e-18df-4fe4-9d02-14d4dc10011a.png)
![image](https://user-images.githubusercontent.com/54589605/235282889-8491422e-f2cc-464a-a116-4918e520f907.png)

> If **T** comes, then only **s** comes.

![image](https://user-images.githubusercontent.com/54589605/235283278-c17cc93a-ac98-4fed-bb0c-879129e82b10.png)
![image](https://user-images.githubusercontent.com/54589605/235283321-b42a4729-fabf-4a39-b71b-7a389d429f5c.png)

> Directly we cannot solve the recurrence relation, **convert first**.

> Now apply **master's theorem**.

> **k** is a **function**.

![image](https://user-images.githubusercontent.com/54589605/235283482-5500e443-54ca-49df-8752-19a6b36d4299.png)

> Left is **bigger** because on the left **k** is a function and on the write **c** is a **constant**.

> Right side **c** is **smaller**, it is **smaller** by some **k**. Then only **both** sides are **equal**.

> Comparing left and right side, right side is smaller by **k** times, where **k** is a function. **K** is a **polynomial** because, **k** is there in terms of **function**.

![image](https://user-images.githubusercontent.com/54589605/235283584-48e66d8a-a8be-4a38-99b5-9bd25f04d064.png)
![image](https://user-images.githubusercontent.com/54589605/235283669-f2cd4eab-4a78-4a3d-b47e-899b3dcfc21d.png)

> Given problem is there in the form of **n**.

> We have to **convert** whatever answer we got in the form of **n**.

3) Now do, **step 2** in **reverse** order. **No s** there, then **no T** will come. Where ever **s** there, keep **T**.

![image](https://user-images.githubusercontent.com/54589605/235283790-a2799a29-628e-41c8-b2f2-dde1ddae4eaf.png)

4) Now do **step 1** in **reverse** order. We know **n = 2^k**, so we will find the value of **k**, which is **k = log n base 2**. Where ever, **k** there, replace it by **n**.

![image](https://user-images.githubusercontent.com/54589605/235283951-6dff96f4-d454-4e06-a854-794241e855fd.png)

> After **converting** into **master's theorem**, please **solve** master theorem **format**. Why solving **master's theorem**, don't worry about **k** value, some **function** is there in the form of **k**, solve it.

![image](https://user-images.githubusercontent.com/54589605/235285337-30233c0d-cde0-46f0-88cf-4c04000b4c47.png)
![image](https://user-images.githubusercontent.com/54589605/235285469-2288803f-9d71-43ac-a890-fa80e277ae7b.png)

> We got the **master's theorem** format now.

> While applying **master's theorem**, don't bring **before and after**.

> The function is in the form of **K**, **YES**.

![image](https://user-images.githubusercontent.com/54589605/235285815-831334d9-b4bf-412b-9b8b-fbb9c39b82c7.png)
![image](https://user-images.githubusercontent.com/54589605/235285838-1f4f2f92-c09c-4fd5-ab66-51e581aa00d2.png)

> We want **answer** in the form of **n** as it was given in the question in the form of **n**.

* 3rd step **reverse** is **2nd** step.
* 4th step **reverse** is **1st** step.

![image](https://user-images.githubusercontent.com/54589605/235285938-39629b47-9194-4b91-897e-98efc92e0d43.png)
![image](https://user-images.githubusercontent.com/54589605/235286353-d980e350-84f2-4aee-ac2e-7bf425ecbb93.png)

> Both the sides are **equal**, so **case 2** and we can multiply with **(log k)^0**, to keep both the sides as **equal** only still. We are multipling with **(log k)^0** and not **(log n)^0** because **function** is there in the form of **k**.

> If we are multipy with **(log n)^0*, then it is **wrong**. Here, we only know about **k** as **function** is there in the form of **k**.

![image](https://user-images.githubusercontent.com/54589605/235286531-70b0e5f5-16ac-4616-9245-0b8f1583bd71.png)
![image](https://user-images.githubusercontent.com/54589605/235286572-0b4cde3f-db3e-467e-bea0-1b71b046047f.png)
![image](https://user-images.githubusercontent.com/54589605/235286626-dd4c5fd0-5610-4795-b6b4-17d905090eee.png)

* Recurrence relation for **time**.

![image](https://user-images.githubusercontent.com/54589605/235286676-95bba476-03a7-4b38-a428-08e3c2a7a0d3.png)

> First and second level costs are **different**, so **series** coming.

![image](https://user-images.githubusercontent.com/54589605/235286869-d6b3cc19-bb58-4b82-9b16-2a1003c9383a.png)

> Upper and lower bound differ by **constants** but that **constant** is in the **power of 2**, so it becomes a **functional** difference and we cannot **ignore**. So, we cannot say that **theta** is possible.

![image](https://user-images.githubusercontent.com/54589605/235286985-b06a6cb6-5c90-446a-9aa2-be6bac558295.png)
![image](https://user-images.githubusercontent.com/54589605/235286974-f51a8554-f589-47b4-979e-99cdc5f8151f.png)

> If **both** upper and lower bound are there in the **answer**, then the **answer** is **both**.

![image](https://user-images.githubusercontent.com/54589605/235287065-6eaa6b84-99ff-4a3c-8d33-559eb29bc006.png)
![image](https://user-images.githubusercontent.com/54589605/235287078-c5910ddb-4a18-4f6b-bcc7-5787bf338697.png)
![image](https://user-images.githubusercontent.com/54589605/235287082-8f433984-436a-4874-8edb-ec56b6bcbe86.png)
![image](https://user-images.githubusercontent.com/54589605/235287092-4eebd423-eedb-4a5e-bdc7-01893584c35c.png)
![image](https://user-images.githubusercontent.com/54589605/235287100-128910c8-57dd-4ec8-b66e-4a590548a882.png)

![image](https://user-images.githubusercontent.com/54589605/235287165-771cc606-8117-40be-a3ff-05cbf86e1601.png)

> **T(n)** is **in-between**.

> Comparing **T(n)**, **2^n** is **bigger**, so **big-O**.

> Comparing **T(n)**, **2^(n/2)** is **smaller**, so **omega**.

> We are not sure if  **T(n)** is **Big-O or omega**, that why we have not written **theta**.

![image](https://user-images.githubusercontent.com/54589605/235287237-8d8ae822-f080-4469-b11a-86b2b14871ae.png)
![image](https://user-images.githubusercontent.com/54589605/235287291-c039cd53-74ed-4e44-b483-92a45f84c3d8.png)

## DP-I (20) [29th April 2023]

## Divide and Conquor

![image](https://user-images.githubusercontent.com/54589605/235288298-b2f59af5-da49-4a50-8b2f-5a878921c802.png)
![image](https://user-images.githubusercontent.com/54589605/235288295-38aa7c43-25da-4ad1-b143-c2f64b701e86.png)

> We are calling **two** times. So it may give **binary tree**.

![image](https://user-images.githubusercontent.com/54589605/235288347-3819cc30-851d-4d9e-b458-33e809a90517.png)

> There are **4** function(small, solution, divide, combine) calls which are not **recursive**. 

> The above **4** function codes are **outside**.

![image](https://user-images.githubusercontent.com/54589605/235288437-0419e435-affc-4f8e-b652-b6ca240bcbb0.png)

* i -> First element index
* j -> Last element index
* a -> Array, which contains elements from i to j.

> We want to **sort** the array, using **divide and conquor**.

* small function -> Will check if the problem is small or not. Return **1** means problem is **small**. Return **0** means problem is not **small**. 

![image](https://user-images.githubusercontent.com/54589605/235289395-e5c2155c-501f-4f61-a2df-870140f65c3e.png)
![image](https://user-images.githubusercontent.com/54589605/235289493-f00f4f43-ff3b-4314-b909-dee63705bdfc.png)
![image](https://user-images.githubusercontent.com/54589605/235289683-9c5cc719-2542-4a60-847a-03613038627b.png)

> A Recursive function without **if(termination condition)** part will give **stack overflow** error message.

![image](https://user-images.githubusercontent.com/54589605/235289829-1fa10bea-b177-4aeb-a5c8-762752f01fa6.png)

> Divide and conquor doesn't mean, we will divide bliendly or divide everytime. First verify **small** or not. If not small, then divide. Don't divide everytime.

> There are **4** non-recursive function calls and out them, **2** are in the **if** part and **2** are there in the **else** part.

> As **2** functions belong to the **else** part, there is chance of **for** loop. Inside **divide**, **for** loop maybe there.

> Inside, **Divide()** there is **one** for loop running till **n** times. Then the time complexity is **n**.

> Inside, **Combine()** there is **two** for loop running till **n** times each. They are **inner** loops. Then the time complexity is **n ^ 2**.

> If no loop is there, then the **time complexity** is **constant**.

> Inside **Small() and solution()**, there are **no loops**. But inside **Divide() and Combine()**, loop maybe there.

![image](https://user-images.githubusercontent.com/54589605/235290221-ee6784b3-7bcd-4da1-befc-9e9b31e33f7e.png)

> **Combine()** code executed means **Combine()** code is **over**.

* Small() -> **True** -> Solution() 
* Small() -> **False** -> Divide() -> Combine()

> This is **Divide and Conquor** abstract algorithm.

![image](https://user-images.githubusercontent.com/54589605/235291467-cc1776f1-3596-48b2-ac1a-98690be618eb.png)

* Code is **hidden**.

* **Divide and conquor** doesn't mean we will **divide** directly, first verify it is **small** or not. Don't divide directly.

![image](https://user-images.githubusercontent.com/54589605/235291592-81d6da76-6d33-43c9-aa64-7f8abcdf3459.png)

* Getting **sub-problem** solutions using **recursion** is called as **conquor**.

![image](https://user-images.githubusercontent.com/54589605/235291638-b7110de4-2026-4013-9de8-ccba94750593.png)

* First **divide**, now we got **sub-problems**, **conquor** will solve the **sub-problems**. **Conquor** goal is to get **sub-problem** solutions using **recursion**. **Combine** is **multiplication**. After getting the **sub-problem** solutions, **multiply**, that is called as **combine**.

![image](https://user-images.githubusercontent.com/54589605/235291769-cfd2a990-2fd7-4ebd-80be-080d3e811f8d.png)

* F(5) = F(4) + F(3)

> F(5) is divided into two parts, F(4) and F(3), it is **divide**.

> Solve F(4) and F(3), individually. It is **conquor**.

> Now, **combine**, here for F(5), **combine** is **addition**. 

![image](https://user-images.githubusercontent.com/54589605/235291912-aa805729-4cf4-4460-bdae-d3096495b437.png)

* From problem to problem, **combine** will change.

> **Combine()** code **inputs** are **sub-problem** solutions, which are **b and c** here.

> **Combine()** code **output** is **total problem** solution which is **d** here.

![image](https://user-images.githubusercontent.com/54589605/235292023-6ca81e41-9895-498b-9e17-5f65bdb37d30.png)

> **Divide and conquor** major part is **else** part. In the **else** part only, **Divide(), Conquor() and Combine()** there.

> **If** is required for **termination** condition.

> In the **else** part, **Divide()** will be executed **first**.

> **Divide()** will divide into **how many parts**, will depend on **divide code**.

![image](https://user-images.githubusercontent.com/54589605/235292140-72def053-5c41-4746-a49c-00a4bd992761.png)

> **How to do combine**? will depend on **combine code**.

> **How to do divide**? will depend on **divide code**.

> In the **else** part, **Divide()** is the **first** part. After divide, **conquor** will come and solve every single problem using recursion. Now, we have solutions to all of the sub-problems. These parts of the solutions are **inputs** to the **combine()**.

![image](https://user-images.githubusercontent.com/54589605/235297957-e2f60f96-e63c-4b72-97c8-52bdc702901e.png)

> Lastly we got **f** as the final solution and we return **f**.

> **Combine()** inputs are going to be **solutions** for the **sub-problems**.

## Summary

* Divide and conquor major part -> **else** part
* **else** part -> Divide() -> Conquor() -> Combine()

![image](https://user-images.githubusercontent.com/54589605/235298376-323fab08-a174-4041-b067-c0e50914b9e8.png)

> The above algorithm is solving **many problems**.

> **Divide and conquor** is a **designing technique**. It is a **template**. That's why somethings are **hidden**.

> It will solve **as many** problems as possible.

![image](https://user-images.githubusercontent.com/54589605/235298679-a74c4488-869c-41cb-83b0-d6b4a085bf26.png)

> **Merge and Quick** sort are implemented using **divide and conquor** designing technique.

> **As many** problems are solved using the **same** algorithm, but the **code** is different in **different functions**.

## Applications of Divide and Conquor (FOR GATE)

1) Finding max and min
2) Power of an element
3) Binary Search
4) Merge sort
5) Quick sort
6) Selection procedure(Not selection sort)
7) Maximum contigious sub-array sum
8) Finding no. of inversions
9) Strassen's matrix multiplication

> All of them use, **same** algorithm. The **4** function's code will **differ**.

![image](https://user-images.githubusercontent.com/54589605/235299034-9beb8c48-f4ff-42de-b0bc-0de205ca89d3.png)
![image](https://user-images.githubusercontent.com/54589605/235299189-d20e2a66-3040-4d43-87d3-07d8ce6b72b6.png)

> All of the applications are having the **same** format but the **4** function's code will **differ**.

> **Small()** function code will take **O(1) or constant** time, as there is **no loop**. Code may change but **no loop**.

> **Solution()** function code will take **O(1) or constant** time, as there is **no loop**. Code may change but **no loop**.

* So, total **if** part is **O(1) or constant** time.

![image](https://user-images.githubusercontent.com/54589605/235299290-638114ac-a162-48ae-9da0-ae3fbe21c3d4.png)

> **Divide()** function time is **dependent** on how the problem is being **divided**, it can be in **constant** or in **some loop**. Some divisions are **easy** and some are **difficult**. Some divisions will take **exponential**.

> Until and unless we see the **code**, we cannot say **anything**. So, we can say **some function**, which is **f1(n)**.

> **Divide()** function time is **dependent** on how the problem is being **combined**, it can be in **constant** or in **some loop**. Some combinations are **easy** and some are **difficult**. Some combinations will take **exponential**.

> Until and unless we see the **code**, we cannot say **anything**. So, we can say **some function**, which is **f2(n)**.

![image](https://user-images.githubusercontent.com/54589605/235299559-e55ae7ef-6212-4337-857d-3130b64961ea.png)

> **Divide and conquor** algorithm for **n** elements, will take time complexity of **T(n)** time.

> **Divide and conquor** algorithm for **n/2** elements, will take time complexity of **T(n/2)** time.

![image](https://user-images.githubusercontent.com/54589605/235299615-ae97f2ba-3347-453b-a49b-f2982bd073c7.png)
![image](https://user-images.githubusercontent.com/54589605/235299643-db0fed28-e3a6-4191-a363-1582f42f4bc4.png)


> If we **add**, divide(f1(n)) and combine time(f2(n)), then we will get **f(n)**.

![image](https://user-images.githubusercontent.com/54589605/235301419-fadb05a1-3c35-4bf3-af80-b01f5aefb811.png)

> First **two** indicate **how many sub-problems** we have, which is **two**. One **sub-problem** size is **n/2**. **T(n/2)** is one **sub-problem** cost. To solve one **sub-problem**, cost is **T(n/2)**.

> **2T(n/2)** represent **cost of all sub-problems**, which means **conquor** time.

> So the **conquor** time is **T(n/2) + T(n/2) -> 2 * T(n/2)**.

![image](https://user-images.githubusercontent.com/54589605/235299747-1b99b465-8250-47ce-bc97-3534da3c5d72.png)
![image](https://user-images.githubusercontent.com/54589605/235299892-9218d271-bafb-436a-9a4a-cc1410ba0f2a.png)

> So, **f(n)** is the time required for both **divide and combine**.

> In general someone can make **a** sub-problems, each of size, **n/b**.**F(n)** is the time required for both **divide and combine**.
 
> It is the **recurrence relation** of **master's theorem**.

![image](https://user-images.githubusercontent.com/54589605/235302085-f152f4f5-3df8-420b-8d51-567198ac5069.png)

> **Master theorem** was invented to solve **divide and conquor** recurrence relations.

> All **divide and conquor** recurrence relation problem will look like the **above** format.

* a -> No. of sub-problems. a >= 1
* n/b -> Size of sub-problems
* f(n) -> Time required for both divide and conquor.
* T(n/b) -> Time/cost of one sub-problem
* b -> b > 1. Otherwise no divide.

![image](https://user-images.githubusercontent.com/54589605/235302268-10f7e1b9-9ffd-4cb5-a45f-279e802f717a.png)
![image](https://user-images.githubusercontent.com/54589605/235302476-d7763c45-8ee3-44e5-955b-db09222ace0c.png)
![image](https://user-images.githubusercontent.com/54589605/235302482-da41f881-ee70-4d3c-8a77-59921acae81a.png)

* **a >= 1**, which means that **a=1** also possible. If we keep **a > 1**, then **binary search** is gone. In **binary search**, **a=1**. If **a > 1**, then we have to remove **binary search**.

## Finding Max and min

* Input -> An array of **n** distinct elements
* Output -> Returns max and min elements.

![image](https://user-images.githubusercontent.com/54589605/235302838-8b05b2bb-e0c5-4206-993d-bcaa61ee6604.png)
![image](https://user-images.githubusercontent.com/54589605/235302889-26c0e21a-cc94-4885-a6cd-2a63aa53532a.png)

> **One scan** is required, which means **O(n)** times.

![image](https://user-images.githubusercontent.com/54589605/235303058-8e167b98-d455-4044-9934-d68c3d6b2ecd.png)

> Finding max, **one scan** is required.

> Finding min, **one scan** is required.

![image](https://user-images.githubusercontent.com/54589605/235303087-8261ec28-9f8c-4120-b018-ca1053a23a9a.png)

> **Loop** will repeat, approximately **n** times.

![image](https://user-images.githubusercontent.com/54589605/235303141-d4d21ab5-9ef0-498d-9ee0-c921151f51e1.png)
![image](https://user-images.githubusercontent.com/54589605/235303170-a0df633d-bca8-405b-a646-45226ad38d65.png)

> Left to right, we went **one** time only, which is **one** scan.

> Within **one** scan, we managed **two** people.

> Within **one** scan, we can manage **two** max people.

![image](https://user-images.githubusercontent.com/54589605/235303274-2076cadf-7700-48e2-a8b5-254b2b41118c.png)
![image](https://user-images.githubusercontent.com/54589605/235303395-a617251e-524f-495a-92ac-0bd8f0145d18.png)

> The above code is **without** **divide and conquor** strategies.

> This is called as **straight max, min** algorithm. The time complexity is **O(n) or theta(n)**, **one scan** is mandatory.

![image](https://user-images.githubusercontent.com/54589605/235303491-c483af10-6e42-4275-96b0-0941a9b25c2c.png)
![image](https://user-images.githubusercontent.com/54589605/235303514-8702190c-9346-4ac2-9e92-6bef1ecc2226.png)
![image](https://user-images.githubusercontent.com/54589605/235303538-ea7a43ef-75df-4460-ba7f-203060dd91b6.png)

> More coming, **change**, less coming, **no change**.

![image](https://user-images.githubusercontent.com/54589605/235303745-96c58d18-3b3d-48cb-a3a6-1ed21bf0a201.png)
![image](https://user-images.githubusercontent.com/54589605/235303758-f359ecb7-42d5-40cc-b14e-2419dd78ec4d.png)

> **Topper** can be at **any place**. If we like it or not, we have to **compare** all of them.

* ECE -> Every Case

![image](https://user-images.githubusercontent.com/54589605/235304033-73116b6a-1a6f-4355-9357-f9caa6ef04b2.png)

> In a given array, finding **max**, **best case** time is, **O(n)** which is **one scan** and it is mandatory.

* Best, Worst, Average -> **O(n)**

> All of them are **O(n)**. **O(n)** is for **every case**.

> The above program is **without** divide and conquor strategies.

![image](https://user-images.githubusercontent.com/54589605/235329777-a8239654-36b2-4e23-822b-049fabd3796c.png)
![image](https://user-images.githubusercontent.com/54589605/235329781-146dd7f8-88b6-4758-8eca-0b48d459395c.png)
![image](https://user-images.githubusercontent.com/54589605/235329784-41056e0f-0741-4cfa-997f-1a1514b97278.png)
![image](https://user-images.githubusercontent.com/54589605/235329786-bbe1c33e-9a44-44e2-9926-0dceb46a7979.png)
![image](https://user-images.githubusercontent.com/54589605/235329789-5430133a-ba53-44ed-a00a-f947dd0ce412.png)
![image](https://user-images.githubusercontent.com/54589605/235329791-6b0d7d32-fc84-412a-827c-6b194c7a0032.png)
![image](https://user-images.githubusercontent.com/54589605/235329794-88d03559-c2c7-4c3c-ae81-d0ee18c9b6bf.png)
![image](https://user-images.githubusercontent.com/54589605/235329795-4bd32e56-7bf4-4529-bcb0-275f4d8376d1.png)


## DP-II (21) [29th April 2023]

## Finding Max and min using divide and conquor strategies

![image](https://user-images.githubusercontent.com/54589605/235304200-710be72b-6ea4-437d-9626-7e8c0a073106.png)

> Compulsory **one scan** needed. This will also give, **O(n)**.

> Yesterday's algorithm of **Finding Max and min** is without using **divide and conquor strategies**.

* **divide and conquor** abstract algorithm steps:

1) Check for the problem is small or not in the if condition.
2) 

> Time complexity is decided by **else** part. **If** is for **stopping/termination** purpose.

![image](https://user-images.githubusercontent.com/54589605/235329958-30b33d1d-c975-40e6-b448-4c3fa142112b.png)

> **1-element** is small, **2-element** is also **small**.

> If **1-element** is there in the array, then that element is **max** as well as **min** element of the array. **No comparions** needed.

> If **1-element** is there in the array, then compare once, one element is **max** and one element is **min**. **Only one** comparison needed.

![image](https://user-images.githubusercontent.com/54589605/235330086-1af48ca8-d8a9-49c4-86c4-1e0d0015d29b.png)

> Array containing **7** elements, it is **big**.

> Bigger one is solved in terms of smaller one, it is **recursion**.

> When calculating **mid** value, we need to take **floor** value.

> **1 and 2-elements** mean **small**, stop it.

![image](https://user-images.githubusercontent.com/54589605/235330189-3169745a-99c1-4e1f-8435-523957fc9025.png)
![image](https://user-images.githubusercontent.com/54589605/235330196-f87a4616-4a3a-4e79-8257-e787757980f9.png)

> **Divides** happened, **combines** will start.

> **3** divides have happened, one that (1,7), another at (1,4) and last at (5,7).

> **3** divides mean compulsory **3** combines will happen or required, otherwise system will not be stabilized.

> Leaf nodes or last level nodes are all **small** problems.

> A node with **zero** children is **leaf** node.

![image](https://user-images.githubusercontent.com/54589605/235330460-a410c9eb-a6a1-4f03-bc17-6225ade77839.png)

> A node with **atleast one** child is **internal** node.

![image](https://user-images.githubusercontent.com/54589605/235330473-62eb73b4-5a8b-4816-a9bc-ddedd67bbaa9.png)
![image](https://user-images.githubusercontent.com/54589605/235330375-64a67ce4-efd9-465e-848f-b755e9202a46.png)

* YES

![image](https://user-images.githubusercontent.com/54589605/235330521-993d717a-c25e-4613-9ac8-6f9e55c1a203.png)

> Every node is a function call.

> Left child(**c1**) is called **first**. Left is over, then only right child is called.

> To completed **c1**, we need **c2 and c5**.

> To complete **c2**, **c3 and c4** are required. 

> To complete **c3 and c4**, **none or no one** is required.

> To complete **c2**, **c3 and c4** are required and they are available. So, **c2** is completed.

> Then it goes to **c5**. To completed **c5**, **c6 and c7** are needed.

> When **c6 and c7** are over, then **c5** is also over.

> Childern over, then **parents** also over.

![image](https://user-images.githubusercontent.com/54589605/235330811-4ada59a7-543d-4e4e-bdf2-e0a72cce6c50.png)

* First and last line in code. There is no left and right in code.

![image](https://user-images.githubusercontent.com/54589605/235330876-47bdf68b-854b-465b-9801-c8cf2db03988.png)
![image](https://user-images.githubusercontent.com/54589605/235330914-73c3d458-9da4-4a41-8e8a-583a4fef6003.png)

* c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7.

> This ordering is function **calling**.

![image](https://user-images.githubusercontent.com/54589605/235331041-4e8060ad-7283-4b2e-a210-9bc0861eae6a.png)

> **c1** will finish **last**, even though **c1** started **first**, until and unless, rest of them are **finished/over**. **c1** is based on all of the people. If all over, then only **c1** is over.

![image](https://user-images.githubusercontent.com/54589605/235330987-4393c2ed-58d8-4460-b13c-ffabaa032300.png)

> **Left** means **first**.

* Who will complete first?

> **c3**. Leftmost element of the tree, which is a **leaf** node.

![image](https://user-images.githubusercontent.com/54589605/235331075-543225f9-304a-4c7b-a16d-c67bd39dea56.png)

* c3 -> c4 -> c2 -> c6 -> c7 -> c5 -> c1

> This is the ordering of **function execution**.

![image](https://user-images.githubusercontent.com/54589605/235331095-292bfbfa-d45d-4041-a506-e8e42bc1d3be.png)

* Left -> Right -> Root 

> This is called as **post-order**. It is also called as **bottom-up** approach.

![image](https://user-images.githubusercontent.com/54589605/235331137-f407e73f-3075-40d4-9208-876bf9dc5070.png)
![image](https://user-images.githubusercontent.com/54589605/235331172-aa4cd098-e541-452b-b207-ce2e2ece5610.png)
![image](https://user-images.githubusercontent.com/54589605/235331193-4b2e0b32-ef9c-4b37-9a3d-d99a05a6061a.png)

* Root -> Left -> Right

> This is called as **pre-order**.

![image](https://user-images.githubusercontent.com/54589605/235331248-9adaf6c1-7fd7-4156-bfdb-e27c165b7569.png)
![image](https://user-images.githubusercontent.com/54589605/235331369-0317803f-164a-4e87-a4d9-482763893596.png)

> Every programming language uses **pre-order** for function calling.

> Every programming language uses **post-order** for function execution.

![image](https://user-images.githubusercontent.com/54589605/235331413-ab3dae08-c6d2-46f9-946e-8e1508379b38.png)

* Array is contiguous.
* Linked list may not be contiguous.

![image](https://user-images.githubusercontent.com/54589605/235331531-9c8576d2-9862-4a84-afde-3d3b7c1861d0.png)

* Function call is a **push operation**.

> At **c3**, **c3** can complete directly and call none or no one. As **c3** is a **small** problem.

> At **stack**, **stack-top** will execute.

![image](https://user-images.githubusercontent.com/54589605/235331663-c2dcb91b-132c-4ea7-a8d1-5ae9759698f0.png)

> Completed means **POP**, before **POP**, it returned to it's **parent**. 

* **Siblings** are at the **same** level.

* **Parents and children** differ by **1-level**.

> All children will not come at the same time. One after another, they will come.

![image](https://user-images.githubusercontent.com/54589605/235331828-3a14a05c-b9d7-49cd-8d86-c7102616a35b.png)
![image](https://user-images.githubusercontent.com/54589605/235331918-2b41545e-7440-4012-ae4a-edd69edba6c3.png)
![image](https://user-images.githubusercontent.com/54589605/235331933-ff054891-762b-468d-b6e3-0856d240f21d.png)
![image](https://user-images.githubusercontent.com/54589605/235332042-1a2cc9c5-9607-4e20-9ca1-7f81a4a3c953.png)
![image](https://user-images.githubusercontent.com/54589605/235332056-cee4950a-33eb-4316-a3f8-6bc32e5d60ae.png)
![image](https://user-images.githubusercontent.com/54589605/235332100-d6eef294-458a-4ec7-8c77-8494b25aebc4.png)
![image](https://user-images.githubusercontent.com/54589605/235332129-a71708f4-1a19-446f-b0d2-7ef66759969c.png)
![image](https://user-images.githubusercontent.com/54589605/235332134-1b2d41f1-5bff-45e3-97bc-e5b48f5ae17c.png)

* How many places divide?

> **3**.

> In those **3** places, **Combine()** also happened. Those many places **divide** happened, those many places, **Combine()** also happened.

> How many times, we **divide**, those many times, we **combine**.

* In the above tree, how many levels?

> **3**.

> Whenever we are dividing, we are **dividing by 2**. Middle means by 2. If we always do by 2, then it is **log n** levels. So, there are **7** elements, then **log 7 base 2** levels. So more than **2** levels, which is **3** levels.

> So, if we always do by 2, then **log n base 2** levels will come. 

> So, if we always do by 3, then **log n base 3** levels will come. 

> So, if we always do by 5, then **log n base 5** levels will come. 

> We are always dividing into two **equal** parts, when **dividing by 2**. Half on the left and half on the right. It is **log n base 2** levels.

![image](https://user-images.githubusercontent.com/54589605/235332367-2d396de6-41d5-4c6c-99f2-c8c5b91bfa44.png)
![image](https://user-images.githubusercontent.com/54589605/235332378-31ed566c-d057-4f28-b7b6-bf600fe8d19e.png)

> In algo, **floor and ceil** doesn't matter.

* How many levels, in the above tree?

> Asymptotically, **log n** levels.

![image](https://user-images.githubusercontent.com/54589605/235332398-9ad559f6-4374-46fa-9a1d-f5503320096f.png)

> Always dividing by 2, so **3** level tree came. what is that tree? **log n base 2**.

![image](https://user-images.githubusercontent.com/54589605/235332428-63a21fc5-9116-4326-a959-adbc4e64a334.png)
![image](https://user-images.githubusercontent.com/54589605/235332429-bf86513a-7702-4589-ac19-e14993537d64.png)

> **Tree** and **stack** both are **same**. **YES**.

> In the **stack**, **c1** will be at the **bottom**, but in the **tre**, **c1** will be at the **top**.

> Rotate the tree, **180 degrees** and we will get **stack**.

> In-side, computer **stack** will be there. **Tree** is for **our/human's** purpose.

* Computer -> Stack
* Humans -> Tree

> Computer never contains **tree**. It contains **stack**.

![image](https://user-images.githubusercontent.com/54589605/235332560-4e0d0da3-3957-49b4-9157-c37e8980a0d5.png)

* How many levels, stack has?

> Stack contains as many levels as tree does, because **stack and tree** are **same** only.

> So, it is **log n**.

![image](https://user-images.githubusercontent.com/54589605/235332615-25306161-d87f-4ea7-9947-a47201ad0f3d.png)
![image](https://user-images.githubusercontent.com/54589605/235332631-de0cc2e3-800b-42c9-be18-5b25a334bab8.png)

> Since dividing by 2, so **base 2**.

> Those many **divides**, those many **combines**.

> The tree level is **log n**.

![image](https://user-images.githubusercontent.com/54589605/235332656-04008c96-73b9-4204-bcb0-105d6bef90dc.png)

> Everywhere is **divide by 2**. So, **log n base 2**.

![image](https://user-images.githubusercontent.com/54589605/235332734-88722cea-ddc1-462d-8cc6-3f1e03ff3ed1.png)
![image](https://user-images.githubusercontent.com/54589605/235332774-06e7eadc-ffd8-4f9e-aa11-0bde1566e59a.png)

* Done, after **divide**.

> Using **Divide and comquor** technique.

![image](https://user-images.githubusercontent.com/54589605/235332851-f58f6b04-0263-46ba-bd70-cd03ba5077e0.png)
![image](https://user-images.githubusercontent.com/54589605/235332869-f26d26e1-0de4-4e45-9a40-e955587a068b.png)

* Divided into **3** parts. **Log n base 3**.

![image](https://user-images.githubusercontent.com/54589605/235332960-6ddac40a-60bd-4ab0-96cf-b0669abbcbc1.png)
![image](https://user-images.githubusercontent.com/54589605/235332964-b949882f-1bd0-47c4-ac1e-8e0f03ec605d.png)
![image](https://user-images.githubusercontent.com/54589605/235332997-091e5737-fb3b-4459-ac18-edba19eb5dfe.png)
  
> Recursive program **running** is time consuming.

![image](https://user-images.githubusercontent.com/54589605/235333370-818d6c6d-7325-43e1-a298-3a3be5a8cc4e.png)
![image](https://user-images.githubusercontent.com/54589605/235333376-7e26ca05-9021-4216-a865-04f6a1565816.png)
![image](https://user-images.githubusercontent.com/54589605/235333432-a43ed770-407c-40fd-a2bb-fa630e366756.png)
![image](https://user-images.githubusercontent.com/54589605/235333446-a4419c18-34b4-4be1-894c-20be1e16d84e.png)

* Small and solution(if part). **If** part is **small** problem.

![image](https://user-images.githubusercontent.com/54589605/235333459-25c9f165-633c-43b8-b1ee-19d1d1e3ba07.png)

> **else** part is **big** problem.

![image](https://user-images.githubusercontent.com/54589605/235333496-17f04f9c-e96a-47b4-ac0e-992d9c44e458.png)
![image](https://user-images.githubusercontent.com/54589605/235333543-6db1826d-b4ff-4b12-9612-d53a10d97a80.png)
![image](https://user-images.githubusercontent.com/54589605/235333573-c5631669-157f-4d4a-999c-b017c5043f06.png)

> Conquor completed successfully, we got **left and right** answer. Now, we can go for **Combine()**.

> Inputs of **Combine()** are the **outputs** of **Conquor()**.

![image](https://user-images.githubusercontent.com/54589605/235333643-5b0c6476-52c5-477a-aa4b-f6d232ad7587.png)
![image](https://user-images.githubusercontent.com/54589605/235333661-ae5430a3-ffe3-4ddb-a53d-318df7e09b01.png)

> So, the **Combine()** algo will take **4** things as inputs, it will **return**, **2** things as **output**.

> **Conquor** over means we have **4** things, **max1, min1, max2 and min2**.

![image](https://user-images.githubusercontent.com/54589605/235333741-8da99b61-8d0a-45e9-8173-f8067d7ad5b9.png)
![image](https://user-images.githubusercontent.com/54589605/235333763-5b588eea-dc0f-41ae-875d-bc1bf540e7d0.png)

> Just take both the **max** and find out which is the real **max**.

> Just take both the **min** and find out which is the real **min**.

> Now, we got **overall**, **max and min**.

![image](https://user-images.githubusercontent.com/54589605/235333798-1eb2f0f8-314f-48b1-8b5c-b4cbcc15cb7b.png)
![image](https://user-images.githubusercontent.com/54589605/235333803-af2e4315-99cd-49e0-bf93-ac46ab30c48c.png)
![image](https://user-images.githubusercontent.com/54589605/235333812-21c5d850-4307-480e-ae06-2b0de524bf77.png)

> We are dividing into **2** parts.

> If we divide into **3** parts, then we will get **3** maximums(max1, max2 and max3).

![image](https://user-images.githubusercontent.com/54589605/235333879-aeb39ca3-069b-4199-859c-28ac0e174ca0.png)

* Recursion will take care.

![image](https://user-images.githubusercontent.com/54589605/235333890-8d0621df-b19c-47bc-a2dc-e9d20f43df62.png)

* Conquor. Solving **sub-problems** is **conquor**.

> **Conquor** step is over means, we got the **answers/solutions** for the **sub-problems**. Now, we can **combine**.

> In **combine**, we are **comparing**.

* Steps:

1) First **Divide()**.
2) Then **sub-problems** came.
3) Solve **sub-problems**, that is **recursion**. This is **Conquor()**.
4) Then **Combine()**.

![image](https://user-images.githubusercontent.com/54589605/235333979-6fd8195c-d858-42da-8b47-364a4b447393.png)
![image](https://user-images.githubusercontent.com/54589605/235334007-7b503264-c55b-42b0-8cba-63e066321e0a.png)

> We have **divided** the problem into **two** equal parts.

![image](https://user-images.githubusercontent.com/54589605/235334035-667cde01-b2cc-458c-b8d5-58f5074c3f7b.png)
![image](https://user-images.githubusercontent.com/54589605/235334042-bff17a76-8391-47c6-ba03-a358407e3c05.png)

> Divde and conquor, max-min for **n** people is **T(n)**.

> Divde and conquor, max-min for **n/2 or half people** people is **T(n/2)**.

![image](https://user-images.githubusercontent.com/54589605/235334083-26e7a201-e1b3-450b-a125-218befe15e4b.png)

> After getting both the solutions, we will **Combine()**. Inside, **Combine()**, there is no **for** loop. So, it is **constant or O(1)**.

![image](https://user-images.githubusercontent.com/54589605/235334100-37c99ad4-3e1f-4762-a788-09cbf54adfc4.png)

> For **Divide()**, there is no **for** loop. So, it is **constant or O(1)**.

![image](https://user-images.githubusercontent.com/54589605/235334114-2d76889b-91c7-4a9b-ad6e-b38d2a7f5316.png)

> For **Small() and Solution()**, there is no **for** loop. So, it is **constant or O(1)**.

![image](https://user-images.githubusercontent.com/54589605/235334137-89a95080-6508-432b-bfda-aea86fc23f58.png)

## Time complexity of above program.

* Write Recurrence relation for **time**.

![image](https://user-images.githubusercontent.com/54589605/235334180-d733189f-c138-46d8-bab8-7a76d7430dac.png)

* **T(n)** = 2 * T(n/2) + C

> **C** is the amount of time required for **both**, **Divide() and Combine()** functions. Amount of time is for **first level** only.

![image](https://user-images.githubusercontent.com/54589605/235334216-f1cf7348-0114-4319-9ceb-ca1e74381a91.png)
![image](https://user-images.githubusercontent.com/54589605/235334235-2cae9fdd-d7b3-42c8-8996-1bdc826da9a4.png)

> In the **first level**, we have done **Divide() and Combine()** function both.

![image](https://user-images.githubusercontent.com/54589605/235334253-a068872a-b5c5-4b7c-a172-e4fe2179fbae.png)
![image](https://user-images.githubusercontent.com/54589605/235334264-7cab0f89-45e3-472c-b47c-6d6816618ade.png)
![image](https://user-images.githubusercontent.com/54589605/235334271-8691b04b-dd44-4ca2-8aa0-ae1098c25e20.png)
![image](https://user-images.githubusercontent.com/54589605/235334278-c8a0a676-2684-4a30-ac52-68c65fb5c80d.png)

> **n** is **bigger** than **c**. We have to **divide** right side **n** with **n**, so that both the sides are **equal**. So, we are **dividing** by **polynomial**, means **n** is **polynomial** times **bigger** than the left side person.

> Hence, **Case 1 and 3** are allowed, so, whoever is **bigger** is the **answer**.

> So, **n** is **bigger**, hence **Theta(n)**.

![image](https://user-images.githubusercontent.com/54589605/235334306-e54b6192-c0a0-4415-b69e-67133d4bee8b.png)
![image](https://user-images.githubusercontent.com/54589605/235334349-a7b1ccc1-839b-4478-9f90-09b74f530e9d.png)
![image](https://user-images.githubusercontent.com/54589605/235334397-66ac5de9-0b5c-464d-a364-68f9679ea257.png)

> **Log n** time in **substitution** method is called as **stack space**, which is **how many times we have substituted**. 

![image](https://user-images.githubusercontent.com/54589605/235334426-369ebf65-23c0-4b70-99d4-0870ca43a69f.png)
![image](https://user-images.githubusercontent.com/54589605/235334454-a0b80248-3113-49ba-9698-0c7f49d8f462.png)

> **Divide()** time is **constant** because there are **no loops** in the **Divide()** code.

> **Combine()** time is **constant** because there are **no loops** in the **Combine()** code.

> In the **if** condition, there are **no loops** so, the **Small() and Solution()** functions have **constant** time.

![image](https://user-images.githubusercontent.com/54589605/235334487-e3e80ccc-fb43-4a21-bee3-3f008c3d7c6c.png)

> In **Conquor()**, it is always **same**, because **recursion** is always **same**.

> **Master's theorem** doesn't give any clarity about, no. of **levels** in the tree. **NO**. **Master's theorem** purpose is only **answer**.

![image](https://user-images.githubusercontent.com/54589605/235334584-08b2bb9d-dcb7-4577-980b-0e5a123c87d5.png)

* Continuing **substituiton** method.

> We can **stop** at **1 or 2**.

![image](https://user-images.githubusercontent.com/54589605/235334637-e88c5a0d-ce87-41b1-bb0e-5bbed6eb9920.png)
![image](https://user-images.githubusercontent.com/54589605/235334640-f63e1778-3318-43b9-ab7a-41c344096401.png)

> Last level is **n/2** people.

![image](https://user-images.githubusercontent.com/54589605/235334661-e13091ec-ecdc-4605-8a57-23e4abf00045.png)
![image](https://user-images.githubusercontent.com/54589605/235334669-2c35189f-90ac-4b0b-b251-28bac7347418.png)

> Leave it. Approximated is **OK**.

![image](https://user-images.githubusercontent.com/54589605/235334704-8b0321b8-57c2-4369-8e6b-c4a4786e08d9.png)

## Slide Numebrs

![image](https://user-images.githubusercontent.com/54589605/235334713-39cfdf93-424a-4f60-96f4-101481842865.png)
![image](https://user-images.githubusercontent.com/54589605/235334722-7a43162f-f208-4285-ad00-257e60c02a20.png)
![image](https://user-images.githubusercontent.com/54589605/235334724-db886526-7376-4544-a0dc-d95de6be68ea.png)
![image](https://user-images.githubusercontent.com/54589605/235334731-c7ec2897-f3af-4a0f-af85-bcf16f783580.png)
![image](https://user-images.githubusercontent.com/54589605/235334735-bb5dc137-844b-4c9e-90c5-c69e1661fb4f.png)

![image](https://user-images.githubusercontent.com/54589605/235334740-6117952d-2f5f-4e87-89d1-bbbdfa179550.png)

* Same only

* Space Complexity -> Stack Space -> O(log n).

![image](https://user-images.githubusercontent.com/54589605/235334755-20f77e46-d568-42f5-8f40-5d294a282736.png)

> Master's theorem will not give **stack space**. It will only give **answer**.

## Doubt_Clearing_Session (22) [30th April 2023]

* Time complexity recurrence relation  -> 2T(n/2) + C. -> Theta(n)

![image](https://user-images.githubusercontent.com/54589605/235347534-bb76b52b-3865-4064-a7c2-8ceb4d3d567c.png)

> **Else** is **more** valuable.

> The **time complexity** to find max-min is **O(n)** for **every case**. We cannot stop in-between. It is **every case**.

![image](https://user-images.githubusercontent.com/54589605/235347626-ccfd578d-fd1b-4fa4-90cb-3c9cf63c5c22.png)

> Recursive program's **space** is based on **no. of levels**.

> Stack space is based on **no. of levels**.

* c1 push -> c2 push -> c3 push -> c3 pop -> c4 push -> c4 pop -> c2 pop -> c5 push -> c6 push -> c6 pop -> c7 push -> c7 pop -> c5 pop -> c1 pop

> If completed, then only **popped**.

> **Function calling and function execution**, both are done **simultaneously**, if possible, **immediately** done.

> **c2 and c5** are **sibling**, once **c2** is **popeed**, then only **c5** is **pushed**.

> Whenever recursive programming is executing, **stack space** is based on **no. of levels**. [**IMPORTANT**]

> Recursive programs, create a recursive **tree**, which is nothing but a **stack**. In the stack, **how many levels are there** is called as **stack space**.

> If we want **time complexity**, then solve recurrence relation for **time**.

> We have substituted **log n** times as there are **log n** no. of levels in the tree, that's why **stack space or space complexity** is **log n**.

![image](https://user-images.githubusercontent.com/54589605/235350123-6554d3dd-dcae-4d29-ae80-b9fd3dd97ea2.png)
![image](https://user-images.githubusercontent.com/54589605/235350157-137efd8a-6b4d-45b3-8a2d-0312175f65b6.png)

> **Array** is fixed space only.

> Finding **max-min**, **else** part is **important**.

* Divide -> O(1)  [No loop]
* Left part(sub-problem) -> T(n/2)
* Right part(sub-problem) -> T(n/2)
* Combine -> O(1) [No loop]

![image](https://user-images.githubusercontent.com/54589605/235350314-3f1234f9-6c3f-4bde-a949-61fee2af118a.png)

> From problem to problem, those **4** functions(Divide, 2 * Conquor, Combine) will **change**. Whenever **code** changes, **time complexity** will also change.

> The above problem's **time complexity** is **O(n)**.

> Conquor is always **recursion** and there are **two** function calls, so **2 * T(n/2)**.

![image](https://user-images.githubusercontent.com/54589605/235350451-2eea791b-7d0b-4fa6-93cb-486e7a416d8d.png)

> Less function calls **less time**. 

> More function calls **more time**. 

> If we divide **one element**, each level, then the **no. of levels** is **n**. **n** level stack required. Stack size increasing.

> Time complexity is **same** which is **n** only but **space** is **increasing**.

> Unnecessarily **space is increasing**.

![image](https://user-images.githubusercontent.com/54589605/235350855-6b9c28ac-f4f9-41ee-bd4c-54d40af343a7.png)

* Let c(n) be the no. of comparisons between the elements in the above algorithm on **n-elements* array.

> Divide and conquor for **max-min** for **n** elements is **c(n)** comparisons.

> Divide and conquor for **max-min** for **n/2** elements is **c(n/2)** comparisons.

![image](https://user-images.githubusercontent.com/54589605/235350997-88db70a5-44ac-4feb-889f-166c98c4c7f1.png)

> For **1-element**, no comparisons.

> For **2-elements**, one(1) comparison is there.

> **Divide()** has no comparisons.

> In **Combine()**, there are **2** comparisons.

![image](https://user-images.githubusercontent.com/54589605/235351070-dd839421-61fb-4f11-9d30-7fc00960e949.png)

* We are calculating **comparisons**.

> Don't write **constants**, write the exact **numbers**, we are not calculating **time complexity** here.

> For **if** purpose, bring **n** value, in **else** don't bring **n** value. It is **very big**.

> Don't give number for **conquor**, it is **recursion**.

> For **non-recursion**, we can give number.

![image](https://user-images.githubusercontent.com/54589605/235351426-0ed45197-94dc-4600-985f-1faf1c4361b9.png)

> a[i] and a[j] are comparison **between elements**, it will give **value**.

> i and j are comparison **between positions**.

![image](https://user-images.githubusercontent.com/54589605/235351469-12f1d902-106c-4cad-a2ab-9fbbe6920167.png)

> Question asked, comparisons between it's elements.

* Recurrence relation **comparisons**.

> The goal is **else** part only and not **if** part.

![image](https://user-images.githubusercontent.com/54589605/235351532-1e15a6b6-681e-4ef1-87cd-44666adf4366.png)

* Exact number required. 

> We have to do **substitution** method, because we want **exact** answer.

> First and second level **non-recursive** term is **different**.

![image](https://user-images.githubusercontent.com/54589605/235352402-086a493e-ca91-4d4f-bb1f-34f1742dfaec.png)

> For first level, **Divide is zero(0)**, **Combine is 2**, so the overall is **2** for the **first level**.

> For second level, **Divide is zero(0)**, **Combine is 2**, so the overall is **0 + 2 + 0 + 2 -> 4 -> 2^2** for the **second level**.

> For third level, **Divide is zero(0)**, **Combine is 2**, so the overall is **0 + 2 + 0 + 2 + 0 + 2 -> 8 -> 2^3** for the **third level**.

> For every level, **Divide and Combine** is going on.

![image](https://user-images.githubusercontent.com/54589605/235352540-0cb57307-82ad-4369-83a3-f63ee20d767c.png)
![image](https://user-images.githubusercontent.com/54589605/235352631-fda5d910-f340-4bc2-a941-bdf48dea1e4b.png)

> We have **two** terminations, **1 and 2**, we can stop at **2** also.

![image](https://user-images.githubusercontent.com/54589605/235352698-87b01b9d-7166-4a3c-a376-6822a54b8770.png)

* c(2) -> 1.

![image](https://user-images.githubusercontent.com/54589605/235352872-c6816f28-c8f0-4586-8230-ba3f52c5f062.png)

* We did **exact**.

> The algo to find **max-min** using divide and conquor, will take **1.5 * n - 2** comparisons.

![image](https://user-images.githubusercontent.com/54589605/235352934-86964173-c7dc-4e0a-a72f-90e2f7a15334.png)

* To find **max-min** using divide and conquor, how many comparisons needed?

> **1.5 * n - 2** or **(3 * n)/2 - 2** comparisons.

> Anything we can use for **asymptotic notations**. That should be **last line**, don't do anything in-between.

* Actual answer is **1.5 * n - 2** or **(3 * n)/2 - 2** comparisons, which is **Theta(n)**.

![image](https://user-images.githubusercontent.com/54589605/235353105-7db89912-0166-4d96-a8b5-8972dbb56193.png)

* In **MSQ**, both are correct.

> If **exact** is there, then why go for **approx** answer. [**IMPORTANT QUESTION**]

* **1.5 * n - 2** or **(3 * n)/2 - 2** comparisons is for **n > 2**.

![image](https://user-images.githubusercontent.com/54589605/235353172-ebe9b70f-5b15-49d5-a5b1-e09c39b922e9.png)

* What is the prodecure to find **1.5 * n - 2** or **(3 * n)/2 - 2** comparisons? [**IMPORTANT QUESTION**]

> Write the recurrence relation and solve it using substitution method.

![image](https://user-images.githubusercontent.com/54589605/235353249-d0a40b63-b1ec-4c91-9610-080a74bdd1a6.png)
![image](https://user-images.githubusercontent.com/54589605/235353268-631ef632-792e-47c8-bee8-f61d7ef03075.png)

> One is **left max and right max** comparion. Another is **left min and right min** comparison. So that we get the overall **max and min**.

![image](https://user-images.githubusercontent.com/54589605/235353341-4e0c5704-f034-4857-b27a-ead3096bf5ac.png)
![image](https://user-images.githubusercontent.com/54589605/235353355-f920b907-cfa0-49f4-8b66-9e34515e6847.png)

> **Total divide and conquor with every application** is having **similar** story.

![image](https://user-images.githubusercontent.com/54589605/235353444-88caa4f8-6ac0-4a3d-a68d-0def85eae7b7.png)
![image](https://user-images.githubusercontent.com/54589605/235353454-c5524c5e-2b40-4cf9-a89b-7c617eacb073.png)

* Both are **similar**.

> In recurrence relation for **time**, **c** is constant so we can write **O(1)**. It can be **anything**.

![image](https://user-images.githubusercontent.com/54589605/235353498-5b54a3d1-23ec-48d0-b40b-888fe70c73d8.png)

> In recurrence relation for **comparisons**, it is **2**, nothing more and nothing less.

> The program had **two(2)** terminations(1 and 2), and we stopped at **2** element.

> If we continue **one more level** till **1**, then **one more term** will **increase**. Automatically, **comparisions** will **increase**.

> Then it will become **2 * n - 2**.

![image](https://user-images.githubusercontent.com/54589605/235353679-7608c5ce-b28a-4d04-ba1e-4e77535d622e.png)

> We have chance to end at **element 2**, then why we should go to **element 1**. Stop at **2**.

> Stopped at **2** for **less comparisons**.

> **2** will come first, so that we can **stop** one level. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/235353872-f9feec3d-b506-425d-9123-ad8c4722cbd6.png)

> Among **Divide and combine**, **Combine()** is take more **comparisons**.

![image](https://user-images.githubusercontent.com/54589605/235353937-4c6cd2cd-149f-4266-82a0-d74917c14c50.png)

> If we want **approximation**, then go to asymptotic notation.

> In the **time complexity** recurrence relation, the final time we got was **Theta(n)**.

> In the **comparisons** recurrence relation, the final comparisons we got was **Theta(n)**.

> They are **same**.

![image](https://user-images.githubusercontent.com/54589605/235354209-9f4586fb-1e4d-4ceb-853e-f4461bb84fcd.png)

> They both will take same **time**. The **constant factor** in **stright max min** algo will take **more comparisons**.

* Finding **max-min**, how many comparison?

> **1.5 * n - 2** or **(3 * n)/2 - 2** comparisons.

## Problem

![image](https://user-images.githubusercontent.com/54589605/235354348-ce92beaa-2c13-48eb-a741-500f9ef60b26.png)

* To find **max-min** in the array of 100 elements, comparisons needed?

> 1.5 * n -2 -> 1.5 * 100 -2 -> 150 - 2 -> 148.

> Remember the **comparisons**.

![image](https://user-images.githubusercontent.com/54589605/235362471-443dc197-92f1-4254-8cd5-67e6c4bbfe62.png)
![image](https://user-images.githubusercontent.com/54589605/235362567-c1cc2c63-c3e7-468d-9a34-77bbe5e71002.png)

> When **no algo** mentioned, which ever **better**, go for that.

> If mentioned, take that only.

> If nothing mentioned, we have flexibility.

![image](https://user-images.githubusercontent.com/54589605/235362949-de9e9bbf-49d4-49d1-9e62-a331d54a84db.png)
![image](https://user-images.githubusercontent.com/54589605/235363531-d87122bd-3976-4c58-80b3-225b565812f1.png)

> Repeatation not allowed. Sorted yes.

![image](https://user-images.githubusercontent.com/54589605/235363598-8dd3b4a6-8576-460a-b250-38486e83a89a.png)

* Time complexity is **O(1)**.

> No comparisons.

![image](https://user-images.githubusercontent.com/54589605/235363698-5e574f01-c34d-466d-ba8e-2d0ca3ae2a18.png)

* Best Algo only -> O(1), constant time. Every case
* return (2nd element)

> Other than **first and last** element, return any element.

![image](https://user-images.githubusercontent.com/54589605/235363763-def5f878-a83a-4349-b72a-0dde686b1a72.png)
![image](https://user-images.githubusercontent.com/54589605/235363774-e8bc6041-6546-4a15-b240-011f1c798ee8.png)

> To find **max-min**, we have a well known algo. Worst case is that we have to use that algo.

> The question didn't mention, give **best algo** but also didn't say give **worst algo** as well. If nothing mentioned give **best algo** because there is no limit or limitation end of **worst algo**.

![image](https://user-images.githubusercontent.com/54589605/235364025-2925cc08-b5b1-423c-ba93-d4b2b5ef0845.png)
![image](https://user-images.githubusercontent.com/54589605/235364416-1ba5c70c-5e3d-4276-90c1-6039d54020eb.png)

![image](https://user-images.githubusercontent.com/54589605/235364471-a4a061ef-accd-4fde-b487-48433d9cfa98.png)

* Not sorted. No duplicates.

> We have to scan the whole array **once** to find the **min and max** elements. Then only we can give an element which is neither max nor min.

> So, time complexity is **O(n)**, which is the worst case. 

> Let's try to find if any better time complexity is there or not.

> Take first three elements and sort them. It will take **constant** time. **80** is the **answer** because he is either min nor max, as there is **10** which is a min element and there is **90** which is the max element.

> So, **80** is either min nor max element.

> As there is one element which is less than **80** and there is one element which is more than **80**. 

> The entire process will take **constant or O(1)** time. [**Correct Answer**]

![image](https://user-images.githubusercontent.com/54589605/235365208-28e63ada-526b-4cbb-b60c-d18b7edfd16a.png)
![image](https://user-images.githubusercontent.com/54589605/235365311-3075240f-d1a1-4001-bee0-972f8463b1e6.png)

> To find out **1 element** which is either max nor min, we don't need to scan the whole array.

> Take first **3 elements**, sort them. Return **middle** person.

> Middle person should be the **answer** because there is **one element more** than middle element and **one element less** than middle element.

> Any **3 people** ok, sort them and return **middle** element.

* Time Complexity -> O(1) [Best algo, Every case(EC)]

![image](https://user-images.githubusercontent.com/54589605/235365548-379ab773-0ecb-4930-98fb-5704517e8023.png)
![image](https://user-images.githubusercontent.com/54589605/235365657-efdf4e2b-857c-4ad8-8c88-c2df3fd199c0.png)

* Straight max-min without divide conquor strategies -> (2 * n) - 1.
* Max-min using divide conquor strategies -> (1.5 * (n)) - 2.

> **Max-min using divide conquor strategies** is asymptotically **better** than **Straight max-min without divide conquor strategies**.

> In both of them, we are doing **one scan**.

> Both of the algos are the **same**. 

## Required slides

![image](https://user-images.githubusercontent.com/54589605/235366066-b5fd1e1b-3486-4359-aebc-4501852757bd.png)
![image](https://user-images.githubusercontent.com/54589605/235366078-5515820b-6c36-4924-a5bd-bcd7122b29a3.png)
![image](https://user-images.githubusercontent.com/54589605/235366083-a18fc524-a55d-4cf7-89e8-776f6ce54e53.png)
![image](https://user-images.githubusercontent.com/54589605/235366085-1781cd70-723e-4341-b3f7-75f1fbc45baf.png)
![image](https://user-images.githubusercontent.com/54589605/235366093-0f419529-7c81-4f72-93ce-a0b4a853af20.png)

> In one problem, we don't know which one to apply, either **straight max-min** or **divide and conquor max-min**, then always apply **divide and conquor max-min**, that's the last one we have to see.

![image](https://user-images.githubusercontent.com/54589605/235366190-ea367dc1-a1bb-48ce-ae92-cc539d30c011.png)

* Not sorted but distinct is there.

![image](https://user-images.githubusercontent.com/54589605/235366220-7e90a21b-8f55-4b34-aed9-a0614fed9834.png)
![image](https://user-images.githubusercontent.com/54589605/235366275-e9115f16-1159-4d61-947f-8aa3770b563b.png)

* Same as above problem but **not sorted** and **not distinct**.

> Repetition is allowed.

> We took first **3 elements**, sort them and returned the **middle** element. We cannot do this because of **non-distinct** elements. There is no gurantee now.

> Worst case is we have to **scan array once**.

> So, time complexity is **O(n)**.

![image](https://user-images.githubusercontent.com/54589605/235366414-696dae23-67b5-4813-bef6-f2ebc8968ac3.png)

> This is the **only algo** possible.

* **Time complexity**  ->  **O(n)** [Best algo]
* Worst Case -> **O(n)**.
* Best Case -> **O(1)**.

> We didn't get any doubt of **best, worst or best** case in the previous questions, because all of the **cases** were the same, that's why we wrote **Every Case(EC)**.

> In the above question, we have different time complexities for different cases.

![image](https://user-images.githubusercontent.com/54589605/235366568-57e5cd8b-0fca-4982-95b8-ad82054946bf.png)
![image](https://user-images.githubusercontent.com/54589605/235366596-08295c0b-d2ad-4e47-8a0b-fe846b8d7526.png)

## DAC-VII (23) [30th April 2023]

## 2. Power of an element

![image](https://user-images.githubusercontent.com/54589605/235367653-ac061971-cbab-4b98-94ec-1afc8cd71107.png)
![image](https://user-images.githubusercontent.com/54589605/235367787-d770488a-fb89-45fb-957c-42cea190d597.png)

> Everytime, **a** is **multiplied**.

* Time complexity -> **O(n)**.

> Above algo is **without** divide and conquor strategies, normal approach.

![image](https://user-images.githubusercontent.com/54589605/235367988-2da2b21e-c34f-4eb5-a4e1-23d2c4fce11b.png)
![image](https://user-images.githubusercontent.com/54589605/235368012-dc782af5-d3cf-4c75-a474-7f4c1acc4248.png)

* Goal is with divide and conquor strategies, only.

![image](https://user-images.githubusercontent.com/54589605/235368070-bbaaa982-f55c-4ab1-a094-96d8fa0e1862.png)
![image](https://user-images.githubusercontent.com/54589605/235368182-7a91d2ae-7561-492e-a906-0a0717758e79.png)

> With **divide and conquor** strategies, we will first **Divide()**. We have to **divide**.

![image](https://user-images.githubusercontent.com/54589605/235368285-d87bee17-1cce-44d7-9fd5-da4bc5e2dbd6.png)

> Calculate **both** and **multiply**.

> We have to define, **small problems**.

![image](https://user-images.githubusercontent.com/54589605/235368328-80a53cec-8852-4ba7-959f-3efe40b6d976.png)
![image](https://user-images.githubusercontent.com/54589605/235368392-54dad1ee-1f8a-415c-a3d9-8830549f0569.png)

> One time, we have **saved**, we can further use it. It is the **power of loops**.

> According to problem, we have to take care.

> **Always by 2**, so, **log n** levels.

> We divided **32**, 5 times.

* log n base 2 -> log 32 base 2 -> log 2^5 base 2 -> 5 [**Answer**]

> Afte getting **sub-problem** answer. **b and b**.

> Our goal is **algorithm**.

> We already got **half answer**.

![image](https://user-images.githubusercontent.com/54589605/235369154-cb8ad9ad-4d8c-4eea-933a-d9c35e526164.png)
![image](https://user-images.githubusercontent.com/54589605/235369206-fd5c1c53-9cce-430c-b1c5-7642fd070683.png)

> So many **recursive calls** are there.

![image](https://user-images.githubusercontent.com/54589605/235369242-0b01ef4b-bdad-4d81-8478-4108540b883d.png)

* Recursion.

> While **execution** going on, so many **recursive calls**.

> We will write the code, **only once**.

> If we write it many times, then no point of **Recursion**.

![image](https://user-images.githubusercontent.com/54589605/235369506-62d697c1-9297-4ad1-a66c-7ff083756026.png)

> Recursive program writting, we will just give **path**.

![image](https://user-images.githubusercontent.com/54589605/235370084-7239a499-0cc4-413c-aad0-57a0969f524e.png)
![image](https://user-images.githubusercontent.com/54589605/235370116-bf21279a-1da5-4677-8a9a-36588aea9ee1.png)

> All divide and conquor strategies have these **4** functions only.

> **Small, Solutions, Divide and Combine** have **no loops**, so their **time complexity** is **O(1)**.

![image](https://user-images.githubusercontent.com/54589605/235370256-5d2cb2f0-36d2-4469-9256-fdffb98a8e20.png)
![image](https://user-images.githubusercontent.com/54589605/235370272-3cbf3adf-1be4-441b-91d6-592d27468835.png)

* Let, **T(n)** be the time complexity of the above algo to find **a^n**.

* **c** is **constant**, but it is the **amount of time** required for both **Divide() and Combine()** at **first** level.

* It is a **unary** tree. Everywhere , **one(1) c**, because of **one function call**.

![image](https://user-images.githubusercontent.com/54589605/235370477-bdef2196-8a48-45f6-9bdd-9996b55bc648.png)

> Time complexity of **a^n** value after using divide and conquor strategies is **O(logn) or Theta(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235370627-a979479a-1dd5-41d3-adb7-f8ea7976d478.png)

> If we repeat it, **log n** times, then we will get **log c**.

![image](https://user-images.githubusercontent.com/54589605/235370660-1b5f7599-1d7f-42c4-bc2a-3a8abf0c43de.png)

> **a^n, where n=1** is a **small** problem. So. it is **O(1)**.

> Big problem cost is **log n**.

> Overall cost is **small + big problem** cost which is **O(1) + O(log n)**. So the overall cost is **O(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235370790-1c56ffad-01ad-4a43-8ded-abcc7de123ab.png)
![image](https://user-images.githubusercontent.com/54589605/235370827-ff1491a5-e42e-41d2-bb3d-338131907804.png)

> Left and right side, **bigger** function **same**, so we can write **theta** also.

![image](https://user-images.githubusercontent.com/54589605/235370863-b12c1ca5-01fa-4607-ab16-9ad0a7052da2.png)

* Stack space -> **O(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235370874-bc3cb3ff-0ac2-4daf-87eb-60bfee2a50b4.png)
![image](https://user-images.githubusercontent.com/54589605/235370910-b7d2f6ec-778b-4b0b-88b1-6bbee74d2ad1.png)
![image](https://user-images.githubusercontent.com/54589605/235370926-45234910-3993-4faf-97b0-f01d3b15fba4.png)

* Final answer what we got is for **time** which is **Theta(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235370964-2d6fcdb5-6c6b-4613-ae87-3c10b420d018.png)

> We can also solve it using **master's theorem**. Both sides are **c or constant**, which means we got **case 2**. So we can add **(log n)^0** to the right side, so that both the sides are sill **equal**.

* The time complexity  -> O((log n)^(0+1)) -> **O(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235371085-28064939-72a2-47ef-ac34-8b68f3c2714a.png)

* Master theorem will give **last answer**.

* Substitution method will say, **how it came**.

![image](https://user-images.githubusercontent.com/54589605/235371133-329e5da1-55ea-46e1-9698-5f7349a33e71.png)

* Time and space complexity  ->  **O(log n)**.

## Slides

![image](https://user-images.githubusercontent.com/54589605/235371261-ce3bc440-162f-4cd9-99fc-d9da9392831e.png)
![image](https://user-images.githubusercontent.com/54589605/235371272-7fec20f7-aef7-45bb-85e5-167d570e1da1.png)
![image](https://user-images.githubusercontent.com/54589605/235371279-8ac20799-0791-4122-b289-146378a7df80.png)

* Recursive program, stack space is based on **no. of levels**.

> If **n** value is **even**, then **no problem** and also we can **directly** return **c**.

> **Else** means **odd** numebr, then return **a * c**.

![image](https://user-images.githubusercontent.com/54589605/235371603-d5063120-e53c-40ed-8453-3dc9150338a3.png)

> While **returning** check if the numbers are **even or odd** numbers.

> By doing **small adjustment**, we can handle **odd numbers** also.
 
![image](https://user-images.githubusercontent.com/54589605/235371780-cdb157e0-7f7b-4478-8f19-1027c379e849.png)

> **No loop** is there, so **time complexity** is **O(1)**.

![image](https://user-images.githubusercontent.com/54589605/235371828-dd4372a3-c3bb-4279-975f-52d6d57344b8.png)

> If we repeat **3** times, then **T(n/2^3)**.

> If we repeat **2** times, then **T(n/2^2)**.

> If we repeat for **k** times, then **n/2^k**.

![image](https://user-images.githubusercontent.com/54589605/235371986-d206645d-de14-43be-ac96-0837db2f82c3.png)

> To terminate the above program, the condition we would take is that, **n = 2^k**.

> Remember, **n** cannot be **odd** number. **n** should be **even** number. **n** should be **powers** of 2 only.

![image](https://user-images.githubusercontent.com/54589605/235372112-f008bbe1-3ad5-4bc1-8f5c-6e43363ae7ae.png)

> When it comes to divide and conquor, we will always divide by 2.

> In the total divide and conquor strategy, we are assuming that **n** is powers  of 2.

> When we always divide by 2 and **n** is powers  of 2, then the story is **quite simple**.

> If not powers of 2, then also divide and conquor strategy will work.


* If anyone asked that if **n** is **odd** than the above code will work or not?

> Because of divide and conquor, we are assuming **n** is powers of 2, then **odd** numbers will not come into the picture.

![image](https://user-images.githubusercontent.com/54589605/235372329-d17b8bc6-a6a0-4d86-8bc1-01b5b7496284.png)

> We have done it in **two** parts, because of **dividing by 2**.

> If there are **three** parts, that is because of **dividing by 3**.

![image](https://user-images.githubusercontent.com/54589605/235372417-b5903a8d-272c-4f6c-862d-c570e1b0c765.png)

> If we divide by 3, then **n** is in the powers of **3**.

![image](https://user-images.githubusercontent.com/54589605/235372462-d0402823-78db-44ee-9244-f4c8246999d9.png)
![image](https://user-images.githubusercontent.com/54589605/235372492-22ab7781-3aa5-4b02-ad39-481abcd3f25c.png)

> Without divide and conquor we had done and got **time complexity** of **O(n)**, because of **1 loop**.

![image](https://user-images.githubusercontent.com/54589605/235372550-c9a819bf-14f3-454a-bcfb-f223d6114ec6.png)

> With divide and conquor we had done and got **time complexity** of **O(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235372578-387e5b20-5612-4bef-8f1c-119749de8535.png)

> The loop is repeating **log n** time.

![image](https://user-images.githubusercontent.com/54589605/235372698-e14fc402-bf9b-4407-abba-2dff9941ad49.png)

> Here also, without divide and conquor. We got **log n** time.

> Time complexity is determined by **logic** and not by **divide and conquor** techniques.

> divide and conquor doesn't mean better one.

* With or without, divide and conquor, **log n** time is possible.
* With or without, divide and conquor, **n** time is possible.

> It is **dependent** on how we write it. Differ by **constants** but both are **same**.

> Recursion something possible, non-recursion also possible.

> Non-recursion something possible, recursion  also possible.

* The **only difference** is that in **recursion**, because of so many **function calls**, stack space maybe **more**. From **time** point of view, both are **same**.

> It is **dependent** on what type of **logic** we write**.

![image](https://user-images.githubusercontent.com/54589605/235373007-938f1054-3e28-45fc-8811-9af7e5c3fcb7.png)

* Maybe in terms of **space**.

![image](https://user-images.githubusercontent.com/54589605/235373028-b2606984-6940-476b-8893-4c8522c7e640.png)

* Only **one** function call. So, **one** unit of stack.
* But the other one is having **log n** function calls. So, **log n** units of stack.

> They will both take **one** stack only, but stack units is different.

* Non-recursion is **better** in terms of or from the point of view of **space** compared to **recursions**.
* From the point of view of **time**, they would be **similar**.

![image](https://user-images.githubusercontent.com/54589605/235373165-710b22c4-7817-4131-b8a9-afc79d6af7d1.png)

* For understanding purpose.

> If we write **better logic**, even **better time** will come.

> If we write **worse logic**, even **worse time** will come.

* Time complexity depends on **logic**, how we have written the logic.

* If we want to calculate **a^n**, how much time?

> **O(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235373337-320f88f5-38c6-4afd-afd5-1b333ef11b5d.png)

> With or without recursion, anything is fine.

![image](https://user-images.githubusercontent.com/54589605/235373374-16f47694-0c54-4bc4-b37d-3657eb12d041.png)
![image](https://user-images.githubusercontent.com/54589605/235373403-48fb2260-a2a2-4221-9a38-3172a7539919.png)

> No requirement for doing all **three**. **One(1)** is enough.

![image](https://user-images.githubusercontent.com/54589605/235373418-8077d734-947d-4b2c-aa5c-bede0ed9b426.png)

> How we have **divided**, **combination** will also **change** accordingly.

## DP-IV (24) [1st May 2023]

![image](https://user-images.githubusercontent.com/54589605/235411253-69b0883a-0f54-40c3-9e69-1986acf1b340.png)

## Searching

## Linear Search

1) Linear Search -> * Input -> An array of **n-elements** and an **element 'x'**.
                    * Output -> Returns position of x, else return '-1'. If found then return position of 'x', else                                     return '-1'.

> 'x' is the element we are searching and return the position of 'x' if found, then return '-1'.

![image](https://user-images.githubusercontent.com/54589605/235412170-a0766aea-3c5b-4d7e-ac79-df11aac56e4f.png)
![image](https://user-images.githubusercontent.com/54589605/235412178-65f2ba5e-8b76-42d8-92bf-17b74166892f.png)

> We are **searching** for **one element**. As soon as we get that element we will stop.

> This is called as **Best case**, which is **O(1)**.

* **Best case** -> **O(1)** [Minimum time to solve the problem]
* **Worst case** -> **O(n)** [When last element is the element we want or the element is not present only]

![image](https://user-images.githubusercontent.com/54589605/235412975-c66f26f4-ed0f-4b12-86f6-ed610cc32905.png)

> Finding element x, **best case** is **O(1)**.

> Finding maximum, **one scan** is required, **best case**  is **O(n)**.

* Maximum means **we have to compare all**.

> Best case to find **x** is **O(1)**.

> Best case to find **max or larger** than the others is **O(n)**. We have to compare with the rest of them and do **one scan**.

> Best case doesn't always mean **O(1)**, we have to **adapt and change** according to the problem and then verify.

![image](https://user-images.githubusercontent.com/54589605/235415148-a93fe6eb-b124-43a7-b9cb-ed5903a939d0.png)

* Best case -> O(1) [Minimum time to solve the problem. When first element is the element, we are finding]
* Worst case -> O(n) [Maximum time to solve the problem. When last element is the element we want or the element is not present only]

> **Best case** to finding an element in a array is **O(n)** and the **worst case** is also **O(n)**. So, the **average case** will also be **O(n)**.

> When **best and worst** are the **same**, then **average** case is also **same**. 

> Starting matching is **best case** and ending matching is **worst case**.

> To calculate **average** case, we have to take everyone or every case into consideration.

> Average matters. It is based on **everyone or every case**.

![image](https://user-images.githubusercontent.com/54589605/235416549-cebe08ba-765a-4603-837f-343ee8804c2d.png)

* Calculating **average case**.

![image](https://user-images.githubusercontent.com/54589605/235416950-6a54a53f-6d3a-4be1-89b5-475a7260f26c.png)
![image](https://user-images.githubusercontent.com/54589605/235417027-db994a32-7700-4a80-981c-77a6abd87a88.png)

> We cannot say that **60 and 100** are **average case** values, because we cannot just take **min and max** values and divide them by 2. That doesn't give **average**.

> We have to use the **upper or first image** steps to calculate average. We have to take all of the values into consideration and then find **average**.

> **Average** is not based on **two** scores which are **min and max** values. **It is values on all of the scores.**

![image](https://user-images.githubusercontent.com/54589605/235417315-5ca86418-fdf3-4e98-98ea-5b4005837629.png)

> All the **(people/scores) by n** is **more** accurate than **two people/2**.


 ## Linear search time complexity

* Best case -> O(1)
* Worst case -> O(n)
* Average case -> (n+1)/2 -> O(n).

* Assume, Linear search time complexity -> **T(n)**.

> **T(n)** having **three** choices. For these **three**, we can write time complexity as **O(n)**. Everyone should satisfy.

* 1 = O(n)
* n = O(n)
* (n + 1)/2 = O(n)

> All are satisfied.

> We cannot write, **theta(n)**, because in **theta**, both sides should be **equal** but they are not. So, **1** is not satisfied with **theta(n)**. So, **theta(n)** not possible.

![image](https://user-images.githubusercontent.com/54589605/235417903-a2b449c0-e2c9-4a97-9ed6-f0dabc7e53b4.png)

> We can write, **omega(1)**, because when comparing **left and right**, **left** should be **bigger or equal to** right side. 

* 1 = Omega(1)
* n = Omega(1)
* (n + 1)/2 = Omega(1)

> All are satisfied. For **1**, **left side** is **bigger or equal to** right side that's why.

![image](https://user-images.githubusercontent.com/54589605/235418304-dfd344af-554a-4d21-bb85-935200df147f.png)

> **T(n)** having **three** possibilities.

> **Theta(1)** is also not possible because only **1** is happy but **n and (n+1)/2** are not happy, as they are not **equal** on both the sides.

![image](https://user-images.githubusercontent.com/54589605/235418552-dd5b309d-7ac6-4d31-a237-088888f422bc.png)
![image](https://user-images.githubusercontent.com/54589605/235418578-6c2ca10d-086c-428a-9e59-57d360b1dedd.png)

> Linear search time complexity **T(n)**, then,

* T(n) = O(n)
* T(n) = Omega(1)

![image](https://user-images.githubusercontent.com/54589605/235418705-71b0a4d7-37b3-41a6-8ff8-9029ad68858d.png)

* Assume linear search worst case time complexity is **T(n)**.

> So **T(n)** is **worst case time complexity**.

![image](https://user-images.githubusercontent.com/54589605/235418947-c2a97031-eaf6-4a4b-9f14-e38d998a05c5.png)

> So, **T(n)** is having only **one** possibility.

* **T(n)** -> O(n)
* **T(n)** -> Omega(n)
* **T(n)** -> Theta(n)

![image](https://user-images.githubusercontent.com/54589605/235419136-3d56b875-bb06-4aed-b669-da462adebc74.png)

> In the above one, they have not mentioned if **T(n)** is **best, worst or average**. They have just mentioned that **T(n)** is time complexity of linear search. That's why we had **three** options there.

> Time complexity of linear search  is **three** options or possibilities. It didn't mention **best, worst or average**.

> If not mentioned, then we have to take **all possibilities**. With respect to **all**, we have to give.

> When mentioned **worst** case, then respect to **worst** case, we have to give.

![image](https://user-images.githubusercontent.com/54589605/235419488-03314188-f84d-4f29-a7bf-31245aa681ee.png)
![image](https://user-images.githubusercontent.com/54589605/235419503-4c3d2c48-64cc-4d38-99bf-3774f2f7acf5.png)

* Assume linear search Best case time complexity is **T(n)**.

> There is only one possibility that is **O(1)**.

![image](https://user-images.githubusercontent.com/54589605/235425369-a435fe60-f038-4afe-ad7e-e8ac27615b2a.png)

* 1 -> Theta(1)

![image](https://user-images.githubusercontent.com/54589605/235425454-02bcce26-866b-4b63-bcaa-f457d59ff896.png)

* In linear search time complexity, **theta** possible?

> It depends on how we define **T(n)**. **T(n)** is simply time complexity.

> If **T(n)** is simply time complexity, then we have to consider **every case** which is **best, worst, average**.

![image](https://user-images.githubusercontent.com/54589605/235425779-4f5e6c69-8a9a-4396-8314-edb9db465b05.png)

* Best case -> Minimum time to solve the problem(correct answer).
* Worst case -> Maximum time to solve the problem(correct answer).

> If **min and max** time are **same**, then **average** time is also **same**.

> If **min and max** time are **different**, then **average** time is **in-between** of **min and max** time.

> If **min= O(1) and max= O(n)**, then average is **(n + 1)/2**, which is **in-between**.

![image](https://user-images.githubusercontent.com/54589605/235426361-91e02ece-7e42-4dc5-8382-cb7c66ef84ba.png)

> There is **no change** that **average** will go **more** than **worst** case and there is **no change** that **average** will go **less** than **best** case.

> Either **all three** will be **same/equal** or **average** is **in-between**.

* Arrange **best, average and worst** cases asymptotically?

> **Best -> Average -> Worst**. Arranged from **less to more**.

> **Best <= Average <= Worst**. 

* **Best** less than **average**
* **Average** less than **worst**.

![image](https://user-images.githubusercontent.com/54589605/235426786-35d2c031-603f-4ab1-9d05-378891874d86.png)

* In-general relation

* Remember how to find out **average case**.

> Average is based on **all person** and not on **two people or two scores**.

![image](https://user-images.githubusercontent.com/54589605/235427017-c31fe845-7631-45dc-ba50-fd0efbe0023a.png)

## Binary Search

* Input -> An **array of sorted** which has **n-elements** and an **element, 'x'**.
* Output -> Returns position of x, else return '-1'. If found then return position of 'x', else return '-1'.

> If we want **efficient** algo, then the **input** should be **efficient** as well.

> In **linear search**, the **numbers** are **random**.

![image](https://user-images.githubusercontent.com/54589605/235428388-84ace385-eb12-460c-9402-a2a4a08eb5a1.png)

> In **Binary search**, the **numbers** are in **increasing order**.

![image](https://user-images.githubusercontent.com/54589605/235428441-095feaaa-1fd6-43ba-b036-4098fbc32d33.png)
![image](https://user-images.githubusercontent.com/54589605/235428545-d5c9f73b-ba8b-440f-a01f-acd2a999f067.png)

* Binary Search

> We are doing **one side** everytime, either it is **left side** or it is **right side**. We are not going at **both** the sides at the **same time**.

> Everytime, it will be **half** of the previous one.

![image](https://user-images.githubusercontent.com/54589605/235429672-eda47c2f-f966-41ca-b65f-e670c16bb7c9.png)

> Algorithm is **deterministic** in nature.

* Best case -> O(1) [The first middle element is the element to be searched]

![image](https://user-images.githubusercontent.com/54589605/235430074-88e7b257-036f-4a80-8467-43b3c8fb2988.png)
![image](https://user-images.githubusercontent.com/54589605/235430188-c26df3f3-6eda-46a1-858e-fc2dcfdaefaf.png)
![image](https://user-images.githubusercontent.com/54589605/235430164-7ddf0364-852e-407c-9150-b8f730fdb605.png)

> As **mid(40)** is less than **10** that's why we have to go **left**.

> **1 element** is a **small** problem.

![image](https://user-images.githubusercontent.com/54589605/235430438-2a847550-2d2a-4dd6-a237-cd6378b79153.png)

> So, we **returned**, the position of 'x' as **1**. 

> If we divide the **n**, everytime by 2, then we will get **n/2**, until one element comes. It is **O(log n)**.

![image](https://user-images.githubusercontent.com/54589605/235430675-bb500cea-ab55-4428-ab15-7a270171dab6.png)

* Best case -> O(1)

![image](https://user-images.githubusercontent.com/54589605/235430732-3bbccbb1-c89e-4fd7-a1f9-513b77b36d09.png)

* Worst case -> O(log n)

![image](https://user-images.githubusercontent.com/54589605/235430942-867ddd98-e1ef-4502-84e7-71dab4c64f1c.png)

> At **7** position, it is **one element** only, so, **small problem**. One element is there, if that's 'x', which we are searching. As it is **70** and we are finding **69**, which means we diidn't find 'x'. So, return **-1**.

> **Not found** is **max** work done and **worst case**.

![image](https://user-images.githubusercontent.com/54589605/235431255-40f01206-268b-4b45-b2f8-918ae866136a.png)
![image](https://user-images.githubusercontent.com/54589605/235431359-33ee1921-1b66-4f21-bd11-1e5daec63b71.png)

* Return **-1**, **41** not possible.

![image](https://user-images.githubusercontent.com/54589605/235431404-fdde0454-426b-4c96-b2f3-c8738c524984.png)
![image](https://user-images.githubusercontent.com/54589605/235431633-0077e058-bdd7-4895-ba2a-4054bec03c97.png)

* i -> First element index
* j -> Last element index
* j - i + 1 -> Array size.

![image](https://user-images.githubusercontent.com/54589605/235432227-598e9b9c-d1c2-4134-8087-83a82a044c6c.png)

> The element we are finding(x) is on the **left** side. So, it will be from **i to mid - 1**.

![image](https://user-images.githubusercontent.com/54589605/235432421-07e6a213-2316-4e71-9974-1f0838ec7abd.png)

> The element we are finding(x) is on the **right** side. So, it will be from **mid + 1 to j**.

![image](https://user-images.githubusercontent.com/54589605/235432441-e52a1c38-aef7-4778-8e95-83466a76eded.png)
![image](https://user-images.githubusercontent.com/54589605/235432504-8069c893-e6fc-4804-9bbb-792c0ed83113.png)
![image](https://user-images.githubusercontent.com/54589605/235432530-fb9470ea-f501-48c8-afff-53513d591a99.png)

* Will come eventually. Wait.

> In the **else** part we have **two** function calls. Only one function call will execute at a time, because of in-between **else** there. 

> Only one will execute, we don't know which one, whether it is **left or right** one, no idea.

> Because **only one(1)** will execute, so the **conquor** time will be **T(n/2)**.

> In the **min-max** divide conquor algo, **two** of the functions calls were executed simultaneously to calculate the **left and right** values, that why it was **2 * T(n/2)** there and here it is only **T(n/2)**, as only **one(1)** function call is executed.

> If **n** elements is **T(n)**, then **n/2** elements is **T(n/2)**.

![image](https://user-images.githubusercontent.com/54589605/235433154-7955f406-37bd-4ab4-a4ad-4ca875c56502.png)

* **Only one** will execute.

* In **conquor**, there are **two** function calls but **only one** is executed because of the **else** in-between so it is **T(n/2)** and not **2 * T(n/2)**.

![image](https://user-images.githubusercontent.com/54589605/235433426-68877642-4234-4423-b382-3cdcff620753.png)
![image](https://user-images.githubusercontent.com/54589605/235433474-069a6c53-0c23-4b76-8c14-c6cb0fd16a6f.png)

> As soon as we enter the **else** part, first we do **constant or O(1)** time, then we take **T(n/2)** time for **conquor**.

> If we are lucky then we can stop at **constant or O(1)** time only, as there is a **return** statement there.

> Without function call also, we can **stop**, as there is a **return** statement there.

* In the **else** part of the program, we can stop in-between?

> **YES**.

> At the staring only of the **else** part, we can **stop**. That is the **best case**.

* In a recursive program, which is more valuable, if or else part?

> **Else** part.

* In a recursive program, how will give better **case**, if or else part?

> **Else** part. [**Correct answer**]

> **If** part. [**JOKE ONLY**]

> If anyone says that **If** part gives the **best** case, then the **best case** always becomes **1 or O(1)**.

> This will be a **joke** only.

* In a recursive program, how is powerful, if or else part?

> **Else** part.

> **Powerful** means **best, worst, average case** from that area. All cases from that area only.

> Everything will come from **else** only.

![image](https://user-images.githubusercontent.com/54589605/235434451-924d0226-0475-4e2c-bedb-7ae74833e274.png)
![image](https://user-images.githubusercontent.com/54589605/235434543-1816feba-4520-4411-a77e-11384a5d80c4.png)

> If **lucky**, we will get **c or constant** only. 

> If **not lucky**, we will get **c + T(n/2)**. We have to do some extra work also.

* Let, **T(n)** be the time complexity of above algo.

* Reccurence relation for **time** or time complexity for **worst case(wc)**.

![image](https://user-images.githubusercontent.com/54589605/235434745-11b577cd-774e-4614-914e-d965cad5c285.png)

* Reccurence relation for **time** or time complexity for **best case(wc)**.

![image](https://user-images.githubusercontent.com/54589605/235434818-c968b408-f113-42f6-93c1-d70f26ca2733.png)
![image](https://user-images.githubusercontent.com/54589605/235434873-348082d6-033f-4d6e-9047-10d331921f81.png)
![image](https://user-images.githubusercontent.com/54589605/235434972-0445ab7e-d9be-43a6-969e-a9cce75c25e9.png)

* Function calls mean **conquor**.

![image](https://user-images.githubusercontent.com/54589605/235435281-ca411995-7f95-429c-86ff-d7df225f96e0.png)

* **Divide and conquor** but **no combine**. No need/requirement for **combine**.

* **Binary Search** is a partial application of **divide and conquor** strategy, as there is need/requirement for **combine**.

![image](https://user-images.githubusercontent.com/54589605/235435541-c708dead-ce1d-40df-a610-cfcecfd7f269.png)

* What is the **c** here?

> **c** is the **Divide** time only, as there is no **combine*. It is for **first** level.

![image](https://user-images.githubusercontent.com/54589605/235435727-4d0d7b77-b173-4aaf-8782-28bf27b7fa6e.png)

> The above recurrence relation is for **worst case** and we will get **worst case** only. We will not get **best case**. It is for **worst case** only.

![image](https://user-images.githubusercontent.com/54589605/235435959-efd722a9-69de-4999-ad51-8090450b3b7e.png)
![image](https://user-images.githubusercontent.com/54589605/235436057-ad941954-7fa8-4668-a9a4-4a84877f2cf2.png)
![image](https://user-images.githubusercontent.com/54589605/235436072-653b2627-c175-45a8-903e-e3320ae8cac4.png)

> Left and right side are **same**, so we can write **theta**, which is **theta(log n)**.

> We can write **O(n)** as well.

> We can write **Omega(1)** as well.

> We cannot write **theta(1)** because **left and right** side are not **same**.

> We cannot write **theta(n)** because **left and right** side are not **same**.

* This is for **worst case**.

* Reccurence relation for **time** or time complexity for **best case(bc)**.

> In the starting of **else** part there is a **return** statement. So, we can **stop** it there.

* Best case -> Theta(1).
* Best case -> O(1).

![image](https://user-images.githubusercontent.com/54589605/235436439-be58a046-fefc-4d3a-907b-94e164d3244a.png)
![image](https://user-images.githubusercontent.com/54589605/235436606-3ea8f30c-f569-4bf2-90ea-bf0c9fc2bfde.png)

> Best case recurrence relation is **not possible** because we are either going **left or right** side. We are stopping at the **middle** only.

* In the **else** part, if we stop at the **starting** only then that is the **best case**.

* When someone doing **binary search**, the **left(worst case)** one will happen **more frequently** compared to **right(best case)**.  

* The worst case of **binary search** is also **average** case only.

![image](https://user-images.githubusercontent.com/54589605/235436912-5210806b-825c-4ccf-9056-102b3d8a7c6f.png)

* Most of the time, **worst case** will happen for **binary search**.
* Whichever will happen, **most of the time**, that will decide **average case**.
* Most of the time, **binary search** will behave as **worst case**.

* Why sachin's average is 60?

![image](https://user-images.githubusercontent.com/54589605/235437139-6fc1a7bc-be4a-4447-917e-cd24adf86cef.png)
![image](https://user-images.githubusercontent.com/54589605/235437162-fe17ad6e-4bf9-4de0-bab2-22f121b3c9a4.png)

* For **best case** of **binary search**, there is **no recurrence relation** because at the **entrance** only we got the **answer**.

* **T(n)** is time complexity. Every case we have to **cover**.

* log n = O(log n)
* 1 = O(log n)

> All are **satisfied**.

![image](https://user-images.githubusercontent.com/54589605/235437735-b0a7a064-8c25-47c7-aaf0-dcc8808a0605.png)

* log n = Omega(1)
* 1 = Omega(1)

> All are **satisfied**.

* log n = Theta(log n)
* 1 = Theta(log n)

> **1** is opposing because **left and right** sides are not the **same**. Hence, **theta(log n)** not possible.

* log n = Theta(1)
* 1 = Theta(1)

> **log n** is opposing because **left and right** sides are not the **same**. Hence, **theta(1)** not possible.

![image](https://user-images.githubusercontent.com/54589605/235437980-24c04e8c-6650-4f24-9d39-dd275b676dbe.png)

* In **T(n)** we have to **cover** everything. **T(n)** has **two** choices, it has to consider both **log n and 1**.

![image](https://user-images.githubusercontent.com/54589605/235438094-10e8d770-7d2a-4642-a3fa-35f4f9a992a0.png)

* what is **Binary search** time complexity?

> O(log n) OR Omega(1). Anyone is **correct**.

![image](https://user-images.githubusercontent.com/54589605/235438311-83744372-880c-4e9e-94cd-52cc6171ed06.png)

* what is **Binary search** time complexity for best case?

> They are asking only **one case**. So, it is **O(1)**. We can also use **theta(1)**, no problem.

> In **best case**, **T(n)** having **only one** choice.


* what is **Binary search** time complexity for worst case?

> They are asking only **one case**. So, it is **O(log n)**. We can also use **theta(log n)**, no problem.

> In **worst case**, **T(n)** having **only one** choice.

* In **one** case, we don't have **any problem**, because **only one** answer.

![image](https://user-images.githubusercontent.com/54589605/235438574-364ca8ad-0384-40be-9f46-0e6c6329e17c.png)

* When asking for **binary search** time complexity?

> Take all of the **cases**. Give **O(log n) or Omega(1)** as the **answer**.

* In **binary search**, we will go **one side**.

![image](https://user-images.githubusercontent.com/54589605/235438716-cc4253d6-1740-444f-8611-79645b4aa055.png)

* Sometimes, we don't go **one side** also, it is the **Best case**.

![image](https://user-images.githubusercontent.com/54589605/235438799-23a1da7f-f4a5-4f94-93b8-86725540cede.png)

* If we are **lucky**, then we don't have to go **any sides**.
* If we are **not lucky**, then we have to go in **one of the sides**.

* In specific case, we can use **theta**. We have **only one answer**.

![image](https://user-images.githubusercontent.com/54589605/235438970-7f1f5b81-1ece-4f77-a3bf-7522b997d7ce.png)

* Time complexity of **binary search**.

*  Best case -> O(1)
*  Average case -> O(log n) [Most of the time, **worst case** will happen]
*  Worst case -> O(log n)

* Why the time complexity of **binary search** in **average case** is **O(log n)**?

> Average means we have to **consider all**. When considering all, most of the time, it is behaving like **worst case**.

> So, **average and worst** case is **same**.

> **Best case** is **very rare** incident, happening very less amount of time.

![image](https://user-images.githubusercontent.com/54589605/235439276-45d2f61a-656a-4cbb-8b9f-3deb424a3223.png)
![image](https://user-images.githubusercontent.com/54589605/235439535-7c4e8c43-602f-4961-8cd3-e8424ef5ca71.png)

* Stack space is **log n**, which is **average and worst case**.
* If we are lucky, then **once divide** then **stop**, which is **best case**.

![image](https://user-images.githubusercontent.com/54589605/235439722-bf443e7e-79ad-4794-913f-061b49e56e7c.png)

* Recursive program performance is based on  -> **Else** part.
* If we want **best case** -> **Else** part.
* Everything thing or every case -> **Else** part.
* Binary search time complexity(In general) -> O(log n) OR Omega(1).

![image](https://user-images.githubusercontent.com/54589605/235440167-f4e44894-2849-405a-a586-14cda8b9ecd9.png)
![image](https://user-images.githubusercontent.com/54589605/235440205-aab3f28a-9774-4e68-90ea-6e4bd6410336.png)

* Binary search time complexity best case -> O(1) OR theta(1) -> 1
* Binary search time complexity worst case -> O(log n) OR theta(log n) -> log n
* Binary search time complexity average case -> O(log n) OR theta(log n) -> log n

> For **one case**, we can give **any symbol** as there is **only one** answer. So better don't give **any symbols**.

* Binary search time complexity(In general) -> O(log n) OR Omega(1).

![image](https://user-images.githubusercontent.com/54589605/235440604-5ea28d0f-7079-438b-8351-f592e2e526a0.png)

* Not needed [**EXTRA**]

![image](https://user-images.githubusercontent.com/54589605/235440697-4664b646-5094-49ea-8cb6-d95579b3da93.png)
![image](https://user-images.githubusercontent.com/54589605/235440714-f901763c-9336-4a91-b5c9-6f2da1a845c6.png)
![image](https://user-images.githubusercontent.com/54589605/235440974-5c938bf1-aacc-403a-8eb3-aa2fd3a52afa.png)
![image](https://user-images.githubusercontent.com/54589605/235441087-29adb420-175c-465b-ae03-8d811d2925c0.png)
![image](https://user-images.githubusercontent.com/54589605/235441124-95ce8765-9b2a-4a23-b751-0a6168afc193.png)

* Non-recursive program. Only **i and j** are updated.
* Because of non-recursive program, the **Stack space** is **1**, because of **1 function call**.
* Time complexity is **same**.
* Other than **recursion**, both the codes are **same**.
* In place of **recursion**, the above program used **while** loop.
* Everything **same**, except **space**.

![image](https://user-images.githubusercontent.com/54589605/235441399-235e33c7-229b-4d37-bf2e-fd0a10d12874.png)

* Binary search time complexity best case -> O(1) OR theta(1) -> 1
* Binary search time complexity worst case -> O(log n) OR theta(log n) -> log n
* Binary search time complexity average case -> O(log n) OR theta(log n) -> log n
* Binary search time complexity(In general) -> O(log n) OR Omega(1).

![image](https://user-images.githubusercontent.com/54589605/235441543-16d1d628-30f5-4b16-a97d-aac46caf1859.png)

> Because of **non-recursion**, **space** is **saved**.

* Space complexity -> **Theta(1)** or constant.

* If above program(non-recursion) given, how much **space complexity** needed?

> **1**.

![image](https://user-images.githubusercontent.com/54589605/235441646-f0c87257-0b54-425f-975c-9916818666ce.png)

* If above program(recursion) given, how much **space complexity** needed?

> **log n**.

* Depending on how we write the program, **space complexity** will **change**.
* Recursion means **more space**.

* If **space complexity** asked then **program** will be given. Without program, how we will calculate **space complexity**.

* **Time complexity** is **same** as **logic** is **same** for **recursive** as well as **non-recursive** program.
* Depending on **how we write the program**, **space complexity** will **change**.

![image](https://user-images.githubusercontent.com/54589605/235442352-6cedcefa-bce6-47f5-ad40-37d3ac1878bc.png)

## DP-V (25) [1st May 2023]

* Binary search is **partial** divide and conquor strategy, because there is **no combine()**.

## Application of Binary Search

![image](https://user-images.githubusercontent.com/54589605/235458815-ccc456f8-a50b-454d-b322-b323cacdebbf.png)
![image](https://user-images.githubusercontent.com/54589605/235459243-38929151-ef77-42d8-b96a-9d0e2b4be7f6.png)

* Sorted and no-repetation allowed.

> If we want to give **best algo**, then first we have to give **some algo**.

> Any problem is given, first we can try **linear search**.

> Linear searching is working. The problem has asked for **worst case**.

> Linear search is possible with time complexity of **O(n)**, which is the **worst case**.

> When mentioning specific case(worst case here), then **one** possibility. So, we can use **theta(n)** because left and right side are **same**.

![image](https://user-images.githubusercontent.com/54589605/235463280-520cd040-adb9-4545-ae3c-bc2bca1c513e.png)

* Linear Search -> Worst case -> **O(n)** -> n.

> If asked for **worst case** in the problem, find **worst case**.

> If nothing mentioned in the problem, then we will have to find **everything or every case**. If nothing mentioned, then find **every case**.

> If asked for **best case** in the problem, then there is a twist in the problem. **Best case** is not asked normally in problems/questions.

![image](https://user-images.githubusercontent.com/54589605/235465983-1090f20e-2386-427d-81ab-27cbfd849f1f.png)

> In **binary search**, the **middle** is the **mid element**. The middle element is **9** so **i=9**, then **a[9] == 9 -> 6 == 9**, **NO**. Now, we are at a **dilemma**, which side to go? If we go to the left then we are at **8th position** and at **i=8** will have **less than 6** element as **i=9** had **6** and it is an **increasing sorted** array. But we wanted **8** at **i=8** which is **not possible**, so we cannot go **left**.

> In **i=9** we had **6**, so at **i=10**, we will have **greater/more than 6**, which could be **10** that's what we are looking for which is **a[i] == i**. So it is **possible, that's why we went **right**.

![image](https://user-images.githubusercontent.com/54589605/235468922-2a5cf513-cfc2-4fb2-b226-c06acf7d7905.png)

> The middle is **10 + 17/2 -> 27/2 -> 13**. So **i=13** and it has **70**. We want **a[13] == 13 -> 70 == 13**, **NO**.  If we go to the **right** then **i=14** and the value will be **more than 70**, which is not possible, so we cannot go **right**. If we go to the **left** then **i=12** and the value is **less than 70**, which is possible, so we got **left**.

![image](https://user-images.githubusercontent.com/54589605/235469714-1775365a-d82f-4e66-87f3-ebddf63c6179.png)

> The middle is **10 + 12/2 -> 22/2 -> 11**. So in **i=11**, the value is **15** and it is not **a[i] == i**. If we go to the **right**, then **i=12** and value is **more than 15**, then it is not possible. If we go to the **left**, then **i=10** and the value is **less than 15**, possible, so we have to go **left**.

![image](https://user-images.githubusercontent.com/54589605/235470371-9fb9ddb8-aabe-4810-ad35-d22ccf3d234a.png)

> The middle is **10 + 10/2 -> 20/2 -> 10**, we have only **one** element which is **10** only so, it is a **small** problem. So for **i=10**, the value is **10** and it satisfies the condition which is **a[i] == i -> a[10] == 10 -> 10 == 10**, **YES**. The condition is **satisfied**. So, we will **return** the **index** which is **10**, **return index -> return 10**.

* Worst case -> log n
* Best Case -> 1

![image](https://user-images.githubusercontent.com/54589605/235471189-b780eb15-959f-4371-ae07-0b1f3b161d04.png)

* If we can decide, which side, we want to go, **left or right*** then **binary search** is possible.

> If **9th person's** value is **6**, then **10th person's** value is **more than 6** as it is an **increasing sorted** array. So, there is **hope**. For **8th person's** value is **less than 6**, so, **no hope**.

![image](https://user-images.githubusercontent.com/54589605/235472005-399de7f7-78ce-4cbb-a586-a771eea43aed.png)

* Using the above logic we can decide, which side, we want to go, **left or right** then **binary search** is possible.

* If we are at the **middle** and we can't decide which side to go, then **binary search** is **not possible**.

* If we are at the **middle** and are able to decide which side to go, then **binary search** is  **possible**.

> If **9th person's** value is **6**, then **10th person's** value can be **anything**, if the array is **not sorted**. For **8th person's**  value also, it can be **anything**, as the array is **not sorted**. 

> We cannot say clearly that if the element is present on the **left or right** side. Then, we have to **verify**, both the sides, this is called as **dilemma**.

* If array is **not sorted**, then **binary search** is not possible.
* If the array is **not sorted**, then we can't take decision to go either **left or right** side, when we are at the **middle**, it is called  as **dilemma**. Both the side people are saying **maybe**. So, we cannot go blindly to either one of the sides. Both the side,**maybe**, so **binary search** is not possible.

* How to decide, if binary search is possible or not?

> Go to the **middle**, if we can go to the **left** only or to the **right** only, then **binary search** is possible, otherwise, if go either **left or right**, it is **dilemma** and **binary search** is not possible.

> When we are in the **middle** and unable to decide which side to go, either **left or right**, dilemma happens, that's why **binary search** is not possible.

> If we try both the sides, then it is called as **linear search**. **Linear search** means covering everyone.

> **Binary search** means **covering only one side**.

![image](https://user-images.githubusercontent.com/54589605/235477934-61c6234b-c281-497d-9232-296c278695e6.png)
![image](https://user-images.githubusercontent.com/54589605/235478189-9d6c3c10-c270-48e5-8f8d-5dc6689c633f.png)
![image](https://user-images.githubusercontent.com/54589605/235478499-28e9c8fb-ff25-4cd1-8574-7034c0627d4f.png)
![image](https://user-images.githubusercontent.com/54589605/235478803-1e5d78ae-1861-4f79-97bb-726c4de169b8.png)

> If we should be able to resolve otherwise we will not be able to proceed further.

* In the above problem, if **sorted** keyword is not there, then only **linear search** is **possible**, **binary search** is **not possible**.

* In the above program, if **sorted** keyword is not there, then time complexity is **n** because only **linear search** is **possible**.

![image](https://user-images.githubusercontent.com/54589605/235479676-3b34bb92-499d-48c7-b1f7-4c43003f5ff4.png)

* In the above problem, if **distinct** keyword is not there, but **sorted** keyword is there then?

> So, if **sorted** is there but **distinct** is not there, then **binary search** is not possible. [**Answer, explained below**]

> If **10th person** is **13**, then **11th person** is **greater than equal to 13**. **12th person** is **greater than equal to 13**. **13th person** is **greater than equal to 13**, there is a change that **13th person** is **13**.

> If **10th person** is **13**, then **repetation** is possible on the **right** side.

![image](https://user-images.githubusercontent.com/54589605/235480051-66b39c69-1bad-41a1-8b58-f4e51a78b35d.png)

> If **10th person** is **13**, then **10th person** is **less than equal to 13**. Then, **left** is also possible.

* If **distinct** is not there, then both the **sides** are possible.
* So, if **sorted** is there but **distinct** is not there, then **binary search** is not possible.

![image](https://user-images.githubusercontent.com/54589605/235480483-a721337d-4f82-46a6-876f-d809e21f9ca6.png)

* If array is **sorted**, then **binary search** is guranteed possible?

> **NO**. See the above example only. **Sorted** array but **non-distinct**, binary search was not possible.

* If array is **sorted**, then **binary search** is **maybe**. No gurantee.

* If array is **not sorted**, then there is **no change** of **binary search** is there. Confirmed, no way.

![image](https://user-images.githubusercontent.com/54589605/235481448-149da0f4-9cd7-44fd-ba8d-1d3bed8f6ab2.png)
![image](https://user-images.githubusercontent.com/54589605/235482179-44a25af0-1f6b-4708-ac69-a1905f9e0571.png)
![image](https://user-images.githubusercontent.com/54589605/235482290-3896850c-63a0-4295-a77a-9a0e76a918d6.png)

* For the above program.
* Not sorted, then **binary search** is **not possible**. 
* Sorted but distinct is not there, then also **binary search** is **not possible**

## DAC-V (26) [1st May 2023]

![image](https://user-images.githubusercontent.com/54589605/235490799-cdfa5077-10f8-4c15-877c-bbb7ae424059.png)
![image](https://user-images.githubusercontent.com/54589605/235491405-fea5df5a-37d0-47a6-9b70-dffdd6316ec0.png)

* **n^(log a base b)** is **bigger**. It is **bigger** by **log n/ root(n) -> log n/n^(1/2)**. Because there is **roo(n) or n^(1/2)** also, that's why it is **bigger** by **polynomial** times, as we are **dividing** by **polynomial** times.

> As, **polynomial** time **bigger**, so **case 1 and 2** of master's theore, which means whoever is **bigger** is the **answer**. So **O(root(n)) -> O(n^(1/2))** is the **answer**.

* If only **log n** was there then we would have to go to **case 2** of master's theorem. 

![image](https://user-images.githubusercontent.com/54589605/235491973-26d362e1-a65d-4f54-8e77-d0eaa8fd5753.png)
![image](https://user-images.githubusercontent.com/54589605/235492021-4c239588-b9ab-4762-a56e-65da2ca8e475.png)
![image](https://user-images.githubusercontent.com/54589605/235492337-a78c1cfc-1a25-46bd-987e-b3d84b6faaf4.png)

* Both the **side**, it can be possible. So, **binary search** is not possible.

![image](https://user-images.githubusercontent.com/54589605/235492963-89d0ff7d-5523-429d-8085-2ff0092c64fb.png)

* Input -> An array of 'n' elements in which, until some position all are integers and afterwards all are infinite.

* Array is not sorted. No mention of positive numbers.

![image](https://user-images.githubusercontent.com/54589605/235494294-77f5b16d-aefa-4941-b0f8-69cd4ec2bc43.png)

* Until which position, integers are there?

> Still **16th** index. 

* What will be the **output**?

![image](https://user-images.githubusercontent.com/54589605/235494790-0ab4f385-d72d-4b11-a474-fdb668109590.png)

1) First try linear search
2) See the best and worst case of linear search
3) Applications/improvement of linear search. Try to improve it. Binary search possible or not.

![image](https://user-images.githubusercontent.com/54589605/235565953-561e8a3c-e7e1-4115-96e0-d47cdeda79c6.png)
![image](https://user-images.githubusercontent.com/54589605/235565972-34ddd544-65f1-4db8-8b00-1d1418eefe17.png)
![image](https://user-images.githubusercontent.com/54589605/235566080-5d3cb86a-9aeb-4a64-b85b-7298715f72bc.png)

1) First algo is linear search.
2) Worst case is **n** and best case is **1**, for linear search. Worst case is mentioned so we will consider **n** only. If nothing mentioned then consider/find out all and we will use **O(n) or Omega(1)** in that case, as all cases agree to **O(n) or Omega(1)**.

![image](https://user-images.githubusercontent.com/54589605/235566682-1eb61338-82e3-45c6-963f-4df5b4f9a38a.png)

> As mentioned in the question, **worst case**, so we only have **n** and we can say **any symbol(O,omega, theta)**.

![image](https://user-images.githubusercontent.com/54589605/235566999-f9a661e7-8533-4959-a877-7931f45cb73e.png)
![image](https://user-images.githubusercontent.com/54589605/235567066-b244f1e7-458a-4a0e-8862-7b7b7e7f7d94.png)

> See the options for the **question**, if **n** is there and **less than n**, no one or not there. Then **n** is the **answer** and we can stop.

> If **less than n** there in the **options**, then we can to **continue**. If **log n** there, then **signal came**, **binary search** possible. Could be a trap a well.

![image](https://user-images.githubusercontent.com/54589605/235569536-a323ae42-ffcc-4493-9c06-1ae2ba51ea7c.png)

3) Try binary search. Array is not sorted. Go to the middle element, which is **1+30/2 -> 31/2-> 15**. Ask if **15** is **integer or infinite**. **15** is **integer**, but we want **infinite**, we should go to **right**, as mentioned in the question that **after some integer, all are **infinite**. There is no **dilemma**.

![image](https://user-images.githubusercontent.com/54589605/235570524-05caa5d9-6141-4439-871c-73e6749fe39c.png)

> Again go to the **middle**. The middle is **16+30/2 -> 23**. **23** is **infinite**, now ask if **before** is **infinite** or not. We will get to know if it is the **first, middle or last infinite**. We got to know that it is the **middle** infinite as there are **infinites** to the **left** as well. We want the **first infinite**, so we **go left**, to find the **first infinite**.

![image](https://user-images.githubusercontent.com/54589605/235571247-75a53016-9dfa-436c-bb76-95f9f8213592.png)

> Again go to the **middle**. The middle is **16+22/2 -> 19**. **19** is **infinite**, now ask if **before** is **infinite** or not. We will get to know if it is the **first, middle or last infinite**. We got to know that it is the **middle** infinite as there are **infinites** to the **left** as well. We want the **first infinite**, so we **go left**, to find the **first infinite**.

> Again go to the **middle**. The middle is **17** only, as there is only one element, which is a **small problem**. **17** is **infinite**, now ask if **before** is **infinite** or not. We will get to know if it is the **first, middle or last infinite**. We got to know that it is the **first** infinite as there are no **infinites** to the **left**. We got the **first infinite**. So, stop and **return** the **position** of the **first infinite**.

![image](https://user-images.githubusercontent.com/54589605/235571706-14c7ffe1-483a-479e-b8e3-b0e9bba4686e.png)

> Whenever **infinite** came, we will check if it is the **middle** person or not, by checking if there are **any infinites** to the **left**. If there are **infinites** to the **left**, then it is the **middle** infinite and we have to go **left**.

> If the **middle** is **infinite**, and the **left** is **not infinite**, then stop it. We found the  **first infinite**.

> If the **middle** is **integer**, then go to the **right**.

![image](https://user-images.githubusercontent.com/54589605/235572148-db01b9d8-b529-47d0-b2a2-3e1062a80228.png)

> Worst is maximum we **divide by 2** and get the **last element**.

![image](https://user-images.githubusercontent.com/54589605/235569922-e7d0953a-f2a2-42b7-ac7c-77f9f63bb5e8.png)

* Array is **sorted**, **according to the requirements** of the question/problem. Physically not sorted but logically sorted.
* Don't judge, **sorted or not** from outside.
* Array **not sorted**, we will not apply **binary search** -> **JUST SHUT UP**. It is logically sorted, **according to the requirements** of the question/problem.
* We have to go **inside** and verify if the array is **sorted or not**. Don't judge from **outside**.

* Worst case for bianry search -> log n
* Best case for bianry search -> 1

![image](https://user-images.githubusercontent.com/54589605/235572966-31593503-a0e1-4aea-bfa3-ebc6723acef4.png)

* Best case example.
* We are not interested in **Best case**, as worst case is asked in the question.

![image](https://user-images.githubusercontent.com/54589605/235573110-511469f9-c1a2-434a-8245-275dfde386a2.png)

* Both, **theta(log n) and theta(n)** both are given in the options. Then we should select **theta(log n)** as it is the **best algorithm** and the **worst case time complexity** as **asked/mentioned** in the question.

* We can use **theta** because only **worst case** asked so **one case** and **one choice** only. 
* From **outside** it looked like **binary search** is not possible. Go inside and verify.
* Array sorted according to problem.

![image](https://user-images.githubusercontent.com/54589605/235573600-a3a73c19-c9db-42cf-bd0d-757f4972448b.png)
![image](https://user-images.githubusercontent.com/54589605/235573623-ad60401d-4fd9-4068-a1bc-68cf9ee022ef.png)
![image](https://user-images.githubusercontent.com/54589605/235573656-3b05c1d0-eb72-4e14-ba0a-3d6a307a58b7.png)
![image](https://user-images.githubusercontent.com/54589605/235573684-993312e3-178a-4829-9097-48d12964e3a6.png)

* We want the **last integer**.

> Middle element is **12**, ask if it is **integer**. It is **integer**. We asked, **right** if it is **integer** or not, it is **integer**. So, we go to the **right**.

> Middle element is **22**, ask if it is **integer**. It is **infinite**. So, we go **left**.

> Middle element is **17**, ask if it is **integer**. It is **infinite**. So, we go **left**.

> Middle element is **15**, ask if it is **integer**. It is **infinite**. So, we go **left**.

> Middle element is **13**, ask if it is **integer**. It is **integer**. We asked, **right** if it is an **integer** or not, it is **integer**. So, we go to the **right**.

> Middle element is **14**, it is the **only one element**, so it is a **small problem**. Ask if it is an **integer**. It is an **integer**. We asked, **right** if it is an **integer** or not, it is **infinite**. So, we found the **last integer**. Now stop, and return the **position** of the **last integer**.

![image](https://user-images.githubusercontent.com/54589605/235574145-a9de34d4-2080-46ce-95b6-0b99e86491bf.png)
![image](https://user-images.githubusercontent.com/54589605/235574289-bbf9ce06-4d59-4c41-9de2-84b91f29ca27.png)
![image](https://user-images.githubusercontent.com/54589605/235574796-869d1555-32cf-4538-ae34-78cef9012f7f.png)

* **n** becomes **log n** is great achievement. This is the meaning of **making apps faster**.

![image](https://user-images.githubusercontent.com/54589605/235574865-d2beee24-f16c-4398-b44b-f141bacdb9f9.png)
![image](https://user-images.githubusercontent.com/54589605/235575007-40b3853e-526b-4cc7-bde8-4c482b9b064f.png)

* If we write **n distinct elements**, then how we will write that many **infinites**.

![image](https://user-images.githubusercontent.com/54589605/235576074-bfc40379-1fda-46f0-ab8f-d90d48b36c00.png)

* Assume 'n' is unknown and after array, all the symbols in memory are '#'.

* If **size** is **unknown**, how we will know that **array** is over.

![image](https://user-images.githubusercontent.com/54589605/235576177-09849ad4-9ab7-4634-a13e-27e99b7df573.png)

* Array having size but we don't know the **size**. We cannot tell when the array is over.
* We cannot use **n**. Be careful.
* Linear search is possible because we will take a **loop** and **search** until we find an **#**, then we stop.

![image](https://user-images.githubusercontent.com/54589605/235576489-658f58eb-e957-4ccd-b437-f18493bf0bb1.png)

> When we see the **first #**, it indicates that the array is over. Stop it and say not there. If we are lucky then we will find the **first infinite** in the array.

> We haven't used **n** anywhere.

![image](https://user-images.githubusercontent.com/54589605/235576686-e5224527-f96b-4ab1-a086-4ec55622e227.png)
![image](https://user-images.githubusercontent.com/54589605/235576779-d0bbe87e-63c8-44b2-8104-003d6cab6b58.png)
![image](https://user-images.githubusercontent.com/54589605/235577263-4d63ca6a-b539-46a3-a980-105fd975561b.png)

* We haven't used **n** anywhere in the code.
* Worst case -> n.

![image](https://user-images.githubusercontent.com/54589605/235577381-9c77b9a3-77fe-427c-be2f-a52a625f2294.png)

* Binary search is not possible because we can't go to the **middle** element or find the **middle** element because we don't know the value of **n**, it is **unknown** or not given in the question.

* As **binary search** is not possible, so, **linear search** is the **best algo**.

![image](https://user-images.githubusercontent.com/54589605/235577644-66a7c918-03d7-4ece-994c-88ce8dc968c5.png)
![image](https://user-images.githubusercontent.com/54589605/235578150-4be90167-e7d6-41d6-be3b-05437711bd0d.png)

* Binary Search.

* We are doing **i * 2**. We are jumping by **double**.

![image](https://user-images.githubusercontent.com/54589605/235578381-98737b4e-3dc1-4eef-8a09-044e8181f8d2.png)

* If we know **n** value then do **divide by 2**.
* If we don't know **n** value then do **multiply by 2**. [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/235578531-7a137400-d16d-40c6-9e4e-93fc920eb274.png)

* We still want to find the **first infinite**.

> We are starting from **first**. We are asking if the first element is **infinite** or not. It is an **integer**, so, we will go to the **right**. We are **multiplying**, **i * 2**, every time we more to the **right**. Now, after **3-4** jumps, we have reached/entered to the **infinites**. Now, in the given area from **start or 1st index** to the currenct index which is **16**. So the **first index** is **1** and the **last index** which is **n** is **16**. So, now we can  do **binary search** in that area as **n** value is **known** now and also the **answer** is there in that area only.

* **Binary Search** steps:

1) We took **log n** time to find the **infinite** at the **16th** index, as we did **double** by **multiplying**, **i * 2**.
2) **One binary search** for finding **n** value is **log n**.

* We took **log n** time to find the **n** value.

3) Now do normal, binary search to find the **first infinite**. 

> Middle element is **8**. It is an **integer**, go to the right.

> Middle element is **9 + 16/2 -> 12**. It is an **integer**, go to the right.

> Middle element is **13 + 16/2 -> 14**. It is an **integer**, go to the right.

> Middle element is **15 + 16/2 -> 15**. It is **infinite**. Check **before**, it is **not infinite**, then this is the **first infinite**. Now, stop and return the **position** of the **first infinite**.

![image](https://user-images.githubusercontent.com/54589605/235581015-b64dc29a-6f24-4b32-93bd-3d8afe832d18.png)

* First find **n** value, for that apply **binary search**.
* So **log n + log n -> 2 * log n -> log n**.
* Binary search **possible**.

![image](https://user-images.githubusercontent.com/54589605/235581221-89ae1e7f-5d57-463f-badf-07dfd5817ff5.png)

* Binary search means **divide by 2** as well as **multiply by 2**, both meaning are **same** they are coming from **two** different directions/angles. [**IMPORTANT**]

* So, binary search is possible in the **above problem**.

![image](https://user-images.githubusercontent.com/54589605/235579802-3471c931-86ac-4f9b-86e8-dfc2552b8fd9.png)

* Previous problem and the above(current) problem is the **n**value. It was known in the **previous problem** but it is unknown in the **above(current) problem**.

* Algo means **logics**. Learn logics.

![image](https://user-images.githubusercontent.com/54589605/235581307-25f6650f-91bc-414b-9943-8cf30d6e1ab0.png)
![image](https://user-images.githubusercontent.com/54589605/235578703-819a8e6d-b532-4d4e-aa22-036abadfa317.png)

* Practice like **sir**.









































 


# Practice Videos (27th April 2023)

* Video 1 -> https://unacademy.com/class/algo-practice-class/7THGBZDH

![image](https://user-images.githubusercontent.com/54589605/234853417-e669a0b7-d9be-44b4-a5e0-2a36673a53c2.png)
![image](https://user-images.githubusercontent.com/54589605/234853698-bd0014ff-46e9-40e7-bbdf-1de7ad565114.png)
![image](https://user-images.githubusercontent.com/54589605/234854938-ea1c37a3-d859-45ec-b208-6575eee2136f.png)
![image](https://user-images.githubusercontent.com/54589605/234854964-1a82df9d-4697-4455-bb9d-68e7f142b7ff.png)
![image](https://user-images.githubusercontent.com/54589605/234855044-7c56e6c0-4692-41b2-ae0e-f408def16721.png)
![image](https://user-images.githubusercontent.com/54589605/234856190-b20b8022-592c-44ca-84fe-019376de2c0c.png)
![image](https://user-images.githubusercontent.com/54589605/234856332-14f82fc0-4d7b-431e-8f5e-46fc25dc9317.png)
![image](https://user-images.githubusercontent.com/54589605/234856402-77f82ea8-4179-44c3-8b8c-296edb426c07.png)

* Asymptotically equal. All are **correct**.

![image](https://user-images.githubusercontent.com/54589605/234856643-82c3285d-1d30-460f-adf7-f927a272114e.png)
![image](https://user-images.githubusercontent.com/54589605/234856712-eeefa6bd-8952-47e3-8589-216a2e9aeeee.png)

![image](https://user-images.githubusercontent.com/54589605/234860633-1546e7d0-1d29-41ff-bb4b-25bfc1a05811.png)
![image](https://user-images.githubusercontent.com/54589605/234860419-6e3e1f7c-b1ab-45ba-8aa6-de716c04770c.png)
![image](https://user-images.githubusercontent.com/54589605/234860461-aaf98de4-3d7e-4fa5-8180-52240dcb25b1.png)

* Condition is on **i** only.

![image](https://user-images.githubusercontent.com/54589605/234860977-3ec1c234-bb7a-4060-986e-40b5baac02e1.png)
![image](https://user-images.githubusercontent.com/54589605/234861169-d8ac0f48-80a7-433a-9344-96c1c837c2e4.png)

## GP series formula [**IMPORTANT**]

![image](https://user-images.githubusercontent.com/54589605/234861705-2e2b5a1b-3c0a-4d70-b9d5-84c555bd5748.png)
![image](https://user-images.githubusercontent.com/54589605/234861859-aa184a8e-fca2-47e6-9afe-12c77c3e99a7.png)

![image](https://user-images.githubusercontent.com/54589605/234862871-743256f9-17ca-45ee-9e6d-26da870e800b.png)

> For **larger n** values, which is **1/(2^(log n))**, the **(2^(log n)** value becomes **infinite**, so, **1/(2^(log n))** becomes **zero(0)** as **1/(infinite)** is **zero(0)**.

![image](https://user-images.githubusercontent.com/54589605/234863186-efd5b290-4479-4a50-9207-b303d282b293.png)
![image](https://user-images.githubusercontent.com/54589605/234863408-ac97ee62-2b3d-414e-b0fc-2aeb78113bd2.png)
![image](https://user-images.githubusercontent.com/54589605/234863640-5cfc9432-c689-451a-aa9d-da12f285ffa7.png)

> There is **no negatives** in the  above **given series**. If we finally got **negative**, then we have **done something** wrong while solving the series.

> If we use the **wrong formulae**, then we will get **negative** as an answer for the series.

* Time Complexity is **O(log n)**

> Since only **i** was there in the **condition**.

* **j** value is **n**.

![image](https://user-images.githubusercontent.com/54589605/234864089-e3a92b6b-1f36-4573-a554-333420c6882a.png)
![image](https://user-images.githubusercontent.com/54589605/234865925-f6faa930-f803-4325-9278-b0e0f2f9f561.png)
![image](https://user-images.githubusercontent.com/54589605/234870341-b33d9ff1-182d-4029-aeba-a624af30f9e2.png)


## Revision

1) Asymptotic Notation and complexities -> Book and practice questions [21st April 2023]



# Practice Questions

* Link -> https://unacademy.com/course/complete-course-on-algorithms-gate/K8EKOMCE

> Every video has **5** practice questions. Do them **regularly**.

* Video 1 -> None given
* Video 2 -> Done [19th April 2023]
* Video 3 -> Done [19th April 2023]

# Doubts

## 1

![1](https://user-images.githubusercontent.com/54589605/233017636-36e65fe8-d0c0-4ef0-948e-d8f9645f247b.png)


## 2

> We are using **log N base 2**, and **base 2**, because we are representing the no. in **binary** form or in **bits** form as asked in the question, they are the **same** thing.

> For representing **15**, in **bits or binary** form, we have to do **log N base 2 -> log 15 base 2**, where **N=15**.

* Link -> https://unacademy.com/goal/gate-cs-it/NVLIA/doubts-and-solutions/doubt/4E9F25BC81

![2](https://user-images.githubusercontent.com/54589605/233017799-52346147-d5a1-432c-bfaa-8ddfbd134477.png)
![image](https://user-images.githubusercontent.com/54589605/233018553-b142659f-ee7c-45b2-b0bd-8b007928fc56.png)

## 3

![3](https://user-images.githubusercontent.com/54589605/233019898-38cf80a1-b44e-48e8-a794-312ff2a60fcc.png)

* Link -> https://unacademy.com/goal/gate-cs-it/NVLIA/doubts-and-solutions/doubt/E6B3684ACC

> First remove the **common things** then do **log**.

![image](https://user-images.githubusercontent.com/54589605/233023669-91b3d808-5d12-4f28-b7e8-6331db6c93c1.png)


## 4

* a^(log b base a) = b [**IMPORTANT FORMULAE**]

![image](https://user-images.githubusercontent.com/54589605/233021203-b25194ef-9fa5-435f-846b-935fc93733b8.png)

* Link -> https://unacademy.com/goal/gate-cs-it/NVLIA/doubts-and-solutions/doubt/3F80718DC8
* Solution -> https://unacademy.com/goal/gate-cs-it/NVLIA/practice/PQQFK?topic_type=2&topic_group=PQQFK&type=4&quiz_uid=NXB8YCHZX9&educator_name=Subbarao+Lingamgunta&source=Course

![image](https://user-images.githubusercontent.com/54589605/233022141-167e45cd-7b2e-471e-aef3-5ed97a89ad96.png)
![image](https://user-images.githubusercontent.com/54589605/233022187-04dbc2c1-67b2-48a6-92cb-7483728d2784.png)

* **Solved**. Solutions available. 

## 5

![image](https://user-images.githubusercontent.com/54589605/233143309-53f64a98-8648-4d74-ada3-5f47fee34cff.png)
![image](https://user-images.githubusercontent.com/54589605/233143371-142812a5-a42e-40d2-bcb4-6df6e8e076b0.png)

* Link -> https://unacademy.com/goal/gate-cs-it/NVLIA/doubts-and-solutions/doubt/B09B352AC7

* Different question solution below

![image](https://user-images.githubusercontent.com/54589605/233364266-c051146e-4cca-47f1-9875-c52c691b9e59.png)
![image](https://user-images.githubusercontent.com/54589605/233364606-b78cf1a4-5d6e-495c-a84a-73533fee75d3.png)

* **Solved**. Solutions available.

## 6

![image](https://user-images.githubusercontent.com/54589605/233268478-2bd7e8f7-3837-4c1f-a1ae-6faf33493519.png)
![image](https://user-images.githubusercontent.com/54589605/233268940-1c71cf55-13ca-4ede-9534-0e147445a75f.png)

> **n** increases, value increases, **increasing function**.

> **n** increases, value decreases, **decreasing function**.

> Option **B** is **True** for **increasing function**. **False** for **decreasing function**.

![image](https://user-images.githubusercontent.com/54589605/233268817-7507759a-bb8e-4fdc-88e1-aaf3635dfda4.png)

> Time complexity is not mentioned in the question. Asymptotic notation does not bother about **constants**.

![image](https://user-images.githubusercontent.com/54589605/233269230-67da1031-a388-4765-9c69-d5891cde532c.png)
![image](https://user-images.githubusercontent.com/54589605/233269385-465bd05a-8122-443f-868f-1c9eb7726af3.png)

* YES.

> **Big-O, omega and theta** are applicable for **anything**.

















