# COA


## COA Prerequisite

![image](https://user-images.githubusercontent.com/54589605/219703126-5838cf62-bbc5-41c3-aa64-5ecb4f5a3b23.png)
![image](https://user-images.githubusercontent.com/54589605/222415066-82eff0ab-07ad-417c-95de-2877f4003c13.png)


### Material

* Video 1 -> https://www.youtube.com/watch?v=syKlvr5a8yQ&t=72s [Completed]
* Video 2 -> https://www.youtube.com/watch?v=n7vehBgKZZo&t=3255s [Completed]

### Marks

![image](https://user-images.githubusercontent.com/54589605/223104039-dc940cd3-9917-458e-9a16-c974dfe9ad6a.png)


## Number System

* 10 -> Not a digit, it is a number, combination of digits
* 1 -> Digit

![image](https://user-images.githubusercontent.com/54589605/219703555-21d53b48-5b6d-45ec-8550-21a09d5a767f.png)
![image](https://user-images.githubusercontent.com/54589605/219704580-26a40f0d-0b3f-4c3e-991e-104e499d3668.png)
![image](https://user-images.githubusercontent.com/54589605/219704894-c30274df-9d7f-4a62-ac08-1ae471d1192c.png)
![image](https://user-images.githubusercontent.com/54589605/219707187-94a5b408-4f2a-4863-957c-4f6689f606ae.png)
![image](https://user-images.githubusercontent.com/54589605/219707482-c9f8735f-0ae2-4a1e-abce-eb3a63127326.png)
![image](https://user-images.githubusercontent.com/54589605/219707673-393ed120-cd47-49d2-864e-11d56703b4da.png)

* Base -> No. of digits, how many digits are used to represent a number.
* Binary -> Base 2
* Octal -> Base 8
* Decimal -> Base 10
* Hexa-Decimal -> Base 16

![image](https://user-images.githubusercontent.com/54589605/219708781-3fe5143a-ac4a-465f-8efd-eee0adef4c11.png)
![image](https://user-images.githubusercontent.com/54589605/219708821-673592bc-a99e-4dd8-9a88-cb40b2c1d972.png)
![image](https://user-images.githubusercontent.com/54589605/219709204-0ad1f924-b4e2-49a1-880a-2d01d8ee915f.png)
![image](https://user-images.githubusercontent.com/54589605/219709935-df35f230-e0fc-4be5-9c97-58e6d71cdeee.png)

### Binary to Octal

* Start from the **right side**.

![image](https://user-images.githubusercontent.com/54589605/219710635-c7d3d02a-8b29-44d7-88bb-ef7ab6d1575f.png)

## Hexadecimal to binary

![image](https://user-images.githubusercontent.com/54589605/219712212-25a99d92-9d63-42ab-a52d-ccdbfb348f43.png)
![image](https://user-images.githubusercontent.com/54589605/219712466-8ed2d6ed-2ad1-4aa0-ba06-149cafce8224.png)

## Binary to Hexadecimal

* Start from the **right side**.

![image](https://user-images.githubusercontent.com/54589605/219713506-80a9fdb9-1ad4-4f02-bbb0-adfe4de2dbe0.png)
![image](https://user-images.githubusercontent.com/54589605/219713548-9def2409-306f-4fe4-badd-170558757cd9.png)

## Conversion from Decimal

* Write the remainders from **bottom to top**.

![image](https://user-images.githubusercontent.com/54589605/219715084-9a4ba8e2-9c95-49c5-9bec-0f79c50fe7dd.png)
![image](https://user-images.githubusercontent.com/54589605/219715329-17c67c68-6e49-4af6-b8c1-33f0e4641c0e.png)
![image](https://user-images.githubusercontent.com/54589605/219715646-63266235-49f2-4990-a093-983b4360360e.png)
![image](https://user-images.githubusercontent.com/54589605/219715997-41189352-d401-45f3-b569-ee57272fbfab.png)

### Conversion of fractions to binary

![image](https://user-images.githubusercontent.com/54589605/219717094-d0be718a-ec96-4ec1-900d-1917d4eb38c2.png)

> Multiply the value with **2**, then whatever is on the left side of **point/dot(.)**, add it to **after the point part of answer**, if **1** comes then remove it before **multiplying** with **2** again.

![image](https://user-images.githubusercontent.com/54589605/219718043-fa01b2fb-b092-4d83-a0e1-677e2218014f.png)
![image](https://user-images.githubusercontent.com/54589605/219718381-a1f2a619-4abc-4c40-bffb-8db66b4948ec.png)
![image](https://user-images.githubusercontent.com/54589605/219718563-bb1c62f5-6094-4980-b79f-503df941abae.png)

![image](https://user-images.githubusercontent.com/54589605/219822467-ab1be341-8518-466c-adf7-0c5c7f97831c.png)

> Separately solve whatever is before the decimal point and separately solve whatever is after the decimal point.

* (5.75) base 10 -> base 2
* Solve **5** separately we get **101** which is the binary of **5**.
* Solve **0.75** separately by multiplying it with **2** ie. **0.75 * 2 -> 1.50**, we take the **1** and again multiply **0.5 * 2 -> 1.00**, we take the **1** again. The answer for **0.75 -> 11**.
* (5.75) base 10 -> (101.11) base 2

## Binary to Decimal

![image](https://user-images.githubusercontent.com/54589605/219822764-6da68cc4-7eec-405f-876b-4c5a807d7ff4.png)
![image](https://user-images.githubusercontent.com/54589605/219822841-ef7779b4-a27b-48ec-8127-265101fa02bd.png)

> For the values after the **decimal pointer**, start from the **decimal pointer** and go **right**.

* (0.10) base 2 -> Base 10

> We will first do **1** as it is closest to **decimal pointer**, **1 * 2^(-1)** and then do **0** ie.**0 * 2^(-2)**. 

* 1 * 2^(-1) + 0 * 2^(-2)
* 1/2 + 0
* 0.5 [Ans] 

![image](https://user-images.githubusercontent.com/54589605/219823222-33545d0e-d193-4940-bc30-652fa1c6ba78.png)
![image](https://user-images.githubusercontent.com/54589605/219823242-ba0d6dde-566d-4a48-900d-cc7afa2d3254.png)

## Decimal to Binary

![image](https://user-images.githubusercontent.com/54589605/219823476-c92c5dc7-58d2-4d94-b97c-37bd90d20f92.png)
![image](https://user-images.githubusercontent.com/54589605/219823522-0cb8b795-cbab-4695-bcf3-9ce40b980019.png)


## Decoder

> It takes input as **binary combination** and generates only one result as **enabled means one(1)**.
> Based on the **input combination**, only one output will be **enabled**. Only one output will be **1** and the rest will be **0**.

![image](https://user-images.githubusercontent.com/54589605/219823706-ab8dff21-fbae-4d0e-8117-58ae54118092.png)
![image](https://user-images.githubusercontent.com/54589605/219823758-7ee55bd5-0d75-40e5-a34b-69b48bfeb2e3.png)
![image](https://user-images.githubusercontent.com/54589605/219823813-854543e8-105c-4dc0-ae64-76a04a58f62e.png)
![image](https://user-images.githubusercontent.com/54589605/219823856-5136d80d-bcf6-4986-9da1-a0623615de81.png)
![image](https://user-images.githubusercontent.com/54589605/219823935-f5df5254-a9bb-4e00-9b86-0c0e4754a148.png)

## Multiplexer

> It selects one of the multiple inputs as output.
> It will only have one output always. It is different have decorder. Decorder can have multiple outputs, so many outputs but only one will be enabled.
> Whatever **inputs** we are sending to the **multiplexer**, that only will be taken as the **output**. Whatever input we are sending to a **multiplexer**, we are getting it back as the **output**.

![image](https://user-images.githubusercontent.com/54589605/219824148-2e0818c5-1502-4d22-b5de-f587a854fa69.png)
![image](https://user-images.githubusercontent.com/54589605/219824169-40e1e64c-522c-4378-8c9d-4cccd66c53ed.png)
![image](https://user-images.githubusercontent.com/54589605/219824179-e14ccab5-fc04-46e0-a089-562d2d26e8da.png)
![image](https://user-images.githubusercontent.com/54589605/219824366-6349d1e9-e715-4fad-939e-b025c001ce69.png)
![image](https://user-images.githubusercontent.com/54589605/219824765-33ed818a-2513-44ca-af0b-88d21bcc445a.png)
![image](https://user-images.githubusercontent.com/54589605/219824815-51994d74-a6f9-43a1-9a7b-c92a3c1549a2.png)
![image](https://user-images.githubusercontent.com/54589605/219824826-75134019-8108-4524-9785-77b139575c5f.png)
![image](https://user-images.githubusercontent.com/54589605/219824866-9dd6598d-e2ee-4307-b8e6-1e990fadd94b.png)


# COA

## Syllabus

![image](https://user-images.githubusercontent.com/54589605/222424846-0f6c97f9-1eed-4867-a1f3-719dfb004a65.png)
![image](https://user-images.githubusercontent.com/54589605/222425568-fcbe88e0-f315-43d0-a943-7709897c9968.png)


## Routine

![image](https://user-images.githubusercontent.com/54589605/222414532-a1bc4710-5af8-4580-af54-980475cdda3f.png)


* Course Link -> https://unacademy.com/course/complete-course-on-computer-organization-architecture/SFZXXJRP

## Basics of Computer Systems (1) [2nd March 2023]

![image](https://user-images.githubusercontent.com/54589605/222416710-8b5eed31-e7e2-495c-8ee6-1e2f3cec5dfb.png)
![image](https://user-images.githubusercontent.com/54589605/222417377-ef6c95c8-28f1-4ac4-9ee0-0f7eac37c841.png)
![image](https://user-images.githubusercontent.com/54589605/222417697-aa8c5fd0-cff0-4668-a1cd-a976ab7ccda7.png)
![image](https://user-images.githubusercontent.com/54589605/222417874-227000a7-45b3-474b-9fa1-7412c9f5cc92.png)
![image](https://user-images.githubusercontent.com/54589605/222418834-411bb0f0-aec8-4b9e-b257-cd356a8d774b.png)
![image](https://user-images.githubusercontent.com/54589605/222418919-7218e17f-df4a-4cc5-a8b0-3489c714a3a8.png)

* Micro processor -> CPU [Every is separate hardware, CPU is separate hardware, Memory has separate hardware and other devices are separate hardware as well]
* When we have single chip with memeory also and other devices on that chip only, that chip is called as the **micro controller**.


![image](https://user-images.githubusercontent.com/54589605/222419701-6526516e-a9f7-4e32-8f8d-3b20ec37732a.png)
![image](https://user-images.githubusercontent.com/54589605/222419845-47ef2fff-c2ff-4e64-b150-63949bd33632.png)

* CPU works on **Binary Number** system. 
* Data Format -> The data which comes to the CPU, how the data is represented(Binary, decimal, etc) in the CPU.

![image](https://user-images.githubusercontent.com/54589605/222420951-b871fb4f-edac-402a-a79c-d2034d4b03e5.png)
![image](https://user-images.githubusercontent.com/54589605/222421650-4fbad66b-f63c-4a4b-ba30-e233d9b489e0.png)

> When we try to make a computer system, we first decide logically what kind of design we want to have of the computer system i.e that is **Architecture** basically. When we try to implement it, we will be having the **Organizational** part coming into the picture. The **organization** says whatever **physical devices** we have decided in the **Architecture**, how will the physical devices be made.
> I have decided that I will teach a kid **multiplication**, that **decision of teaching, multiplication** to that kid is **Architecture** part. How will I teach **multiplication** to that kid is **Organization** part.

* Decision of teaching, multiplication -> **Architecture** part [Decision, what to do]
* How will I teach **multiplication** -> **Organization** part [Decision, How to do]

![image](https://user-images.githubusercontent.com/54589605/222424254-f491be35-622a-47c1-91c0-d2bf01c459ef.png)
![image](https://user-images.githubusercontent.com/54589605/222424288-d0e87ae5-577c-49ac-a6c6-f238e77102ba.png)
![image](https://user-images.githubusercontent.com/54589605/222424398-18d8cf26-a5c6-40e6-8969-d3e8c1f37535.png)

* Microprocessor is a special type of implementation of COA.

[**IMPORTANT**]
![image](https://user-images.githubusercontent.com/54589605/222424549-b3f47b87-ded1-46cb-8387-1f2e68b94340.png)

[**IMPORTANT**]
* After 2008, **microprocessor** is removed from the syllabus. Don't learn it and ignore the PYQ questions as well.

![image](https://user-images.githubusercontent.com/54589605/222424796-46b1970e-0a2d-49ad-b739-7e3d4126797c.png)

## Data In Computers

![image](https://user-images.githubusercontent.com/54589605/222427069-4be83cb3-a459-4e74-95b1-c7d924531c71.png)
![image](https://user-images.githubusercontent.com/54589605/222428365-1af0e0f0-d93d-42b1-908d-9b1cc7912696.png)


## Componenets of Computer

![image](https://user-images.githubusercontent.com/54589605/222429183-b2e5940f-c018-4608-b9c7-03df75fa0a12.png)

* ALU -> Arithmetic Logic Unit -> Arithemic, logic type operations are performed here. -> **Husband**
* CU -> Control Unit -> Controlling the entire computer system hardware. -> **Wife**
 
 > They are the **couple** of the house.

![image](https://user-images.githubusercontent.com/54589605/222432203-3ead5c4b-9026-42cf-be9c-b5ee4944e3c2.png)
 
### Other Componenets

### System bus

![image](https://user-images.githubusercontent.com/54589605/222433831-eb07b9e8-5c58-4b72-b987-5e541107712d.png)
![image](https://user-images.githubusercontent.com/54589605/222433927-2ad40f05-67fa-4997-bfac-808a2f517e8a.png)

> The single Communication/Connection line like a single wire can take **one(1) Bite(Either 0 or 1)**, it can carry **one bite** at a single time, from **CPU to Memory** and **Vice-versa**. It is **bi-directional**. If we want to send **more no. of bytes**, then we need more **single lines or wires**.
> If we have **5 lines** then we can **transfer 5bites** of data at a time. 

* Bus -> Collection of communication lines single-single lines/wires.

![image](https://user-images.githubusercontent.com/54589605/222434488-943004a5-f8e7-46c4-b6fa-64356992f07e.png)

* We make different types of busses, **what type of content that bus is carrying** or **for what purpose the bus is being used**. Based on these, we are deciding **different types of buses**.

### Types of Buses

1) **Address Bus** -> Only take the address from one place to another. -> **Uni-directional**.
2) **Data Bus** -> Only take the data from one place to another. -> **Bi-directional**
3) **Control bus** -> Only take the control from one place to another. -> **Bi-directional**


> **Control bus** -> It contains the **control signals**. Control Signal is send so that other devices understand what does the device want. Control Signal are signals which tells other devices, what to do. 

![image](https://user-images.githubusercontent.com/54589605/222437273-04cb9a5d-7c53-4aed-ae2b-f05a2ea5b179.png)
![image](https://user-images.githubusercontent.com/54589605/222438049-0ca32f7f-e0c6-4b8e-9b9e-d47bbf139848.png)

## Memory System

![image](https://user-images.githubusercontent.com/54589605/222438767-7abf9d8b-02f0-45f9-a7a7-ec38f080cce2.png)


## Registers and Memory Address (2) [4th March 2023]

* The basic reason for providing the address is that the CPU has to give some address or send some address to memory, and the memory will understand, where the CPU wants to do some operation(read, write etc). **This is the basic reason for providing address to each and every cell**.

![image](https://user-images.githubusercontent.com/54589605/222869679-12b4996c-a211-479e-91cb-1c0528ac099b.png)

> If CPU wants to select any particular cell then the CPU has to inform the **memory** by providing the **cell number i.e the address of the cell**. If CPU wants to send **the address of the cell** to memory, **the how will CPU send the address to memory?**

> Through **Bus**, Which Bus? -> **Address Bus**.

![image](https://user-images.githubusercontent.com/54589605/222869858-4e9a78d4-f794-41d0-b664-acebf6c241a8.png)

> If CPU wants to perform **read and write** in memory then it will send **the address of the cell** in a given range(0-15) here to memory i.e CPU is selecting that particular memory cell and wants to perform **read and write** operations there.

![image](https://user-images.githubusercontent.com/54589605/222870027-3d496553-12ab-4bc3-80b5-cab47cf07c2e.png)

### Memory operations

* Read
* Write

* Control Signal -> It is a signal which is used to inform to **memory**, what type of **operation** CPU wants to perform on memory.

### Read operation

* Enabled -> The signal is **tuned on i.e Carrying 1**.

> When CPU performs **read** operation, cpu has to send **two information** to memory, **one is address by address bus and one is control signal i.e read through control bus**. Memory will send data back to cpu through data bus.

* **tuned off i.e Carrying 0**.

![image](https://user-images.githubusercontent.com/54589605/222871379-c7745a0a-38fd-4da3-b46f-04923f756a8d.png)
![image](https://user-images.githubusercontent.com/54589605/222871436-48e3515e-98b3-4712-bc56-3795496d96fd.png)

### Write operation

> CPU sends **data** to memory through **data bus**, whatever data CPU wants to **write** in the memory. That data also CPU will send.

![image](https://user-images.githubusercontent.com/54589605/222871828-680bc636-cfa4-4d9a-815e-5be464ed2b28.png)

>  When CPU performs **read** operation, cpu has to send **three information** to memory, **one is address by address bus, one is data(content) through data bus and one is control signal i.e write through control bus**. Memory will accept the address, go to the address, whatever content cpu has send, memory will accept that and perform a **write** operation on that given address.


> In Both **read and write** operation, one thing is sure, cpu can send **enabled read/write** signal to memory, only when the memory is ready. There are control signals between memory and cpu. Memory is sending those control signals to cpu.

* The control signals are:

1) Ready
2) Busy/wait

![image](https://user-images.githubusercontent.com/54589605/222872994-8b1fc007-5fe9-4a98-b3d0-3a5128deceb7.png)

> As soon as cpu has send a signal to memory to perform read/write. What happens that memory will perform that operation and immediately as the memory accepted that signal of read/write, memory will **enable** that **busy/wait** signal.  **Busy/wait** signal will be **enabled or 1**. **Ready** signal will be **0**.

![image](https://user-images.githubusercontent.com/54589605/222873284-4e689a8e-cc5c-4e04-adb2-36476338b775.png)

> As soon as memory operation is over, **Busy/wait** signal will be **0**. **Ready** signal will be **1**.

![image](https://user-images.githubusercontent.com/54589605/222873317-b441f51d-f06a-4eb6-8934-47b1e5b8d621.png)


## CPU Registers

> The work of the cpu is to perform the operations, to execute the program, to execute the software.

* CPU registers are small memories inside the cpu.

![image](https://user-images.githubusercontent.com/54589605/222873484-de0fb589-5c78-44d6-8ee8-f92d59c7d728.png)

### Types

1) General Purpose Registers(GPRs) -> Any general data
2) Special Purpose Registers -> Special content/data. Very specific.

![image](https://user-images.githubusercontent.com/54589605/222873599-6938ac27-5193-4ee5-a963-5a23f73f875c.png)
![image](https://user-images.githubusercontent.com/54589605/222873638-2f899fa5-d77b-43c6-b9c9-43c45d3be61d.png)
![image](https://user-images.githubusercontent.com/54589605/222874085-35b645d4-db28-4eb3-9267-597ebecc3319.png)


## 1. Accumulator

* ALU -> It need **two** inputs and it generates the result.

![image](https://user-images.githubusercontent.com/54589605/222874263-ef77487a-dc3d-45d0-903c-971ba0667977.png)
![image](https://user-images.githubusercontent.com/54589605/222874329-a3c84a66-44f8-42a3-8550-b67042556488.png)

* One input should be taken from **accumulator** only. In ALU, only first input taken from Accumulator only that is fixed.


* These two designs are called as **architectures** of cpu based on **ALU** input. Or **Accumulator based architecture**.

![image](https://user-images.githubusercontent.com/54589605/222874504-37aefa34-909f-45cf-9969-19b53380998f.png)

* Based on from where the **two** inputs are coming to **ALU**, based on these we have different achitectures.

## Types of Architecture

* In every architecture, the result always comes to the **Accumulator** first.

![image](https://user-images.githubusercontent.com/54589605/222874573-78cf8d88-90be-475e-b1eb-3745b2e099c7.png)
![image](https://user-images.githubusercontent.com/54589605/222874651-37ccb6bd-f51c-411e-be17-2caa0c48767b.png)

![image](https://user-images.githubusercontent.com/54589605/222874768-ee23a81f-05f2-409f-a20a-428d0d2f6b65.png)

> As, **a and b** values are stored in memory, hence we have to first take the values from memory to some **genenral purpose registers(R1, R2)**. After that we can perform the **addition** operation.

* In Register-based architecture, if we want to perform any **ALU** operation on any values, both values are to be present in a **genenral purpose registers(R1, R2)**. If not present then we have to bring it first. First we have to bring the values into **genenral purpose registers(R1, R2)** and after that we can send them to ALU.

![image](https://user-images.githubusercontent.com/54589605/222874999-ac0220c5-8fdb-437d-a71f-bed47c9c13fd.png)


* Register-Memory Base Architecture -> The first input is fixed/restricted to **Genenral purpose registers** only. The second input has flexibility i.e it can be choosen either from **memory or Genenral purpose registers** depending on the condition or requirements. 

> **By default**, we have fixed the first input to *Genenral purpose registers** only. If we have to perform **a + b**, then **a** should be in a **Genenral purpose registers** and **b** can be in **memory or Genenral purpose registers** my choice but **first input is fixed**. This is the **default one**.
> In the questions they will **reverse it**, to **confuse** us.

[**Default**]

![image](https://user-images.githubusercontent.com/54589605/222875552-27e330dc-6524-4ea5-bafe-b64b329aa5f9.png)


* Complex System Architecture -> More flexibility. Four combinations/options available. 

![image](https://user-images.githubusercontent.com/54589605/222878099-0cfd032f-636b-4991-92cc-758922d0e5d8.png)


* Stack-based architecture -> Not in the syllabus. Jurt remember the drawing and nothing else.

![image](https://user-images.githubusercontent.com/54589605/222878127-3c4cd467-ed89-4dc9-af47-5fe3b6b8ce76.png)


## 2. Program Counter 

* It is just a pointer which will store the address of the memory, so that the cpu will know whatever program we are running, if current instructions are  completely executed then next instruction we will get from which address in the memory.

![image](https://user-images.githubusercontent.com/54589605/222878482-4b13fa66-ec75-4c69-aa75-589366e88f79.png)

## 3. Instruction Register

![image](https://user-images.githubusercontent.com/54589605/222878570-e33746da-1951-46c8-b94f-365f837fb69f.png)

* To store the current instructions, cpu has a very specific register called as the **Instruction register**. It stores the current instruction to be executed. Whichever instructions cpu brings from memory that instruction is stored in IR. The **viva chair** is the *Instruction register**.


## 4. Stack Pointer

* Stores the address of the top of the stack.

![image](https://user-images.githubusercontent.com/54589605/222878875-70335b45-ad2e-4c03-888a-86efc03037f7.png)

## 5. Flag or Status Register

![image](https://user-images.githubusercontent.com/54589605/222878989-b0fe9286-079e-4640-8960-c4ab040fa357.png)

* Carry is nothing but extra bit or extra result we have or not.
* Status of the current result we are generating.

* S -> Sign [Negative or positive]
* Z -> Zero [Zero or not]
* Ca -> Carry [Carry or not]

![image](https://user-images.githubusercontent.com/54589605/222879079-42bd3563-e4dc-4d74-b2ac-2a6dec5d7911.png)
![image](https://user-images.githubusercontent.com/54589605/222879099-e4ba3399-cd85-428b-9fbf-6c8af2a71f33.png)


## Address Register or MAR

* Used to send address to memory

> Cpu wants to do read/write operation in memory, cpu has to send address to memory through address bus. **Bus stop** in the cpu for address bus is **Address register**.
> If cpu is having any address which cpu wants to send to memory through address bus. First, cpu has to bring that address to **address register**. If cpu wants to send any address to memory through address bus then first cpu has to bring that address to **address register**. From **address register**, address bus is connected, that address goes to memory.

![image](https://user-images.githubusercontent.com/54589605/222879537-6ffd32ca-73c6-4711-aa31-297d9a96e587.png)


## Data Register or MDR

* Used to send data to memory -> Memory **write** operation
* Used to receive data from memory -> Memory **read** operation -> Data is coming from memory to cpu

![image](https://user-images.githubusercontent.com/54589605/222879676-395e5355-72d1-43f9-ad4a-f7766214cefc.png)

![image](https://user-images.githubusercontent.com/54589605/222879733-135a8053-7b37-49d4-a479-e10861f7ccec.png)

> **Current**

![image](https://user-images.githubusercontent.com/54589605/222880025-fe74dc2c-d582-487d-8ca0-36b5536e869d.png)

* It will be given in the question.

![image](https://user-images.githubusercontent.com/54589605/222880003-815ccc33-4646-47a7-837b-2401526f62dd.png)

* One(1) instruction is -> 2 bytes (Taken her)


### Questions

* If nothing is mentioned about **memory** then it is **byte addressable** by default .

![image](https://user-images.githubusercontent.com/54589605/222880526-0beb55ca-046a-4f9a-a6e4-404c460a6bcb.png)
![image](https://user-images.githubusercontent.com/54589605/222880612-da236703-b519-4bf4-958a-8d38f99ba02f.png)

> When **I120** has gone for execution, PC Or program counter will hold the address of next instruction or **I121**. The value will be **976+4 -> 980**. PC Or program counter will point to the next instruction.

![image](https://user-images.githubusercontent.com/54589605/222880683-a8e28e1f-11b3-4fd9-8ca2-496e19a580dd.png)
![image](https://user-images.githubusercontent.com/54589605/222880767-0fd476a4-ac6c-42bd-b972-e419128e1b09.png)
![1_registers](https://user-images.githubusercontent.com/54589605/222881338-c143d85e-5473-4e96-9f00-a1e2883e0f38.jpeg)

## Micro-Operations (3) [5th March 2023]

![image](https://user-images.githubusercontent.com/54589605/222943658-c52afd0c-83d3-41aa-9097-9360d1084abe.png)

* Status Registers stores the status, not the values. Status means 1 bit will be storing the status of sign of the previous result, which is either positive or negative.

![image](https://user-images.githubusercontent.com/54589605/222943769-fdccffe5-3f32-4ef6-97db-f7732052444c.png)

* Current instructions

![image](https://user-images.githubusercontent.com/54589605/222943830-6946397d-da9d-4762-951b-73623463810f.png)

* Yes

![image](https://user-images.githubusercontent.com/54589605/222943854-cf953fe2-e0af-4400-840a-baf13e09c0cc.png)

* Next instruction address

![image](https://user-images.githubusercontent.com/54589605/222943865-ae057227-2a3c-412c-b7d9-5cc742746b67.png)

* Also stores the address of memory. It stores the address of stack top.

![image](https://user-images.githubusercontent.com/54589605/222943916-1d3c3d88-25eb-4431-a47d-ad0a45bde848.png)

* Yes and Yes

## Architecture Type(Based on size of input)

* ALU can perfrom operations but there is limitation to ALU also. Let's say ALU can take two inputs for any operation(addition, substraction etc), **there is a particular limit for what can be the size in binary of each input**. Assuming that an ALU can take max. size of upto 32-bits of each inputs and can perform any operation. It can. This ALU is having a **32bit architecture** of the cpu or alu.

![image](https://user-images.githubusercontent.com/54589605/222944260-28d27d18-ac8d-4029-8e30-a26a0421efdf.png)

* If it is written like **32bit architecture** then we will know that each input for the ALU will be max. of upto **32-bits** only.

> We can say that the **CPU word size** for **32bit architecture** is **4bytes -> 32/8 -> 4bytes**.

* **CPU word size** -> **32bit architecture** -> **32/8** -> **4bytes**.

![image](https://user-images.githubusercontent.com/54589605/222944570-a901dac4-1389-4b75-a15a-65456be8c55b.png)


* We have **64bit ALU** also.
* If it is written like **64bit architecture** then we will know that each input for the ALU will be max. of upto **64-bits** only.


### Padding

* 5 -> 101 -> 0101 [As 4 bytes in 32bit architecture]

> Adding **0s** at the starting of the number to fit the architecture is called as padding.

![image](https://user-images.githubusercontent.com/54589605/222944721-2b5e65ec-5353-4b16-a7c6-7a388c92a399.png)

* Padding

> If we don't have a 32-bit number, then we will make a 32-bit number using padding. Then, CPU will always get a 32-bit number. ALU can use that afterwards.


* Padding -> Done though **unsigned values**.
* Signed bit extension -> Done though **signed values**.

## Micro Operation

![image](https://user-images.githubusercontent.com/54589605/222944829-dcf03f6c-57be-4433-a555-1727ecd4d10e.png)
![image](https://user-images.githubusercontent.com/54589605/222945386-a53fa1e4-3c6b-492d-ab06-a74dd4f14dd1.png)

> We write a program(user-program), in it we have written lots of statements. I am going from highest to lowest level. This **user-program** cannot be directly understood by the CPU. For that, some interpreter or compiler, some type of language converter comes and that language translater/converter converts this **user-program** into binaries. This **user-program** is converted into **binary statements**, that is called as **lower level language or program**, which cpu can understand. User writes statements in english characters, which cpu cannot understand.
> This **user-program**, compiler converts into **lower level language or program** which cpu can understand. Each of the staements written here are called as **cpu instructions** and **these are in binary**.
> Cpu executes instructions one by one to execute a program.
> **To execute one instruction**, cpu performs so many small-small operations.
> **One such small operation** is called as **one micro operation**. Cpu performs it.

* Micro -> small  [Meaning]

> If cpu is performing some operation, ofcourse those operation will be performed on those values that are present in the **registers**. Inside cpu, we have everything in the registers only.
> Other definition of **micro operation** is, whatever the operations performed/executed by cpu values stored in the register are called as **micro operation**.

* Micro Operation -> Smallest operation, which Cpu can perform at a time.

![image](https://user-images.githubusercontent.com/54589605/222945889-c99fe1f9-0593-49d0-b5e3-6895a502d885.png)

> In a single go, one operation that can be performed by the cpu that is one micro operation.
> In another go, another micro operation and on and on.
> That one go or one step done by cpu is one micro operation performed.
> Another step cpu is doing, another micro operation performed.

> That one step of cpu is called as **one cpu cycle time**.
> **One cpu cycle time** means cpu will be able to do one step of **micro operation**.
> Another cpu cycle time, another **micro operation**.
> Let's say a cpu has cycle time of **3 nano seconds or 3ns**. **3ns** means that in **3ns**, cpu can perform **one micro operation**. In another **3ns**, another micro operation will be performed and so no and so forth.

![image](https://user-images.githubusercontent.com/54589605/222949741-6219ba6e-2a26-45e4-a08e-0cd28e63c313.png)

![image](https://user-images.githubusercontent.com/54589605/222949750-f271e32c-7be4-4b49-a7d3-990eb2d93149.png)

* No, reading data from bus and coping it into register only. It is micro-operation only.


![image](https://user-images.githubusercontent.com/54589605/222949802-645f85bf-e572-449a-b944-ccfee938133d.png)

* No. They are not the same.
* Operation -> Is operation
* Instruction -> Will be responsible for operation. Micro instruction will be responsible for operation.

![image](https://user-images.githubusercontent.com/54589605/222950026-156ca46c-a14c-4930-85c7-2ad9f84ad896.png)

> In general, almost all of the micro-operations will be performed in **one cpu cycle time** only, whatever is the **cpu cycle time**. Some micro-operations will be there which will take longer, multiple cpu cycles.


![image](https://user-images.githubusercontent.com/54589605/222950184-0925fbdd-1997-4d03-bd50-68f5bd529cd4.png)

### Register Transfer

![image](https://user-images.githubusercontent.com/54589605/222950232-db925870-1816-4f08-b7cc-20df6232235a.png)

* R1 and R2 both have **5**.

### Memory Transfer

* Either read or write.

* Read -> Data goes from memory to cpu.
* M or m -> It represents memory.
* M(address) -> Representation of memory access. We accessed the memory at that address.

![image](https://user-images.githubusercontent.com/54589605/222950459-4aab03b0-f64f-4fb9-ac29-86f63ee595fd.png)

* Two ways of writing the address

1) We directly specify the address value.

 * M[address] -> M[5000] -> We go to the memory, there is an address 5000, on that address, some content is there, that particular content we need to read. We need to copy it into some register(DR).

![image](https://user-images.githubusercontent.com/54589605/222950610-4a597fa3-9f2f-4a7f-9721-c81ca68fcac1.png)
![image](https://user-images.githubusercontent.com/54589605/222950691-64163f2c-68bd-4fea-87fd-a4d721d45556.png)

2) We specify some register inside bracket( [] ), which will hold the memory address. Instead of directly writing the address, we write a register name here(AR). 'AR' is that register which is holding the memory address. Go to the memory and on address 500, whatever content is present, bring it into the Register(DR). 
 
  * M[AR] -> AR=5000 -> DR

> Target will be **'M', memory access** only. Inside we will specify address directly or through register.

![image](https://user-images.githubusercontent.com/54589605/222950980-28d482a3-4739-4939-b2c3-157523b43541.png)


* Write -> Content goes from cpu to memory.

![image](https://user-images.githubusercontent.com/54589605/222951042-58449b57-4102-4802-a811-62235fa17f65.png)

* Opposite of read operation.

![image](https://user-images.githubusercontent.com/54589605/222951170-57232cfc-6fd0-48a7-8789-d68eeaac3b85.png)

* M[700] -> 50 [Content which is present at address of 700]
* Content of M[700] which is **50** will be copied to a register(R1).

![image](https://user-images.githubusercontent.com/54589605/222951251-84aed1f8-ee79-4ccb-991f-aa55be1bf145.png)
![image](https://user-images.githubusercontent.com/54589605/222951284-b42fdd72-0416-498a-89d5-4692b4e7834c.png)

* R2=800
* R3 <- M[R2]
* R3 <- M[800] 
* R3 = 40.

![image](https://user-images.githubusercontent.com/54589605/222951372-b11b9009-71f9-4a6a-ac64-6bd63b38adbc.png)
![image](https://user-images.githubusercontent.com/54589605/222951421-ef25762a-e441-438f-af11-d85999649707.png)

* R4 = 500
* M[R4] <- R3
* M[500] <- R3 [R3=40, from above]
* M[500] = 40 [Previously M[500] was 10]

![image](https://user-images.githubusercontent.com/54589605/222951438-856642c0-9da1-4a80-ba99-1120a57b77ba.png)

* Yes, always.

![image](https://user-images.githubusercontent.com/54589605/222951476-659f5b04-397c-427e-b1e6-7c4c52096c6a.png)

* Some address will be given in **AR**, we will not be changing anything. We will just be using it. 

### Questions

* Whenever **#** is used, means **it is just a value**.

![image](https://user-images.githubusercontent.com/54589605/222951683-e695a1a4-4664-4760-9ad9-a886e4855962.png)
![image](https://user-images.githubusercontent.com/54589605/222951728-fa0bb919-af07-4be1-bb2a-f200d5137316.png)
![image](https://user-images.githubusercontent.com/54589605/222951800-24d6f1ce-8839-4d94-88c9-55c6027e6d57.png)

* We don't have to learn **Assembly Language**. Not needed.

![image](https://user-images.githubusercontent.com/54589605/222952074-da7c3eba-b8aa-4742-980e-eef51008f5a0.png)

## Status Register (Real Meaning)

* ALU takes two inputs, performs some operation. Result generated in Accumulator. Along with that, **status** is stored in the **status register or flag register**.

![image](https://user-images.githubusercontent.com/54589605/222953108-d8172348-f20e-4f15-aeef-d97f7ed38f5c.png)

* The status of these operation is **non-zero and positive and no-carry**. This status is stored in the **status register or flag register**.
* Based on these status, we will check the conditions(Do something if result is zero or non-zero). These condition check will be done on the status. 
* The status is of which operation?

> Whichever operation(R1 <- R1 -1, here) we did on the ALU.

> So in any case, if any condition is written in the program for the condition check, we will check the result of the operation we just performed in the ALU. We will check the result of the operation we just performed in ALU. Check the status of the result and based on that checkout the condition.
> Whenever a condition is checked, we will have the status of just previous operation, which we did perform in ALU and that status will be in **status register**.

### Question

![image](https://user-images.githubusercontent.com/54589605/222953720-3be2d6b7-dc20-49cd-8bce-c3f694b52803.png)
![image](https://user-images.githubusercontent.com/54589605/222953752-d96a5145-bdfb-4440-a791-7a44aed5ebd2.png)

* Branch on not zero to loop
* Branch -> Nothing but jump.

> If condition is **True**, we jump to **loop** and execute from **loop** again. The condition is **not zero**. 

* Which operation's result **not zero**?

> Just before this check. Check the statement just before the condition.
> **R1 <- R1 -1**. This statement.
> We are check this statement because this is the statement we have performed last in the ALU. After that we are checking the condition. Just before the condition statement, whichever operation we are performing, it's status will be in the status register. That status only we will check.

![image](https://user-images.githubusercontent.com/54589605/222954124-9cf81230-5aa0-487c-94fe-61732eb880a5.png)
![image](https://user-images.githubusercontent.com/54589605/222954177-95862236-faa6-43a9-a347-7ba83ebdf450.png)
![image](https://user-images.githubusercontent.com/54589605/222954191-2a4325ab-232f-4837-b816-1ddf474a5a7f.png)

* To read/write the operand value, how many times we have accessed memory in the above question?

> Once(1) or one time. First statement i.e **R1 <- M[1000]**. It is a memory **read** statement.


![image](https://user-images.githubusercontent.com/54589605/222955155-7e4c87d2-56d1-4010-af89-152d3bd11faf.png)
![image](https://user-images.githubusercontent.com/54589605/222955170-4ef5454a-8e8a-4745-9091-978f89dc13ba.png)
![image](https://user-images.githubusercontent.com/54589605/222956236-2170b7b8-3c12-4096-9a3b-327c62e13689.png)
![image](https://user-images.githubusercontent.com/54589605/222956277-d9d30797-454b-4e94-9572-8674c14f9a0a.png)
![image](https://user-images.githubusercontent.com/54589605/222956285-c062bf34-3232-4f65-9e72-f10c58432b6b.png)
![image](https://user-images.githubusercontent.com/54589605/222956421-1ba60279-cc87-406c-a055-93d5fd369336.png)

* 2 * any_number -> Even
* Even + 1 -> Odd

![image](https://user-images.githubusercontent.com/54589605/222956326-c896c593-0ca9-48ee-bdbe-4897eefc62b1.png)

* Yes [Asked for above question]

![image](https://user-images.githubusercontent.com/54589605/222956421-1ba60279-cc87-406c-a055-93d5fd369336.png)
![image](https://user-images.githubusercontent.com/54589605/222956514-7a51b53c-c64f-40f1-97f2-55ff6c194658.png)


![image](https://user-images.githubusercontent.com/54589605/222956578-db45244a-32ff-4846-8164-283a78ae2f08.png)

* Byte Addressable

### Word Addressable

* If memory is **word addressable**, then in **1 memory/address**, one(1) word is stored.

![image](https://user-images.githubusercontent.com/54589605/222956857-bef7d832-9efa-47b4-905d-e418f6fbf454.png)
![image](https://user-images.githubusercontent.com/54589605/222956920-160b25ff-d758-49de-8a95-9a91aa96cb74.png)

* No. of words -> Size taken by the operation

> If the size is **2**, then **2** addresses will be taken by that operation. If the size is **1**, then only **1** address will be taken by that operation. 

### Byte Addressable

> If memory is **Byte Addressable**, then in **one(1) room**, we can write **1 byte** only.

![image](https://user-images.githubusercontent.com/54589605/222957271-8c73dcc4-8540-4b1a-8741-feb6414f3378.png)


* 1 word -> 2bytes

![image](https://user-images.githubusercontent.com/54589605/222957021-46324007-d029-4be9-8247-c7d48299160a.png)

* 1 word -> 4bytes

![image](https://user-images.githubusercontent.com/54589605/222957075-e5f0942f-13cb-43a9-b414-cead1bc5c3c9.png)


![image](https://user-images.githubusercontent.com/54589605/222957422-f77ff054-2366-4650-9db3-9cfa041e90b3.png)

[**Interrupt**]

![image](https://user-images.githubusercontent.com/54589605/222957529-5bf8a78b-35ad-4e07-afaf-b69f06e9a27c.png)
![image](https://user-images.githubusercontent.com/54589605/222957581-187d7364-28a4-4912-b1a0-a07430229a54.png)
![image](https://user-images.githubusercontent.com/54589605/222957558-163d6874-8af0-43ae-b4e5-612f1805159e.png)

* INC -> 1020
* DEC R1 -> 1024 [Answer]

* If, Byte addressable, 1 word -> 2 bytes
* Dec R1 -> 1012 [Answer]

![image](https://user-images.githubusercontent.com/54589605/222957660-1b30f98e-adba-408f-a5f9-a41fa1025b26.png)

* If word addressable, 1 word -> 1 byte
* Dec R1 -> 1006 [Answer]

![image](https://user-images.githubusercontent.com/54589605/222957711-eab68717-dba2-4e11-aa21-5fed928b9798.png)

![image](https://user-images.githubusercontent.com/54589605/222957744-cc53aab9-6a7a-4aeb-ab98-085cf49847ff.png)
![micro_operations_1](https://user-images.githubusercontent.com/54589605/222959022-03974a2f-5549-45c6-87df-63c7713ffc27.jpeg)
![micro_operations_2](https://user-images.githubusercontent.com/54589605/222959023-ae0fd63a-47ff-4a7a-b972-7e6fafd7277e.jpeg)

## Doubts_Solutions (4) [6th March 2023]

![image](https://user-images.githubusercontent.com/54589605/223107582-c1e38937-b2cf-49c4-a60e-b5765550bfc6.png)
![image](https://user-images.githubusercontent.com/54589605/223107745-144455f3-caaa-4d01-a8d2-0d42e9a3c575.png)
![image](https://user-images.githubusercontent.com/54589605/223107858-65acb2d2-d8fa-49da-95f4-fb72016a665d.png)
![image](https://user-images.githubusercontent.com/54589605/223107988-d89f864b-ed13-428f-956f-7a46203fd59a.png)
![image](https://user-images.githubusercontent.com/54589605/223108094-6b3399cd-f1c7-4260-9ab0-6c959850efe3.png)


* Address Register ->  To send address
* Data Register -> To send/receive data.

![image](https://user-images.githubusercontent.com/54589605/223109278-01d37309-a4d0-4216-98ec-1308fa6b0b85.png)
![image](https://user-images.githubusercontent.com/54589605/223109444-1e2a8c0e-fdd4-484c-93a3-4dd33f99d50b.png)

* Instruction Registers -> Holds/stores instructions
* Program Counter -> Holds address
* Address Register -> Holds memory address
* Program Counter -> Holds memory address(next instruction)
* Stack pointer -> Holds address of stack top.
* Data Register -> Holds data or Hold operand values.
* Accumulator -> Hold operand values

![image](https://user-images.githubusercontent.com/54589605/223109671-003fb3bc-6ac5-4d2b-9557-1c8e958d934b.png)


* Included in Architecture -> CPU design, instruction, addressing mode and data formating. 
* Instruction set -> Collection of instructions

![image](https://user-images.githubusercontent.com/54589605/223110295-ce5492bb-764c-4d60-ad32-5f005d4b1c89.png)

![image](https://user-images.githubusercontent.com/54589605/223111212-38c2f12f-ac97-4c4a-a2a5-1792e52e555e.png)

* Implementation of Architecture comes in organization part.

![image](https://user-images.githubusercontent.com/54589605/223111405-ec3a9a85-772f-44df-9818-5b22e3c285c4.png)

* All of the other three(A,B and C) will store addresses. They will always store addresses.

![image](https://user-images.githubusercontent.com/54589605/223112091-d074362f-d7e2-4ab8-8c54-2b998fed428c.png)
![image](https://user-images.githubusercontent.com/54589605/223112634-77d2403f-1599-416b-bf3a-23e3e4ed543f.png)
![image](https://user-images.githubusercontent.com/54589605/223112936-0da6d2b1-6f39-474e-95ee-8069b96c2385.png)
![image](https://user-images.githubusercontent.com/54589605/223113044-48f04351-9e06-4dd6-b931-8cc9ed679b57.png)

* As we know it is byte addressable, hence 24bits is **3 bytes**. As **600** is the starting address, we will add **3** to it to go to the next address, **600+3 =603, 606,609.....**. The addresses will be multiple of **3**. Hence the answer is **900** as it is a multiple of **3**.  


* 5000 [Starting Address]
* 5000, 5001 [2 Words]
* 5002 [1 word]
* 5003, 5004 [2 Words]
* 5005, 5006, 5007 [3 Words]
* 5008, 5009 [2 Words]

* 5008 (Ans)

![image](https://user-images.githubusercontent.com/54589605/223114751-8c3783be-2c9d-447c-86dc-7a89e7035fda.png)
![image](https://user-images.githubusercontent.com/54589605/223114944-a53cde30-3e73-4903-93f7-a60bd89f8907.png)
![image](https://user-images.githubusercontent.com/54589605/223115164-c9f91004-aa56-4879-8701-a71f17e5e97c.png)

* 234 [Starting Address]
* 234 + 2 * 2 = 234 + 4 = 238 [Answer, C]

![image](https://user-images.githubusercontent.com/54589605/223123813-8b1a5b29-9598-42ed-ab48-3efa136d6860.png)
![image](https://user-images.githubusercontent.com/54589605/223128392-4ef3d241-8d0c-47c1-928b-f36ff20c632f.png)
![image](https://user-images.githubusercontent.com/54589605/223131812-89a1f732-807c-4580-848a-c0b2ef8b8417.png)
![image](https://user-images.githubusercontent.com/54589605/223131865-72061fe2-fb6b-4183-a58d-d6f8289805f8.png)
![image](https://user-images.githubusercontent.com/54589605/223131916-3e332225-c118-4efd-b258-2ced493e2a2b.png)

* It is possible that 2 micro-operations can be performed parallely.
* In **single memory system**, memory read and memory write both can be performed simultaneously. **NEVER EVER**. Not possible.

![image](https://user-images.githubusercontent.com/54589605/223132796-b23541d5-6304-4d25-b179-2cfb83ee7716.png)
![image](https://user-images.githubusercontent.com/54589605/223133263-c33ccbab-2ba8-4d7b-84d4-a40edfbc0461.png)
![micro_operations_3](https://user-images.githubusercontent.com/54589605/223426676-176e9f61-62e9-4303-8992-1797638c682f.jpeg)
![micro_operations_4](https://user-images.githubusercontent.com/54589605/223426685-b7f7425d-6a6f-4fb0-b6b7-cf2f21ce7318.jpeg)


## Micro-Operations: Part II (5)  [7th March 2023]

## Instruction Part 1

* Program -> Set of instructions or statements or code that we have written and runs on the cpu.
* Data -> Operands on which the program operates.

* Both **Program and Data** should be in Binary or converted to binary form.

![image](https://user-images.githubusercontent.com/54589605/223321326-97ef7305-ba4a-471c-a2fc-f07579c41670.png)

> Output also initially generated in binary only and later converted and presented to us in some visual or text form.
> Computer takes **input in binary** and also **outputs in binary**. Input means **program and data**, which will be comverted to binary and send to cpu for processing.

![image](https://user-images.githubusercontent.com/54589605/223321769-76bffca6-dbdc-4c9a-bb9b-2c204ea9dc32.png)

![image](https://user-images.githubusercontent.com/54589605/223321936-e83c0940-c401-47c0-80f6-30439714938b.png)

> CPU doesn't understand the above lines of program or code. CPU doesn't understand them directly, that's why **compiler** comes to the picture and **translates** the above piece of code into such kind of code which works exactly as the above code but in a **format which  cpu can understand**.

![image](https://user-images.githubusercontent.com/54589605/223322322-0d368e02-63be-478c-8c78-e0a09101f75c.png)

> The above code if we write then cpu can't understand anything. We have to translate into such type of code which cpu understands. The new code generated works like the above code but can be understood by the cpu. This new code is generated by the **compiler**. 
> The **language translation** is done by the **compiler**. The compiler generates the new code which is understood by the cpu.

![image](https://user-images.githubusercontent.com/54589605/223322902-bcd1bb50-92fa-4abf-821e-12e6a9a007c5.png)

* Output of both the code will be the **same**. The working of both the logic is the same. The result will not change. 
* Whatever we have written, the same kind of code will be running on the cpu but in a **different format**.

![image](https://user-images.githubusercontent.com/54589605/223323533-e4df25d8-add8-40dd-b8c0-93c190d79252.png)

> Whenever compiler converts these **programming statements**, into such type of code, these type of code is called as **low level code, machine langauge code, binary code, byte code, machine code**.

![image](https://user-images.githubusercontent.com/54589605/223323589-33087fdc-5525-40c5-b5a0-acf46c36d6ae.png)
![image](https://user-images.githubusercontent.com/54589605/223324852-e1e7f5eb-0df1-4d46-9757-eede29554786.png)

* Intermediate Code. 
* Direct convertion form High level language to low level language doesn't happen. First C-language program will be converted to **Assembly code**, then assembly to low level code.

* Instructions -> C-language statements are not instructions. Instructions are which cpu can understand. Instructions are nothing but **binary combination**.

![image](https://user-images.githubusercontent.com/54589605/223325129-24b694cf-a3a4-47a9-9a70-3258cba9bdd8.png)

> These are instructions.

![image](https://user-images.githubusercontent.com/54589605/223325389-24c8835b-559e-436b-ba12-0043f0aecae2.png)

* In instructions, in binary format only, there are **two types of information** are hidden/given.
* First few bits or left side few bits will be used to give information about **operation**. The instruction trying to do what type of operation. These few bits collection is called as **operation code or opcode**.
* Remaining bits will give information about the **operands**.

![image](https://user-images.githubusercontent.com/54589605/223326093-7942a64c-b9e1-4853-9f3e-6ba910db6cda.png)

![image](https://user-images.githubusercontent.com/54589605/223326635-5b6b9fe1-2a27-4852-963b-da05ab1cd8b4.png)

* There are **8** operations.

> Whenever the compiler will generate the instructions. The compiler will generate the instructions in such a way that for **addition**, the first **three bits** will be **000** which are the **opcodes** of the instruction.
> For instruction which has **substraction** operation, the first **three bits** will be **001** which are the **opcodes** of the instruction.

* For complement -> **101**
* Increment -> **111**.

> If at all the compiler will generate the instruction for the above computer system, the compiler will have to have **opcode of 3 bits**.

![image](https://user-images.githubusercontent.com/54589605/223327540-bf835fef-a3d1-4463-987a-2ca49281a017.png)

* How did we get the **opcode of 3 bits** for the above computer system?

> We have to collect first architecture information that total how many different-different operations, the computer architecture is supporting. Based on that, one instruction, the architecture can support of one addition type, one substraction type, one multiplication type etc. Whenever a unique instruction is created one for **addition**, then **addition** will have the first **three bits as 000**.

![image](https://user-images.githubusercontent.com/54589605/223328796-0d22c132-03cd-4d1a-8812-eb9bb80c4e29.png)

> If Vice-versa, when somebody has designed a computer architecture then that fellow could have **maximum** of 16 distinct instructions supported by the architecture.

![image](https://user-images.githubusercontent.com/54589605/223329208-a540aa89-08cc-4fca-b696-1c2f292905c5.png)

* Why maximum? [Means why for 4 bits maximum 16 instrcutions]
 
> When designing a computer system and during designing the computer system, they thought they needed a total of 15 
different types of operations only. For 15 operations to be supported, **opcode** cannot be of **3 bits** only, because with **opcode of 3 bits**, we can have a maximum combinations of 8 opcodes only, **2^3=8**. For making more than 8 combinations, the opcode combination should be **4**. Among 16 combinations available, one will be not used. Compiler will never generate that combination. Compiler will generate only that combination which is supported. Simple.

![image](https://user-images.githubusercontent.com/54589605/223330821-ffb89fa4-b436-4e90-8e11-77a7b90e40ba.png)

![image](https://user-images.githubusercontent.com/54589605/223331176-5bfa34e3-9b20-4b9f-9751-203116dda262.png)

* Yes, each instruction

![image](https://user-images.githubusercontent.com/54589605/223331755-57940888-a0dc-4a71-8017-bb77d8ccb054.png)
![image](https://user-images.githubusercontent.com/54589605/223331708-1b1c72b2-6c45-474b-8f84-7078e04823ed.png)

* Compiler makes the instruction. Compiler sees the hardware and then whatever program we have written, translates it into such kind of instructions which this hardware can understand. Compiler is making these binary instructions.

![image](https://user-images.githubusercontent.com/54589605/223332204-d7d26afa-87d0-4711-a12d-d2480f3ed1db.png)

* Compiler is not identifying anything. Compiler is making these binary instruction/strings. Compiler needs to understand that what the hardware can understand, based on that compiler generates it.

![image](https://user-images.githubusercontent.com/54589605/223332817-4182a175-b016-4d5f-bcbd-509261ee05a9.png)

* Architecture First. Then we implement it. Once implemented, after that at the time of usage, compiler thing comes.

![image](https://user-images.githubusercontent.com/54589605/223333619-b846a0ab-28d0-4148-8bf0-1034be76c098.png)

* Yes.

* why **min. no. of instruction cpu supports** is 1?

> If we say that there is an instruction supported then only we will have **opcode**. So if we have **instruction supported** then we will have **opcode**. Atleast **1** instruction should be supported. Atleast **1(one)** instruction should be there.

![image](https://user-images.githubusercontent.com/54589605/223334371-ebb1ee3d-23f3-4dfb-9dfe-7d0acc687ee2.png)

* Yes.

![image](https://user-images.githubusercontent.com/54589605/223334501-d84ffabe-2169-4d8a-9b71-79cb9ea46127.png)

## Instruction Set Architecture(ISA)

> Collection of all supported instructions by a cpu. It is also called as **instruction set** as well.

![image](https://user-images.githubusercontent.com/54589605/223334870-c6cb8963-6810-4804-af0a-6077ece9fe94.png)

* Size of instruction set -> How many no. of instructions are there in the **ISA**. **No. of instructions supported**.

![image](https://user-images.githubusercontent.com/54589605/223337840-5fdcad8f-a93d-4432-be34-b2bf19e9c4fa.png)

![image](https://user-images.githubusercontent.com/54589605/223337950-b5a821b4-a2c3-45e9-9f41-6264f3b8598f.png)

* Yes, same.

> When we design the system, apart from deciding the **instruction and their opcode**. We decide one more thing, that when we have the instructions, within an instruction, how many operands we can describe or specify. How many operand's information we will provide in one instruction. For **addition** we will specify **2 or 3** operands, **substraction** we will specify **2 or 3** operands, **increment** we will specify **1** operand. Like this way for different-different operations and different-different instructions, what happens for different-different instructions how many no. of operands to be given within an instruction, that is decided. Based on that we categorize the instructions, what type of instruction it is.

### Types of instructions

![image](https://user-images.githubusercontent.com/54589605/223340678-9d571cb4-6df3-4400-9b22-44a3c6c4d7da.png)

* Address -> Reference of operand. Where is the operand.

![image](https://user-images.githubusercontent.com/54589605/223341051-136793a3-21c9-4911-8a2f-6263241ab1ac.png)

### 3-Address Instruction

* How many operands we will specify when we have **3-Address Instruction**?

> Three(3) operands we will specify.

> **opcode** is the mandatory part of instruction. Without opcode, no instruction. opcode is mandatory part, that only will specify what is the instruction type. Apart from that these **3 operands** we will be having. For the first operand, we will specify the address where it is located. For the second operand, we will specify the address where it is located. For the third operand, we will specify the address where it is located. Such that we are specifying three address here.

![image](https://user-images.githubusercontent.com/54589605/223344231-4487e6c4-6014-4428-b7f7-7dc4153a4f8e.png)
![image](https://user-images.githubusercontent.com/54589605/223344638-d73ac35d-e017-4204-86ef-f3cfe09b911f.png)

* Designer of the architecture will decide if **first address or Register 5 is the destination address** or **address 3 or register 1 is the destination address**.

* Use of **3-Address Instruction**.

> We can specify **two operands** for taking two inputs and another 3rd operand for giving the result where we have to store the result.
> Apart from opcode, we will specify three operands, one operand will be destination and two will be the source of the operations.

* Destination -> Where to store the result/output.
* Source -> From where to get the input.

![image](https://user-images.githubusercontent.com/54589605/223345903-106c9d58-5a82-44b0-ad11-e9f2cc811b36.png)

* If in an instruction, three operands are specified. We can take intuition that two operands will be take as input/source operands and one will be take as output/destination operand.

* Output operand -> Where the result is stored.

> Let's say there is a new computer system and that computer system is supporting 3-address instruction.

* Max. how many operands we can provide within one instruction itself?

>  Three(3).

* Can we get more than 3?

> No.

![image](https://user-images.githubusercontent.com/54589605/223347794-82b4d4b8-365d-4358-8cb1-1d7076de0f32.png)

* We cannot specify **4** operands in an architecture which is supporting 3-address instruction. So we will have to break down. We have to break down it.

* Who will break down this?

> Compiler will break down this, so that compiler can make instructions for these(3-address instruction) cpu which only supports 3-address instruction.

![image](https://user-images.githubusercontent.com/54589605/223348609-77f57830-a938-4e73-9f7d-7f0ef7f250c9.png)
![image](https://user-images.githubusercontent.com/54589605/223348850-0fe815dc-09d9-4ab1-9fd3-d48fb07a8689.png)

* Now it is possible, as there are max. of **3** operands specified.

> If computer system supports **3-address instruction**, whichever instruction is generated. If it needs or any 
operation needs more **3 operands**, it will be broken down into multiple instructions by the compiler so that every instruction can be max. of three(3) operands.
> If any instruction needs **2 operands**, compiler will do that too.

![image](https://user-images.githubusercontent.com/54589605/223349632-badd8a46-9dde-4308-a901-99607da3085f.png)

* Max. will be 3.

### 2-Address Instruction

> Apart from opcode, we can only specify max. of **2 operands** only. Not more than **2**.

![image](https://user-images.githubusercontent.com/54589605/223350423-b10645c7-ba6a-4d08-85b3-0fbf75316ff2.png)

### 1-Address Instruction

> Apart from opcode, we can only specify max. of **1 operands** only. Not more than **1**.

![image](https://user-images.githubusercontent.com/54589605/223350517-2145c388-fb85-4322-915e-f66bd8813926.png)

### 0-Address Instruction

> **Only opcode can be specified in the instruction here**. No any address can be specified within the instruction. opcode should be there in the instruction, it is mandatory part.

![image](https://user-images.githubusercontent.com/54589605/223350847-31d685ff-9972-4929-bdc3-df673b09bde3.png)
![image](https://user-images.githubusercontent.com/54589605/223351204-954b3056-ba79-47a7-8b46-b6d2b83049d8.png)

> If we build a new architecture, and we have said that it will support max. of **3-Address instruction**. So, it will support 0-Address Instruction, 1-Address Instruction, 2-Address Instruction and 3-Address Instruction, based on how many operands needed for that instruction. For **add and sub** operation, we will need **3**, for **moving/copy** operation we need **2**, for **increment/decrement of any register** operation will require **1** operand. Some operations will not require any operands as well then **0** also.

> If my computer supports **2-Address instruction**, means that if I am going to perform **addition** also, more than **two operands** we cannot specify. 
> Here, if **Register 5 and 6** are taken as inputs for the addition, among these two, then one of them will act as the destination operand also. 

![image](https://user-images.githubusercontent.com/54589605/223392643-e73c17a6-beae-4394-8106-2da43ffa4a8e.png)

* We will be deciding which one. 

> If my computer supports maximum **2-Address instruction** and not **3-Address instruction** , means that it will support **2,1,0-Address instruction**. 
> Among these two(two address), one of them will be the destination operand.

![image](https://user-images.githubusercontent.com/54589605/223393473-06269525-f6d6-466f-9eb1-7c3a436462ce.png)

![image](https://user-images.githubusercontent.com/54589605/223393676-929616a4-572d-4904-95bd-075061ee976f.png)
![image](https://user-images.githubusercontent.com/54589605/223393766-d51ab499-d8f4-407a-84dc-5569c7af1018.png)

* Overwritten by result.

> If my computer supports maximum **1-Address instruction** and not **2-Address instruction** , means that it will support **1,0-Address instruction**. 

![image](https://user-images.githubusercontent.com/54589605/223394213-7cd97fcc-038c-4347-90c9-e7e9ff4bd694.png)
![image](https://user-images.githubusercontent.com/54589605/223394928-a9bb7b76-f8ca-4b0b-b537-8fdca14dd40b.png)
![image](https://user-images.githubusercontent.com/54589605/223394983-9635770e-febe-47d5-9e1f-9205730f98fc.png)

* Accumulator is that one friends who goes with you everywhere you go.

![image](https://user-images.githubusercontent.com/54589605/223395592-2e421181-6b5f-474a-9c66-1e8a61457a90.png)
![image](https://user-images.githubusercontent.com/54589605/223395966-746459fc-9063-4343-8c33-f90940780838.png)

* Since both are addition, hence the oppcodes will be the **same**.

![image](https://user-images.githubusercontent.com/54589605/223396274-8325519c-8bb6-428f-ac2c-e0622913e96f.png)

> In the architecture side, architecture understands **what type of instruction** it is. In the perspective of architecture both the above instructions are same to same, why because both do **additions**. Architecture doesn't  care about what value or from where the value came, which value we are using for addition. Architecture says **addition** means addition and both are the same. 
> When we say a system supports 16 type of instructions, it means in the perspective of architecture that there are 16 different opcodes are there. Doesn't matter on which operand they are performing on.
> In the perspective of architecture, 16 instructions are 16 operation distinct type of. Addition is addition, value is whatever doesn't matter.

> They two are different in the perspective of program, when we say program in the context of the compiler, program are generated by compiler. In the program, these two statements are different-different statements, different instructions but type of instruction is same to same in the architectural design or perspective.

![image](https://user-images.githubusercontent.com/54589605/223400104-f18972df-1d59-4de2-a171-f364705b16f4.png)
![image](https://user-images.githubusercontent.com/54589605/223400149-4f67b83d-c891-453e-b2fe-e1bfd0ad3067.png)

* Source and destination are two different things.

* Register <- Memory [Load]
* Register -> Memory [Store]

* No. of instructions in program -> 8 [Count of sentences of code]
* Types of instructions ->  4
* In the perspective of architecture, types of instructions -> 4

* Types of instructions 

1) Register <- Memory
2) Register -> Memory
3) Addition
4) Multiplication

![image](https://user-images.githubusercontent.com/54589605/223400820-978e8d97-df44-4dfa-a7e2-100a56d93102.png)

* Using these **distinct 4 instructions**, compiler can generate so many instructions for a particular program.

> Whatever compiler generates are stored in **main memory or RAM**. The program is also stored in **main memory or RAM** as it is generated by the compiler.

### Questions

![image](https://user-images.githubusercontent.com/54589605/223402330-697c75d6-0dbb-4e81-bcbb-b27d0fc7ee94.png)
![image](https://user-images.githubusercontent.com/54589605/223402921-cd5b07a1-64e6-4753-bd12-811f917f3c39.png)

* Addition, multiplication -> type of instruction
* The whole thing is the instruction.

* How many instructions the system can support?

> How many distinct type of instructions the system can support.

![image](https://user-images.githubusercontent.com/54589605/223405176-739dc5a4-2840-4151-9a27-becda656a2a4.png)
![image](https://user-images.githubusercontent.com/54589605/223405201-69a38fd3-0f75-413e-95e3-61027045f5fe.png)
![image](https://user-images.githubusercontent.com/54589605/223405660-80902714-4427-4867-bda3-3de5bcdcadbc.png)

* Every instruction for these computer system whenever compiler will generate each will be **24 bits**.

* How many types of instructions the compiler can generate for the above system?

> 2^6 -> 64 [Ans]

* How many no. of instructions the compiler can generate for the above system?

> Unlimited.

> The compiler converted the C-language program into binary code. Is it possible that **1000** instructions are them? **Maybe**.  All those instructions will be of that type which **my cpu** can support, **yes**. Based on looking at the hardware and the design, the compiler has generated this **binary code**. 

* Where to keep/store this **binary code**? 

> So that particular **binary code** converted program, will be kept in **main memory(RAM)**. First the compiler compiles it, makes and stores it in **main memory(RAM)**. Then, cpu takes one-by-one instruction and runs it.

![image](https://user-images.githubusercontent.com/54589605/223408519-7b6dca25-0611-42b6-80b6-b9cc8e07c731.png)
![image](https://user-images.githubusercontent.com/54589605/223409008-a709ef07-e4c4-4d8b-9c86-47f1f362637b.png)

* It is stored in a specific section, called as the **code section**.

> These instructions sir was talking about in last class, these instruction's address cpu has in **program counter or PC**.

> For a program, which we wrote in c-language, which compiler has made instructions of binary code. There are 1000 instructions, each instruction is **24 bits**. All of the instructions are kept in main memory.

![image](https://user-images.githubusercontent.com/54589605/223410522-cfb866d7-3008-457b-8b94-503361329110.png)
![image](https://user-images.githubusercontent.com/54589605/223412469-bc03c272-756c-4ee8-89bc-7638aa334587.png)
![image](https://user-images.githubusercontent.com/54589605/223414770-87e990d6-4310-4a51-a33e-14186b3f8e01.png)

* 21 bites -> 8 + 8 + 5
* First 8bites -> 1 byte
* 2nd 8bits -> 1 byte 
* Last 5bits -> 1 byte

> Even though the last 1 byte is not completely filled, we will got to the next byte to store the next values.

![Instructions_1](https://user-images.githubusercontent.com/54589605/223426842-edde37b0-0b15-463e-a821-32b1b9710750.jpeg)
![Instructions_2](https://user-images.githubusercontent.com/54589605/223426854-950e3e97-8728-470c-a6fa-4bdcedb0f477.jpeg)
![Instructions_3](https://user-images.githubusercontent.com/54589605/223426857-1d51ef28-e7c9-44c1-97ab-9d223e242ffc.jpeg)


## Instructions Part 2 (6) [9th March 2023]

![image](https://user-images.githubusercontent.com/54589605/223940650-b1be401f-d87d-42bd-8cbd-d158a61f1092.png)
![image](https://user-images.githubusercontent.com/54589605/223940673-4326e66e-46ea-4d4b-9234-11c2f05731c9.png)

* From the perspective/view of **architecture**, both are **same** i.e both are addition. Because the **opcode** is the same for **addition**.
* From the perspective/view  of **program**, both are **different** instructions.

![image](https://user-images.githubusercontent.com/54589605/223941822-0af211c2-9f6b-4795-b3de-dc40abbe4dd2.png)
![image](https://user-images.githubusercontent.com/54589605/223942006-0a6c2cd7-d926-4560-b4ec-9f15f0ad395c.png)

* All type of instructions whichever a particular type of cpu supports, that collection is called as **ISA**.


![image](https://user-images.githubusercontent.com/54589605/223943137-7f2868fd-061f-4ebc-84e6-b78441ee99bc.png)

* On the left hand side or **Byte Addressable**, we are storing **2 Bytes** on **2 addresses**. 
* On the right hand side or **Word Addressable**, we are storing **2 Bytes** on **1 or single address**. **100 words** for **100 instructions**, total **200 bytes** needed/given for the program.

* For both of them, we will require **2 bytes** of space, to store the **one complete instruction**.

![image](https://user-images.githubusercontent.com/54589605/223944296-769a7eb6-185c-4206-bebf-0e24edf6497b.png)

* Too much **wastage** of storage here.

* Per instruction, how many bytes are wasted?

> 4Bytes -> 32 bits, but we need 12 bits only. So (32-12)= 20 bits are wasted per instruction.


![image](https://user-images.githubusercontent.com/54589605/223943137-7f2868fd-061f-4ebc-84e6-b78441ee99bc.png)

* Per instruction, how many bytes are wasted for left hand side or **Byte Addressable**?

> 2Bytes -> 16 bits, but we need 12 bits only. So (16-12)= 4 bits are wasted per instruction.

* Per instruction, how many bytes are wasted for right hand side or **Word Addressable**?

> 2Bytes -> 16 bits, but we need 12 bits only. So (16-12)= 4 bits are wasted per instruction.

![image](https://user-images.githubusercontent.com/54589605/223945822-53880da0-d901-4b05-8e7e-0c59bb99fdc2.png)

> When we call these **wastage** in very technical term, it is called as **internal fragmentation**. Wastage of extra spaces.

* **Total Internal Fragmentation** for left hand side or **Byte Addressable** -> 4bits * 100 total instructions -> 400 bits -> 50 bytes

* 4 bits per instructions
* There are 100 total instructions

> It is the same for right hand side or **Word Addressable**.

![image](https://user-images.githubusercontent.com/54589605/223946515-486ec06c-40bc-430d-9c36-d6618edb8c6e.png)

* **Total Internal Fragmentation** -> 20bits * 100 total instructions -> 2000 bits -> 250 bytes
* 20 bits per instructions
* There are 100 total instructions

![image](https://user-images.githubusercontent.com/54589605/223947306-f71a3bdf-d991-47f5-ab99-37bf60b81bd7.png)

* Yes. Fragementation means wastage of storage space.

> Whenever a computer system is designed, it is not the case that the instruction format will be strictly only in these below formats. Computer system instruction format can be anything. Atleast theoritically it can be anything.

![image](https://user-images.githubusercontent.com/54589605/223946910-867039de-51a0-46b7-843c-a1623b0b0ee7.png)
![image](https://user-images.githubusercontent.com/54589605/223947870-63e12745-bdff-43d9-a3a1-3d639a5eef07.png)
![image](https://user-images.githubusercontent.com/54589605/223947889-ca95a365-dffc-4348-b635-2d9b858c92de.png)

* We want to number all of the registers, uniquely. If we want to number all of the registers in **binary**, then that particular register number will require how many **bits** to be given?

> We need **3 bits**, 8= 2^3. Hence we need 3 bits.

![image](https://user-images.githubusercontent.com/54589605/223948423-ea063071-408e-442f-bd69-6f46ada6f625.png)

> For **n** registers, the register numbers will be in **Ceil(log n)** bits.

![image](https://user-images.githubusercontent.com/54589605/223949961-8dd32836-c344-4371-9011-4fd992a855c4.png)
![image](https://user-images.githubusercontent.com/54589605/223950061-730387c0-5d0d-4d47-925b-22997aee18ab.png)

* Yes, rather than address they are giving **register number** here.

![image](https://user-images.githubusercontent.com/54589605/223950649-c3f370c8-ea5a-4520-acd2-8292cb8171d8.png)

* No, if we see a question where in the registers, in place of the registers, special purpose registers are mentioned or in any of the operand field special purpose registers is mentioned then that is a wrong thing/question. We are not going to solve that question.
* We will never specify any **special purpose registers** at all here(Circled or highlighted). Never ever at all. Special purpose registers are having very special purpose to be served and those will never be mentioned here.

![image](https://user-images.githubusercontent.com/54589605/223951176-657239d9-d7e0-4504-81f9-53b4bd4095ee.png)
![image](https://user-images.githubusercontent.com/54589605/223953304-7c88f8e0-d4e7-4140-b2cb-db1079e834f5.png)
![image](https://user-images.githubusercontent.com/54589605/223956928-7b248e43-fdd4-4cd4-9305-92421b2e5fe2.png)
![image](https://user-images.githubusercontent.com/54589605/223957189-f04e08fb-d036-4ec7-8cda-61a133dd898c.png)

* 1 bit is given for **sign**.
 
 ![image](https://user-images.githubusercontent.com/54589605/223957570-5199af1d-c636-424b-b8a3-d18a5a34509f.png)

* We got **9 bits** as the answers. That why **2^9 -1 -> 511**

![image](https://user-images.githubusercontent.com/54589605/223958110-94b5c57b-7349-4892-bd2f-8b42e30dc587.png)

* Here, n=9, as we got **9 bits** as the answers.
* **2^(n-1) - 1 -> 256 -1 -> 255.

> As we have given **numbering** to each and every register. Similarly, we have to give **numbering** for **memory cells** also like addresses. It will be in **binary**.

![image](https://user-images.githubusercontent.com/54589605/223959032-d785a565-cdb1-442f-929f-b021994cda42.png)
![image](https://user-images.githubusercontent.com/54589605/223959369-c3ab671d-066e-4d54-bafa-cfe41f57483c.png)

* Memory is **byte addressable** -> Each address is **1 byte** -> Each Cell is **1 byte**.
* Memory Size or Overall memory size -> How much content this memory can store total is equal to **64 bytes** .

![image](https://user-images.githubusercontent.com/54589605/224018634-81883f8a-0dd9-4939-a5f8-38211ba04f91.png)

* Per address how much data we have stored?

> 1 byte. Per address 1 byte we can store.

![image](https://user-images.githubusercontent.com/54589605/224019429-0471e268-5506-4d68-8d65-ba983e1bc0c9.png)

* Address size = log 64 -> log 2^6 -> 6 bits.

![image](https://user-images.githubusercontent.com/54589605/224019904-33321b72-09f8-476c-9984-b70b5864c212.png)
![image](https://user-images.githubusercontent.com/54589605/224020217-af2c977a-7c95-4909-9dab-858bc8875ed6.png)

* No. of cells or no. of addresses -> 256B/1B -> 256
* Address Size -> log 256 -> log 2^8 -> 8 bits

![image](https://user-images.githubusercontent.com/54589605/224020544-114331ed-ca2c-45f2-991f-2d6ab1aaba3b.png)

* No of cells -> 2^17B/1B -> 2^17
* Address size -> log 2^17 -> 17 bits.

![image](https://user-images.githubusercontent.com/54589605/224020403-a01fb7ff-29a2-4f49-8754-4cee78ac3733.png)
![image](https://user-images.githubusercontent.com/54589605/224021135-b5f2dc16-8c7f-4a0e-9147-d3cee9f4eba6.png)

* Address size -> log 16 -> log 2^4 -> 4 bits.

![image](https://user-images.githubusercontent.com/54589605/224023727-f4d71e07-b16a-4c8e-badc-a6019ceff85d.png)

![image](https://user-images.githubusercontent.com/54589605/224025121-9326e6eb-da6c-4db7-b0dd-24687a36ea9f.png)
![image](https://user-images.githubusercontent.com/54589605/224026182-23843c46-8b75-4645-8c46-e7371530178c.png)

* 5 instructions require 2 operands only(+,-,* , /). -> Here, we will have **opcode** of lesser bits.
* 4 instructions require 1 operands only(+=,--,!). -> Here, we will have **opcode** of more bits.

> Possible, yes ofcourse both the type of **instructions** are supported. If, length is fixed then the length of opcode will be increased. So we will have **extra bits** in opcode in the **4 instructions require 1 operands only case**. So, we have **variable length** opcode.

![image](https://user-images.githubusercontent.com/54589605/224029314-8d2f2245-8002-4587-aad9-db3e6c1316c1.png)
![image](https://user-images.githubusercontent.com/54589605/224030029-b65488bd-eef4-43a7-9dd9-d97150a43b70.png)

* cpu design will be something like this that, it will match the smallest size of **opcode**. In the above two instructions which is the **smallest** size of **opcode**. Here, it is the **2-address instruction**  which has the **smallest size of opcode**.  

> So whenever a instruction comes to the cpu, cpu will try to match the first two bits which are the **opcodes** with it's hardware that do we have **10** as the opcode combination for any two bit instruction. If yes, then the cpu has to interpret and run this (101011) instruction as **2-address instruction**.

* Opcode -> 10
* address 1 -> 10
* address 2 -> 11

> If these first two (10) bits are not used for **2-address instruction** opcode design then cpu will go with the **1-address instruction** design. Then,

* Opcode -> 1010
* address 1 -> 11

![image](https://user-images.githubusercontent.com/54589605/224032629-8ce7c87b-ab70-48ee-bf49-64b884dcd1ff.png)
![image](https://user-images.githubusercontent.com/54589605/224033262-07cdd1b8-1713-43b7-881b-78a9fe80c6cf.png)
![image](https://user-images.githubusercontent.com/54589605/224033297-e400d0b8-8534-48c2-9a55-a5f04f9d8cca.png)

> Whenever a particular architecture is build based on the above assumptions on **image 3** and if 6 bit instruction is coming to the cpu then cpu will first match the 2 bit of instruction(10) because smallest/minimum opcode bits are 2 bits in **2-address instruction**. If yes, then this instruction(101011) will be interpreted by cpu as **2-address instruction**.

![image](https://user-images.githubusercontent.com/54589605/224034477-2481a310-7df6-4e3c-84ad-e0d03ae0d26b.png)

> Any instruction comes which is having first two bits as opcode and they are **00, 01 or 10**. Then that instruction will be interpreted/executed as **2-address instruction**.
> The instruction who's first two bits are not in **00, 01 or 10**. The first two bits of instruction should be **1**.

![image](https://user-images.githubusercontent.com/54589605/224035602-322db038-4453-4255-993b-1e540fc4311e.png)
![image](https://user-images.githubusercontent.com/54589605/224035655-c16ee6db-963e-4616-bc24-18032904ec07.png)

> Now, if we go to **1-address instruction**, the total length of opcode is **4**. First two bits got fixed, in opcode of 4 bits as **11** is the only combination of **first two bits** which can go to **1-address instruction**, any opcode which is starting with (11) that only can come to **1-address instruction** only.

![image](https://user-images.githubusercontent.com/54589605/224036956-b9d80d02-b10a-4432-a3c1-a01fab5f186d.png)

* We can have **4 possible opcode** we can have in this case, where instructions will be interpreted, understood as **1-address instruction** only. Not more than that.

* Maximum possible opcodes available for **1-address instruction** is?

> 4. Not more than that.

> In such kind of questions where multiple instructions are supported, then we will start solving the question from wherever we have **minimum no. of bits of opcode**. From that format we will start and go to **higher bits of opcode**.

![image](https://user-images.githubusercontent.com/54589605/224039264-fc64e2bd-0124-466c-b3fc-0bb3f098087c.png)
![image](https://user-images.githubusercontent.com/54589605/224039337-d7680d3a-edc8-4dc6-b632-73f8b040e919.png)

* **Previous level** -> Start with minimum opcode bits, max. opcode combinations will be **2^2 -> 4**. From the question we know **3** opcodes are used. Hence **1** opcode is not **used**. Go to the **next level**.

![image](https://user-images.githubusercontent.com/54589605/224039987-3f712f98-5642-4e72-91d7-9a40efabecc3.png)

* **Next level** -> After this, complete opcode(4 bits) will be divided into **two** parts. From left side, first starting part, previous level opcode bits(2 here) are taken. The count of the previous level bits are taken into the **starting/first** part. First part will have previous level opcode bits and these two bits are fixed. If total bits is **4**, then **2 bits** are used in the first part as they are coming from the previous level and  then the 2nd part will be **4-2 -> 2** bits. Now, with these **1** combination, which is the count of **unused combinations** from previous level, we will make  binary combination of the remaining two bits. This is how we will get the **max no. of 1-address instructions**.  

* How many opcode bits in previous level or  in **2-address instruction**?

> 2 bits

* How many **unused combinations** we are getting from previous level for starting two bits?

> 1.

![image](https://user-images.githubusercontent.com/54589605/224045088-7b820458-e5be-4575-a58b-6192c789e444.png)

![image](https://user-images.githubusercontent.com/54589605/224046996-27fa1710-2172-41bd-bbd6-6507758da9d2.png)
![image](https://user-images.githubusercontent.com/54589605/224047065-69257a18-e57c-4f7c-a3cb-844ed855f077.png)

> We can pretty surely say that there is no any **2-address instructions** supported in this system(highlighted with blue). Only **1-address instructions** are there. If qustions says that we need both **2-address instructions and 1-address instructions** supported then this **case** is not possible. 

> It should have **atleast one** instruction supported to support the **2-address instructions**.

![image](https://user-images.githubusercontent.com/54589605/224047831-512c4ae1-d8f2-4080-8009-a9af3dc8c675.png)


> Here, we have used all opcode for **2-address instructions**, so we cannot use any opcode for **1-address instruction**, which means that there is no **1-address instructions**. Hence, **1-address instructions** is not supported.

![image](https://user-images.githubusercontent.com/54589605/224048908-45628432-2c48-4cbb-9c51-beed59731a2a.png)

> If we have **2 bits address** and **6 bits instruction**. Then,

* Maximum **2-address instructions** we can have?

> 3. Not more than that. If we make **4** then **1-address instructions** won't be supported.


* Minimum **2-address instructions** we can have?

> 1. Not less than that. If we make **0** then **2-address instructions** won't be supported.

> **2-address instructions** can vary from **1 to 3**.

![image](https://user-images.githubusercontent.com/54589605/224052836-309d2284-da3d-4e9d-bc66-caaded058ddc.png)
![image](https://user-images.githubusercontent.com/54589605/224055429-3945adb7-c697-463c-90b0-148c49070b34.png)


![Instructions_4](https://user-images.githubusercontent.com/54589605/224235345-be07aacb-36fe-4028-a8b4-c1307e60b68d.jpeg)
![Instructions_5](https://user-images.githubusercontent.com/54589605/224235350-35389ad1-82ed-4747-aa1f-fb04f8971134.jpeg)
![Instructions_6](https://user-images.githubusercontent.com/54589605/224235353-1f8a3541-53e1-4fd7-a120-39248264b69f.jpeg)

## Instruction: Part II (7) [10th March 2023]

![image](https://user-images.githubusercontent.com/54589605/224335986-2c929c38-617e-4e0f-88d3-e334af6573ca.png)
![image](https://user-images.githubusercontent.com/54589605/224337300-1b44e86b-9637-4092-b025-4b2f00bdfe55.png)
![image](https://user-images.githubusercontent.com/54589605/224337372-10dd2c9e-b01c-4877-b41d-e549ff456c35.png)
![image](https://user-images.githubusercontent.com/54589605/224338040-6233ced5-875f-40b6-8e77-7fde31fdd8e9.png)

> Continuation of the above question only. We found **1-address instructions** first then from the **1-address instructions** we found the **0-address instructions**.

![image](https://user-images.githubusercontent.com/54589605/224339214-daf369e2-5084-4f02-8614-47e5bc4e12d3.png)

* If it was mentioned in the question that **512** 2-address instructions, then how many **1-address instructions**? [Above]

![image](https://user-images.githubusercontent.com/54589605/224340950-4fb79f96-ab67-440f-8e96-a1ea4a8e9b79.png)

* **4096** is **exactly** 1-address instructions.

![image](https://user-images.githubusercontent.com/54589605/224341585-fc7d8d56-9b17-41aa-92fc-7598faca9212.png)

* Yes

![image](https://user-images.githubusercontent.com/54589605/224341312-d1c528fb-0472-46b3-a9f1-676c229de390.png)
![image](https://user-images.githubusercontent.com/54589605/224341662-5320976a-1d3b-430b-b4ea-48d5c86a9ef0.png)

* Yes. exactly.

![image](https://user-images.githubusercontent.com/54589605/224343003-69576f38-8df7-4846-8309-5f3794ecd281.png)

## Variable length instruction

* Opcode size is **fixed** in variable length instruction. Then, we will calculate total how many no. of instruction are supported of every type.

> For each type of instruction, the opcode length will not vary, it will be fixed(5 bits here). For each type of instruction, calculate total no. of instructions and based on that, calculate opcode bits.

![image](https://user-images.githubusercontent.com/54589605/224350378-044a91f2-92bd-42cf-8c18-f0aafa743bd5.png)
![image](https://user-images.githubusercontent.com/54589605/224352006-a43b66fa-28c7-41a7-8464-05afb6b1c79d.png)
![image](https://user-images.githubusercontent.com/54589605/224352440-5e651d54-fb73-40d2-87a2-0aeb0fbffea4.png)
![image](https://user-images.githubusercontent.com/54589605/224352528-c94b0bde-65f1-4288-a481-a02f9a4bca91.png)
![image](https://user-images.githubusercontent.com/54589605/224353132-800aff40-5cb4-497a-abfa-5f0ecc40f7a5.png)

* If that is the case then the length of instruction is **variable**, then it is a known fact that **length of opcode is fixed** for all instructions.

## Compiler

![image](https://user-images.githubusercontent.com/54589605/224354404-9668c566-4e76-4ed3-b982-56e9ca6ec633.png)
![image](https://user-images.githubusercontent.com/54589605/224354434-4dec1490-2a2c-4152-95d6-d6c0adc9ee0a.png)

> Compiler generates the **instructions**. It converts the code(c-program) to low level language which is understood by the cpu.

![image](https://user-images.githubusercontent.com/54589605/224354741-e2d50955-9c66-4d30-9f8b-f7e9a366aeae.png)
![image](https://user-images.githubusercontent.com/54589605/224355075-43f0d75c-c97a-488b-95a3-07a31da3d03c.png)

> Same code(C = a +b), but these **instructions(below)**, the compiler generates, based on whatever type of instruction these **architecture(below)** is supporting and cpu is understanding. Based on that the compiler will generate the instructions.

![image](https://user-images.githubusercontent.com/54589605/224355385-65e308ec-bf3e-4feb-92a8-fcaa135c019a.png)

* instructions

![image](https://user-images.githubusercontent.com/54589605/224355898-02da74ac-a8fb-44fc-9b74-7d5bde77f89b.png)

* Architectures

![image](https://user-images.githubusercontent.com/54589605/224356767-708b9046-c9dd-48ef-800e-9a243c6f7e7c.png)
![image](https://user-images.githubusercontent.com/54589605/224356801-a3e569d9-8c42-4ba3-aa95-b5af4aeb2fe2.png)
![image](https://user-images.githubusercontent.com/54589605/224359814-857e7efc-3ddd-4555-ab00-ecc571e42d4f.png)
![image](https://user-images.githubusercontent.com/54589605/224359839-1a823bf3-f0b4-4ae2-8fef-274182ddcae3.png)
![image](https://user-images.githubusercontent.com/54589605/224363073-3ca6bd3a-5ed9-4f54-b60a-9a2ffe71b474.png)
![image](https://user-images.githubusercontent.com/54589605/224363136-8ef5316d-0787-4a17-b515-865758ec5169.png)

## Register Spill

> If there are not enough no. of registers, then for temporary basis, register memory is kept in main memory.

![image](https://user-images.githubusercontent.com/54589605/224365405-12716e8d-aadd-4e22-b456-da2b8ef23397.png)
![image](https://user-images.githubusercontent.com/54589605/224364520-0cab4a9a-2aac-4fcd-ae79-4c5c575eb409.png)

* Register spill, highlighted with green.

![image](https://user-images.githubusercontent.com/54589605/224365540-1088acec-eb3d-439b-9ef8-10da8e5ed4cf.png)

> Here, if we have **3** registers then we can do the operations without any **register spill**.

![image](https://user-images.githubusercontent.com/54589605/224370714-de1c9e47-72b7-4972-bdc2-2ad869b6f46b.png)


* Add the yesterday's numerical photos from the copy. Both for digial and COA.



# Quizes

## Quiz-1

* Link -> https://unacademy.com/quiz/quiz-i/PPCBB9935H/solutions/SP_AAF34WLKY4HP0N2MV

![Quiz_1](https://user-images.githubusercontent.com/54589605/223939357-b43aeca8-d6c8-4cf3-a3fd-18f0636e1029.jpeg)


# PYQs

## Micro-operation PYQs

> From **5_MicroOperations_Part_II_with_anno** PDF file.

![Micro-operations_1](https://user-images.githubusercontent.com/54589605/223427084-6afe0579-c4b5-491f-a047-b7503c2df3ef.jpeg)
![Micro-operations_2](https://user-images.githubusercontent.com/54589605/223427089-cdfa699a-679c-4fab-883e-1ccb22ccf26b.jpeg)
 ![Micro-operations_3](https://user-images.githubusercontent.com/54589605/223427090-5d469c66-1f4f-406d-9650-c1125645e29e.jpeg)
![Micro-operations_4](https://user-images.githubusercontent.com/54589605/223427092-07b76ffc-3634-443e-a2b5-48f25bd0d080.jpeg)
