# COA


## COA Prerequisite

![image](https://user-images.githubusercontent.com/54589605/219703126-5838cf62-bbc5-41c3-aa64-5ecb4f5a3b23.png)
![image](https://user-images.githubusercontent.com/54589605/222415066-82eff0ab-07ad-417c-95de-2877f4003c13.png)


### Material

* Video 1 -> https://www.youtube.com/watch?v=syKlvr5a8yQ&t=72s [Completed]
* Video 2 -> https://www.youtube.com/watch?v=n7vehBgKZZo&t=3255s [Completed]

## Number System

* 10 -> Not a digit, it is a number, combination of digits
* 1 -> Digit

![image](https://user-images.githubusercontent.com/54589605/219703555-21d53b48-5b6d-45ec-8550-21a09d5a767f.png)
![image](https://user-images.githubusercontent.com/54589605/219704580-26a40f0d-0b3f-4c3e-991e-104e499d3668.png)
![image](https://user-images.githubusercontent.com/54589605/219704894-c30274df-9d7f-4a62-ac08-1ae471d1192c.png)
![image](https://user-images.githubusercontent.com/54589605/219707187-94a5b408-4f2a-4863-957c-4f6689f606ae.png)
![image](https://user-images.githubusercontent.com/54589605/219707482-c9f8735f-0ae2-4a1e-abce-eb3a63127326.png)
![image](https://user-images.githubusercontent.com/54589605/219707673-393ed120-cd47-49d2-864e-11d56703b4da.png)

* Base -> No. of digits, how many digits are used to represent a number.
* Binary -> Base 2
* Octal -> Base 8
* Decimal -> Base 10
* Hexa-Decimal -> Base 16

![image](https://user-images.githubusercontent.com/54589605/219708781-3fe5143a-ac4a-465f-8efd-eee0adef4c11.png)
![image](https://user-images.githubusercontent.com/54589605/219708821-673592bc-a99e-4dd8-9a88-cb40b2c1d972.png)
![image](https://user-images.githubusercontent.com/54589605/219709204-0ad1f924-b4e2-49a1-880a-2d01d8ee915f.png)
![image](https://user-images.githubusercontent.com/54589605/219709935-df35f230-e0fc-4be5-9c97-58e6d71cdeee.png)

### Binary to Octal

* Start from the **right side**.

![image](https://user-images.githubusercontent.com/54589605/219710635-c7d3d02a-8b29-44d7-88bb-ef7ab6d1575f.png)

## Hexadecimal to binary

![image](https://user-images.githubusercontent.com/54589605/219712212-25a99d92-9d63-42ab-a52d-ccdbfb348f43.png)
![image](https://user-images.githubusercontent.com/54589605/219712466-8ed2d6ed-2ad1-4aa0-ba06-149cafce8224.png)

## Binary to Hexadecimal

* Start from the **right side**.

![image](https://user-images.githubusercontent.com/54589605/219713506-80a9fdb9-1ad4-4f02-bbb0-adfe4de2dbe0.png)
![image](https://user-images.githubusercontent.com/54589605/219713548-9def2409-306f-4fe4-badd-170558757cd9.png)

## Conversion from Decimal

* Write the remainders from **bottom to top**.

![image](https://user-images.githubusercontent.com/54589605/219715084-9a4ba8e2-9c95-49c5-9bec-0f79c50fe7dd.png)
![image](https://user-images.githubusercontent.com/54589605/219715329-17c67c68-6e49-4af6-b8c1-33f0e4641c0e.png)
![image](https://user-images.githubusercontent.com/54589605/219715646-63266235-49f2-4990-a093-983b4360360e.png)
![image](https://user-images.githubusercontent.com/54589605/219715997-41189352-d401-45f3-b569-ee57272fbfab.png)

### Conversion of fractions to binary

![image](https://user-images.githubusercontent.com/54589605/219717094-d0be718a-ec96-4ec1-900d-1917d4eb38c2.png)

> Multiply the value with **2**, then whatever is on the left side of **point/dot(.)**, add it to **after the point part of answer**, if **1** comes then remove it before **multiplying** with **2** again.

![image](https://user-images.githubusercontent.com/54589605/219718043-fa01b2fb-b092-4d83-a0e1-677e2218014f.png)
![image](https://user-images.githubusercontent.com/54589605/219718381-a1f2a619-4abc-4c40-bffb-8db66b4948ec.png)
![image](https://user-images.githubusercontent.com/54589605/219718563-bb1c62f5-6094-4980-b79f-503df941abae.png)

![image](https://user-images.githubusercontent.com/54589605/219822467-ab1be341-8518-466c-adf7-0c5c7f97831c.png)

> Separately solve whatever is before the decimal point and separately solve whatever is after the decimal point.

* (5.75) base 10 -> base 2
* Solve **5** separately we get **101** which is the binary of **5**.
* Solve **0.75** separately by multiplying it with **2** ie. **0.75 * 2 -> 1.50**, we take the **1** and again multiply **0.5 * 2 -> 1.00**, we take the **1** again. The answer for **0.75 -> 11**.
* (5.75) base 10 -> (101.11) base 2

## Binary to Decimal

![image](https://user-images.githubusercontent.com/54589605/219822764-6da68cc4-7eec-405f-876b-4c5a807d7ff4.png)
![image](https://user-images.githubusercontent.com/54589605/219822841-ef7779b4-a27b-48ec-8127-265101fa02bd.png)

> For the values after the **decimal pointer**, start from the **decimal pointer** and go **right**.

* (0.10) base 2 -> Base 10

> We will first do **1** as it is closest to **decimal pointer**, **1 * 2^(-1)** and then do **0** ie.**0 * 2^(-2)**. 

* 1 * 2^(-1) + 0 * 2^(-2)
* 1/2 + 0
* 0.5 [Ans] 

![image](https://user-images.githubusercontent.com/54589605/219823222-33545d0e-d193-4940-bc30-652fa1c6ba78.png)
![image](https://user-images.githubusercontent.com/54589605/219823242-ba0d6dde-566d-4a48-900d-cc7afa2d3254.png)

## Decimal to Binary

![image](https://user-images.githubusercontent.com/54589605/219823476-c92c5dc7-58d2-4d94-b97c-37bd90d20f92.png)
![image](https://user-images.githubusercontent.com/54589605/219823522-0cb8b795-cbab-4695-bcf3-9ce40b980019.png)


## Decoder

> It takes input as **binary combination** and generates only one result as **enabled means one(1)**.
> Based on the **input combination**, only one output will be **enabled**. Only one output will be **1** and the rest will be **0**.

![image](https://user-images.githubusercontent.com/54589605/219823706-ab8dff21-fbae-4d0e-8117-58ae54118092.png)
![image](https://user-images.githubusercontent.com/54589605/219823758-7ee55bd5-0d75-40e5-a34b-69b48bfeb2e3.png)
![image](https://user-images.githubusercontent.com/54589605/219823813-854543e8-105c-4dc0-ae64-76a04a58f62e.png)
![image](https://user-images.githubusercontent.com/54589605/219823856-5136d80d-bcf6-4986-9da1-a0623615de81.png)
![image](https://user-images.githubusercontent.com/54589605/219823935-f5df5254-a9bb-4e00-9b86-0c0e4754a148.png)

## Multiplexer

> It selects one of the multiple inputs as output.
> It will only have one output always. It is different have decorder. Decorder can have multiple outputs, so many outputs but only one will be enabled.
> Whatever **inputs** we are sending to the **multiplexer**, that only will be taken as the **output**. Whatever input we are sending to a **multiplexer**, we are getting it back as the **output**.

![image](https://user-images.githubusercontent.com/54589605/219824148-2e0818c5-1502-4d22-b5de-f587a854fa69.png)
![image](https://user-images.githubusercontent.com/54589605/219824169-40e1e64c-522c-4378-8c9d-4cccd66c53ed.png)
![image](https://user-images.githubusercontent.com/54589605/219824179-e14ccab5-fc04-46e0-a089-562d2d26e8da.png)
![image](https://user-images.githubusercontent.com/54589605/219824366-6349d1e9-e715-4fad-939e-b025c001ce69.png)
![image](https://user-images.githubusercontent.com/54589605/219824765-33ed818a-2513-44ca-af0b-88d21bcc445a.png)
![image](https://user-images.githubusercontent.com/54589605/219824815-51994d74-a6f9-43a1-9a7b-c92a3c1549a2.png)
![image](https://user-images.githubusercontent.com/54589605/219824826-75134019-8108-4524-9785-77b139575c5f.png)
![image](https://user-images.githubusercontent.com/54589605/219824866-9dd6598d-e2ee-4307-b8e6-1e990fadd94b.png)


# COA

## Syllabus

![image](https://user-images.githubusercontent.com/54589605/222424846-0f6c97f9-1eed-4867-a1f3-719dfb004a65.png)
![image](https://user-images.githubusercontent.com/54589605/222425568-fcbe88e0-f315-43d0-a943-7709897c9968.png)


## Routine

![image](https://user-images.githubusercontent.com/54589605/222414532-a1bc4710-5af8-4580-af54-980475cdda3f.png)


* Course Link -> https://unacademy.com/course/complete-course-on-computer-organization-architecture/SFZXXJRP

## Basics of Computer Systems (1) [2nd March 2023]

![image](https://user-images.githubusercontent.com/54589605/222416710-8b5eed31-e7e2-495c-8ee6-1e2f3cec5dfb.png)
![image](https://user-images.githubusercontent.com/54589605/222417377-ef6c95c8-28f1-4ac4-9ee0-0f7eac37c841.png)
![image](https://user-images.githubusercontent.com/54589605/222417697-aa8c5fd0-cff0-4668-a1cd-a976ab7ccda7.png)
![image](https://user-images.githubusercontent.com/54589605/222417874-227000a7-45b3-474b-9fa1-7412c9f5cc92.png)
![image](https://user-images.githubusercontent.com/54589605/222418834-411bb0f0-aec8-4b9e-b257-cd356a8d774b.png)
![image](https://user-images.githubusercontent.com/54589605/222418919-7218e17f-df4a-4cc5-a8b0-3489c714a3a8.png)

* Micro processor -> CPU [Every is separate hardware, CPU is separate hardware, Memory has separate hardware and other devices are separate hardware as well]
* When we have single chip with memeory also and other devices on that chip only, that chip is called as the **micro controller**.


![image](https://user-images.githubusercontent.com/54589605/222419701-6526516e-a9f7-4e32-8f8d-3b20ec37732a.png)
![image](https://user-images.githubusercontent.com/54589605/222419845-47ef2fff-c2ff-4e64-b150-63949bd33632.png)

* CPU works on **Binary Number** system. 
* Data Format -> The data which comes to the CPU, how the data is represented(Binary, decimal, etc) in the CPU.

![image](https://user-images.githubusercontent.com/54589605/222420951-b871fb4f-edac-402a-a79c-d2034d4b03e5.png)
![image](https://user-images.githubusercontent.com/54589605/222421650-4fbad66b-f63c-4a4b-ba30-e233d9b489e0.png)

> When we try to make a computer system, we first decide logically what kind of design we want to have of the computer system i.e that is **Architecture** basically. When we try to implement it, we will be having the **Organizational** part coming into the picture. The **organization** says whatever **physical devices** we have decided in the **Architecture**, how will the physical devices be made.
> I have decided that I will teach a kid **multiplication**, that **decision of teaching, multiplication** to that kid is **Architecture** part. How will I teach **multiplication** to that kid is **Organization** part.

* Decision of teaching, multiplication -> **Architecture** part [Decision, what to do]
* How will I teach **multiplication** -> **Organization** part [Decision, How to do]

![image](https://user-images.githubusercontent.com/54589605/222424254-f491be35-622a-47c1-91c0-d2bf01c459ef.png)
![image](https://user-images.githubusercontent.com/54589605/222424288-d0e87ae5-577c-49ac-a6c6-f238e77102ba.png)
![image](https://user-images.githubusercontent.com/54589605/222424398-18d8cf26-a5c6-40e6-8969-d3e8c1f37535.png)

* Microprocessor is a special type of implementation of COA.

[**IMPORTANT**]
![image](https://user-images.githubusercontent.com/54589605/222424549-b3f47b87-ded1-46cb-8387-1f2e68b94340.png)

[**IMPORTANT**]
* After 2008, **microprocessor** is removed from the syllabus. Don't learn it and ignore the PYQ questions as well.

![image](https://user-images.githubusercontent.com/54589605/222424796-46b1970e-0a2d-49ad-b739-7e3d4126797c.png)

## Data In Computers

![image](https://user-images.githubusercontent.com/54589605/222427069-4be83cb3-a459-4e74-95b1-c7d924531c71.png)
![image](https://user-images.githubusercontent.com/54589605/222428365-1af0e0f0-d93d-42b1-908d-9b1cc7912696.png)


## Componenets of Computer

![image](https://user-images.githubusercontent.com/54589605/222429183-b2e5940f-c018-4608-b9c7-03df75fa0a12.png)

* ALU -> Arithmetic Logic Unit -> Arithemic, logic type operations are performed here. -> **Husband**
* CU -> Control Unit -> Controlling the entire computer system hardware. -> **Wife**
 
 > They are the **couple** of the house.

![image](https://user-images.githubusercontent.com/54589605/222432203-3ead5c4b-9026-42cf-be9c-b5ee4944e3c2.png)
 
### Other Componenets

### System bus

![image](https://user-images.githubusercontent.com/54589605/222433831-eb07b9e8-5c58-4b72-b987-5e541107712d.png)
![image](https://user-images.githubusercontent.com/54589605/222433927-2ad40f05-67fa-4997-bfac-808a2f517e8a.png)

> The single Communication/Connection line like a single wire can take **one(1) Bite(Either 0 or 1)**, it can carry **one bite** at a single time, from **CPU to Memory** and **Vice-versa**. It is **bi-directional**. If we want to send **more no. of bytes**, then we need more **single lines or wires**.
> If we have **5 lines** then we can **transfer 5bites** of data at a time. 

* Bus -> Collection of communication lines single-single lines/wires.

![image](https://user-images.githubusercontent.com/54589605/222434488-943004a5-f8e7-46c4-b6fa-64356992f07e.png)

* We make different types of busses, **what type of content that bus is carrying** or **for what purpose the bus is being used**. Based on these, we are deciding **different types of buses**.

### Types of Buses

1) **Address Bus** -> Only take the address from one place to another. -> **Uni-directional**.
2) **Data Bus** -> Only take the data from one place to another. -> **Bi-directional**
3) **Control bus** -> Only take the control from one place to another. -> **Bi-directional**


> **Control bus** -> It contains the **control signals**. Control Signal is send so that other devices understand what does the device want. Control Signal are signals which tells other devices, what to do. 

![image](https://user-images.githubusercontent.com/54589605/222437273-04cb9a5d-7c53-4aed-ae2b-f05a2ea5b179.png)
![image](https://user-images.githubusercontent.com/54589605/222438049-0ca32f7f-e0c6-4b8e-9b9e-d47bbf139848.png)

## Memory System

![image](https://user-images.githubusercontent.com/54589605/222438767-7abf9d8b-02f0-45f9-a7a7-ec38f080cce2.png)


## Registers and Memory Address (2) [4th March 2023]

* The basic reason for providing the address is that the CPU has to give some address or send some address to memory, and the memory will understand, where the CPU wants to do some operation(read, write etc). **This is the basic reason for providing address to each and every cell**.

![image](https://user-images.githubusercontent.com/54589605/222869679-12b4996c-a211-479e-91cb-1c0528ac099b.png)

> If CPU wants to select any particular cell then the CPU has to inform the **memory** by providing the **cell number i.e the address of the cell**. If CPU wants to send **the address of the cell** to memory, **the how will CPU send the address to memory?**

> Through **Bus**, Which Bus? -> **Address Bus**.

![image](https://user-images.githubusercontent.com/54589605/222869858-4e9a78d4-f794-41d0-b664-acebf6c241a8.png)

> If CPU wants to perform **read and write** in memory then it will send **the address of the cell** in a given range(0-15) here to memory i.e CPU is selecting that particular memory cell and wants to perform **read and write** operations there.

![image](https://user-images.githubusercontent.com/54589605/222870027-3d496553-12ab-4bc3-80b5-cab47cf07c2e.png)

### Memory operations

* Read
* Write

* Control Signal -> It is a signal which is used to inform to **memory**, what type of **operation** CPU wants to perform on memory.

### Read operation

* Enabled -> The signal is **tuned on i.e Carrying 1**.

> When CPU performs **read** operation, cpu has to send **two information** to memory, **one is address by address bus and one is control signal i.e read through control bus**. Memory will send data back to cpu through data bus.

* **tuned off i.e Carrying 0**.

![image](https://user-images.githubusercontent.com/54589605/222871379-c7745a0a-38fd-4da3-b46f-04923f756a8d.png)
![image](https://user-images.githubusercontent.com/54589605/222871436-48e3515e-98b3-4712-bc56-3795496d96fd.png)

### Write operation

> CPU sends **data** to memory through **data bus**, whatever data CPU wants to **write** in the memory. That data also CPU will send.

![image](https://user-images.githubusercontent.com/54589605/222871828-680bc636-cfa4-4d9a-815e-5be464ed2b28.png)

>  When CPU performs **read** operation, cpu has to send **three information** to memory, **one is address by address bus, one is data(content) through data bus and one is control signal i.e write through control bus**. Memory will accept the address, go to the address, whatever content cpu has send, memory will accept that and perform a **write** operation on that given address.


> In Both **read and write** operation, one thing is sure, cpu can send **enabled read/write** signal to memory, only when the memory is ready. There are control signals between memory and cpu. Memory is sending those control signals to cpu.

* The control signals are:

1) Ready
2) Busy/wait

![image](https://user-images.githubusercontent.com/54589605/222872994-8b1fc007-5fe9-4a98-b3d0-3a5128deceb7.png)

> As soon as cpu has send a signal to memory to perform read/write. What happens that memory will perform that operation and immediately as the memory accepted that signal of read/write, memory will **enable** that **busy/wait** signal.  **Busy/wait** signal will be **enabled or 1**. **Ready** signal will be **0**.

![image](https://user-images.githubusercontent.com/54589605/222873284-4e689a8e-cc5c-4e04-adb2-36476338b775.png)

> As soon as memory operation is over, **Busy/wait** signal will be **0**. **Ready** signal will be **1**.

![image](https://user-images.githubusercontent.com/54589605/222873317-b441f51d-f06a-4eb6-8934-47b1e5b8d621.png)


## CPU Registers

> The work of the cpu is to perform the operations, to execute the program, to execute the software.

* CPU registers are small memories inside the cpu.

![image](https://user-images.githubusercontent.com/54589605/222873484-de0fb589-5c78-44d6-8ee8-f92d59c7d728.png)

### Types

1) General Purpose Registers(GPRs) -> Any general data
2) Special Purpose Registers -> Special content/data. Very specific.

![image](https://user-images.githubusercontent.com/54589605/222873599-6938ac27-5193-4ee5-a963-5a23f73f875c.png)
![image](https://user-images.githubusercontent.com/54589605/222873638-2f899fa5-d77b-43c6-b9c9-43c45d3be61d.png)
![image](https://user-images.githubusercontent.com/54589605/222874085-35b645d4-db28-4eb3-9267-597ebecc3319.png)


## 1. Accumulator

* ALU -> It need **two** inputs and it generates the result.

![image](https://user-images.githubusercontent.com/54589605/222874263-ef77487a-dc3d-45d0-903c-971ba0667977.png)
![image](https://user-images.githubusercontent.com/54589605/222874329-a3c84a66-44f8-42a3-8550-b67042556488.png)

* One input should be taken from **accumulator** only. In ALU, only first input taken from Accumulator only that is fixed.


* These two designs are called as **architectures** of cpu based on **ALU** input. Or **Accumulator based architecture**.

![image](https://user-images.githubusercontent.com/54589605/222874504-37aefa34-909f-45cf-9969-19b53380998f.png)

* Based on from where the **two** inputs are coming to **ALU**, based on these we have different achitectures.

## Types of Architecture

* In every architecture, the result always comes to the **Accumulator** first.

![image](https://user-images.githubusercontent.com/54589605/222874573-78cf8d88-90be-475e-b1eb-3745b2e099c7.png)
![image](https://user-images.githubusercontent.com/54589605/222874651-37ccb6bd-f51c-411e-be17-2caa0c48767b.png)

![image](https://user-images.githubusercontent.com/54589605/222874768-ee23a81f-05f2-409f-a20a-428d0d2f6b65.png)

> As, **a and b** values are stored in memory, hence we have to first take the values from memory to some **genenral purpose registers(R1, R2)**. After that we can perform the **addition** operation.

* In Register-based architecture, if we want to perform any **ALU** operation on any values, both values are to be present in a **genenral purpose registers(R1, R2)**. If not present then we have to bring it first. First we have to bring the values into **genenral purpose registers(R1, R2)** and after that we can send them to ALU.

![image](https://user-images.githubusercontent.com/54589605/222874999-ac0220c5-8fdb-437d-a71f-bed47c9c13fd.png)


* Register-Memory Base Architecture -> The first input is fixed/restricted to **Genenral purpose registers** only. The second input has flexibility i.e it can be choosen either from **memory or Genenral purpose registers** depending on the condition or requirements. 

> **By default**, we have fixed the first input to *Genenral purpose registers** only. If we have to perform **a + b**, then **a** should be in a **Genenral purpose registers** and **b** can be in **memory or Genenral purpose registers** my choice but **first input is fixed**. This is the **default one**.
> In the questions they will **reverse it**, to **confuse** us.

[**Default**]

![image](https://user-images.githubusercontent.com/54589605/222875552-27e330dc-6524-4ea5-bafe-b64b329aa5f9.png)


* Complex System Architecture -> More flexibility. Four combinations/options available. 

![image](https://user-images.githubusercontent.com/54589605/222878099-0cfd032f-636b-4991-92cc-758922d0e5d8.png)


* Stack-based architecture -> Not in the syllabus. Jurt remember the drawing and nothing else.

![image](https://user-images.githubusercontent.com/54589605/222878127-3c4cd467-ed89-4dc9-af47-5fe3b6b8ce76.png)


## 2. Program Counter 

* It is just a pointer which will store the address of the memory, so that the cpu will know whatever program we are running, if current instructions are  completely executed then next instruction we will get from which address in the memory.

![image](https://user-images.githubusercontent.com/54589605/222878482-4b13fa66-ec75-4c69-aa75-589366e88f79.png)

## 3. Instruction Register

![image](https://user-images.githubusercontent.com/54589605/222878570-e33746da-1951-46c8-b94f-365f837fb69f.png)

* To store the current instructions, cpu has a very specific register called as the **Instruction register**. It stores the current instruction to be executed. Whichever instructions cpu brings from memory that instruction is stored in IR. The **viva chair** is the *Instruction register**.


## 4. Stack Pointer

* Stores the address of the top of the stack.

![image](https://user-images.githubusercontent.com/54589605/222878875-70335b45-ad2e-4c03-888a-86efc03037f7.png)

## 5. Flag or Status Register

![image](https://user-images.githubusercontent.com/54589605/222878989-b0fe9286-079e-4640-8960-c4ab040fa357.png)

* Carry is nothing but extra bit or extra result we have or not.
* Status of the current result we are generating.

* S -> Sign [Negative or positive]
* Z -> Zero [Zero or not]
* Ca -> Carry [Carry or not]

![image](https://user-images.githubusercontent.com/54589605/222879079-42bd3563-e4dc-4d74-b2ac-2a6dec5d7911.png)
![image](https://user-images.githubusercontent.com/54589605/222879099-e4ba3399-cd85-428b-9fbf-6c8af2a71f33.png)


## Address Register or MAR

* Used to send address to memory

> Cpu wants to do read/write operation in memory, cpu has to send address to memory through address bus. **Bus stop** in the cpu for address bus is **Address register**.
> If cpu is having any address which cpu wants to send to memory through address bus. First, cpu has to bring that address to **address register**. If cpu wants to send any address to memory through address bus then first cpu has to bring that address to **address register**. From **address register**, address bus is connected, that address goes to memory.

![image](https://user-images.githubusercontent.com/54589605/222879537-6ffd32ca-73c6-4711-aa31-297d9a96e587.png)


## Data Register or MDR

* Used to send data to memory -> Memory **write** operation
* Used to receive data from memory -> Memory **read** operation -> Data is coming from memory to cpu

![image](https://user-images.githubusercontent.com/54589605/222879676-395e5355-72d1-43f9-ad4a-f7766214cefc.png)

![image](https://user-images.githubusercontent.com/54589605/222879733-135a8053-7b37-49d4-a479-e10861f7ccec.png)

> **Current**

![image](https://user-images.githubusercontent.com/54589605/222880025-fe74dc2c-d582-487d-8ca0-36b5536e869d.png)

* It will be given in the question.

![image](https://user-images.githubusercontent.com/54589605/222880003-815ccc33-4646-47a7-837b-2401526f62dd.png)

* One(1) instruction is -> 2 bytes (Taken her)


### Questions

* If nothing is mentioned about **memory** then it is **byte addressable** by default .

![image](https://user-images.githubusercontent.com/54589605/222880526-0beb55ca-046a-4f9a-a6e4-404c460a6bcb.png)
![image](https://user-images.githubusercontent.com/54589605/222880612-da236703-b519-4bf4-958a-8d38f99ba02f.png)

> When **I120** has gone for execution, PC Or program counter will hold the address of next instruction or **I121**. The value will be **976+4 -> 980**. PC Or program counter will point to the next instruction.

![image](https://user-images.githubusercontent.com/54589605/222880683-a8e28e1f-11b3-4fd9-8ca2-496e19a580dd.png)
![image](https://user-images.githubusercontent.com/54589605/222880767-0fd476a4-ac6c-42bd-b972-e419128e1b09.png)
![1_registers](https://user-images.githubusercontent.com/54589605/222881338-c143d85e-5473-4e96-9f00-a1e2883e0f38.jpeg)






