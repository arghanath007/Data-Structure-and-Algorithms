## sorting-techniques-part-1 (13)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3df430f2-f21f-4c22-8fb2-fc5043ee6ac3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc22615f-a6bb-4a9d-a7d6-a221e0f5cb2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0de6704d-1ae7-49b1-98c5-117d2209c4f4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/196fa97b-754d-43e6-80d4-9bcf59a2e31f)

* This is series for the function of **log n**.
* Option **A**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c115cec-de66-403e-ac5f-235e80b978a5)

* Polynomial equation cannot be **negative**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a73eb84-0cdf-4d92-9e3f-26d567dc4db8)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9bf96de-8f9b-435d-ad5a-42c2facfbb91)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f2ae5786-4495-4f4c-866c-6c5f4655c0f8)

* option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d578eac5-a7c3-4075-ae77-77f2fb5b07cb)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08c608ee-ea04-4cc5-8a95-15c5e7151e69)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/046aa980-31c9-4dea-a11a-a64322a5b4f4)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f7b81b7-de6c-43ff-b1da-9aad6d548eb3)

* We cannot apply **master's theorem** here because this is **substract and conquor** and in that **f(n)** should be a **polynomial**.
* We have to use **iteration method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2cfdccf6-0a17-4f74-a976-b558c6e6c038)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac72f974-f2d6-4f9c-bfb2-9849785d5dd1)

* For **n!** the equivalent higher to it is **n ^ n** even though **n ^ n** is **greater** than **n!**.
* If **n!** is not given in the **options** then we can put **n ^ n** instead of **n!**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/784f82ce-7d70-4a70-8710-eb5b3f10dac0)

* So we can go with **n * log n**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2d72af2-783f-4aa3-a73e-d94e9968ac66)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dcac8a6-c322-418e-82eb-7979038298e4)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ada83043-4099-45e9-a8f1-36c60a7afcdd)

* We have to use **tree method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7c2c2dbd-e62e-437b-b819-c616cef3c149)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1295861a-02fa-4a10-b0d1-0af8696e64fc)

* As the addition of **n/3 and (2 * n)/3** gives us **n**, so we can say that the answer is **n * log n**.
* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f4860e4-8b6b-41c0-b02a-911af55d5451)

* **n** is the **cost**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2c2ed47-e2c0-47de-bb51-d000f1880fb3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1b96b879-7cc6-4d02-863e-a803cc1c0f40)

* In the series we are multiplying with **GP** then in the series then value of **r** is **9/10** which is **less than '1'** so we can ignore the **series** and we can take **n**. So ultimately the value will be dependent on **n**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfe85a69-122c-4522-8b2b-b489e5475627)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b13c5063-2595-4754-98d1-4d7a70f8325f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0080df1-b69f-4fae-a636-246b38b68fc1)

* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0b705a9-4a7d-4dd0-8d3e-0c94cb1dcf34)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88447a06-8f60-4628-8f7d-4d245abcb531)

* Option **A** [Already done in last class]
* Solved using **tree method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c191b97b-bef2-413b-bdf1-1ed222961047)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36821aac-cbc9-4ea6-b918-96960fcad8a9)

* Example
* **Base terms** do not alter or have any effect on the **complexities**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7bcc171-3b91-43c6-ad3a-36066680e022)

* log [Formula]

## Space Complexity

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38503259-5416-4b42-b89d-92ea2f62994d)

* **Space Complexity** is dependent on **auxillary space**.
* Whatever **parameters** which we are passing to the algo all those fall under the **input space**.
* CES -> Code Execution Space -> Variables, data types, etc.
* DS -> Data Space -> **Stack**.
* The **auxillary space** is dependent on **Data Space and Code Execution Space**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6a8e12b-a65d-4408-b40e-202c93ee5acf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/efbd9502-1337-4d5a-92b0-653a72924b64)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ab8f0346-e366-4f43-bfd7-41f97592d3ca)

* For **Sequential and Iterative** algorithms the **Code execution space** is always **constant(1)**. It is **fixed space**.
* For **recursve algorithm**, the **Code execution space** increases.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fc2e8cc-37a0-42c5-9963-35ce881a08b3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/892fcd79-3662-41aa-a2e5-c2eb23bbafd3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6fedee09-fb08-46cc-a3da-64c10eb99549)

* Time Complexity -> O(10) -> O(1) -> Constant. [n -> 10]
* Loop will run for 10 times.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1dd2f54-2914-4335-b3e4-036d752e8b6d)
 ![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88a9b4de-f280-43d6-9ac8-6ebfc9bcc277)

* Example.
* Time -> Theta(n)
* Space -> 3 * n -> Theta(n). [For storing all of the 3 Arrays(A, B, C)] 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23fe755d-56a5-4065-b11a-aaff7cab9e37)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/61fccd7f-7036-44c5-b74f-5ff23cccccc5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dcebca39-7d6d-4ac3-9687-ded8c4154ab4)

* Example.
* Time -> Theta(n ^ 2)
* Space -> Theta(n ^ 2).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5a6f186-fae7-4b7d-90e4-b90e761e0050)

* **CES** is **constant(1)** since there is no **recursive algo**. Until **recursive algo** comes, **CES** is **constant(1)** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99e71eb6-2639-4b5f-b0d7-db80a33767dd)

* The **time and space** complexity for the whole program will be **constant(1)** because as we know that the program will run for **8 times** which is **constant times only**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19354baa-f91c-4743-bb43-8a4f68bb8a3d)

* Solution.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c8362924-adce-4994-8cb2-ce3e1550d48a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e40a892b-be92-418e-91ee-e1b335e35c57)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f04041c-d04d-46aa-8ba4-8c381e7f4187)

* Height of tree is **n**.
* Time and space is both **Theta(n)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b2fa0164-119f-4710-8d98-09d60891699a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1e9f6a20-02bd-43c7-a8f6-2865795cae22)

* Time Complexity -> Theta(n ^ 2).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be15709a-d7ab-43c1-9179-28c5e374dd59)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ccd66ec-0980-4832-9313-563ee5ba80ce)

* Space Complexity -> Theta(n). [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f539356d-1259-4604-8391-57fe5e507b47)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81d84221-6b1d-4c16-ae1a-7bf8686e3537)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abdd18d1-5665-40ec-87d7-ecff0bc576ec)

* The value is getting **halved** everytime the function is being called so it falls under **log or logarithmetic** time.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1c4e4ee-3702-49d2-8e4b-0d8300d37101)

* There is no **data space** as it is **constant** and everything is coming from **CES**.
* Solution [**IMPORTANT**]

## Sorting Techniques

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/31549e05-3565-48de-933a-73caed0a6cf1)

1) Bubble Sort
2) Selection Sort
3) Insertion Sort
4) Quick Sort
5) Merge Sort
6) Heap Sort
7) Radix Sort

* Comparision Based.
* Counting Based.
* Substract and Conquor
* Divide and Conquor
* Tree Based.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd5d0ddf-cd19-4545-b92e-bdb95221b5f5)

* Bubble Sort.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c8972d3-1aaf-4d14-89b9-389ede4b3882)

* Complexity [Type of Question]
* No. of swap operations are performed here? [Type of Question].
* No. of comparision are performed here? [Type of Question].

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4165f8e8-82d5-497b-9eca-2fb96b0792c8)

* **Swaps** are not fixed they vary from **min to max** which is from **0 to (n * (n - 1)) / 2**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c55c63b2-2b27-4d74-87d2-cc56caa19f68)

* Question
* n -> 5
* Comparison -> n * (n - 1)/2. [Formula] [**IMPORTANT**]
* n * (n - 1)/2 -> 5 * 4 /2 -> 10

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2da26ab9-aeed-4cb3-88c9-b75c7766309e)

* example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fff55931-15e1-43aa-b670-d6a2b5dc48ed)

* [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a30a4065-387c-45f4-91ae-53ffd167aba8)

## searching-and-sorting-techniques-part-2 (14)

* Video started from the **middle**, recording issue.
* BC -> Best Case
* WC -> Worst Case
* AC -> Average Case
* **CES** is constant(1) for every **iterative algorithm** case.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/14d6849f-343a-435f-98bf-be281b1385f1)

* Space Complexity is dependent on **CES** as it is a **recursive algo**.
* The stack will go **max to 'n'** elements as there are **n** elements in the array.
* So **CES** is **n**.
* **DS** is **constant(1)**.
* So the **Space Complexity** for **recursive algo** is **theta(n)**.
* So the **Space Complexity** for **iterative algo** is **theta(1) or constant**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b44c7920-2875-4124-b276-fccf64a45f94)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84047eed-f86a-4b87-a841-665d28757c80)

* Recursive Algo.
* Bubble Sort -> Complexities.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9bad2e1c-159f-4e57-ad59-5d64d9f30aa8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16e839cf-aae1-4d9e-9c6a-9d8d3429e257)

* In-place and Outplace Sorting Algorithms. [**IMPORTANT**]
* For an **algo** to be an **in-place** algo the **data space(DS)** needs to be **constant or Theta(1)**.
* For an **algo** to be an **out-place** algo the **data space(DS)** is **not constant**.


![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d30f04b-3dcf-4d60-9f51-b8c288213b9f)

* In **bubble sort**, the **data space** is **constant(1)** that why it is an **inplace** sorting algorithm.[**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75c76031-c022-4e23-b937-018d863eadef)

* Build-in sorting methods -> Sort(), Sorted().

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6caca9e-f2fe-4e2b-a20d-d3087dd5ccf9)

* Sorted()

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f4e9dec5-020a-4c8d-8ba8-f6af71a116ec)

* Whatever we give as **input**, the **output** is always in the format of **list**. The **list** is in **sorted sequence**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1bd81401-bccf-4362-be23-6c2743322ee3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6fb2770f-0241-4057-9c95-1fc7c1ff404d)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abe17573-6328-4f39-a8d4-4d940b403e9b)

* Sort().

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/adeefd84-0e37-4e79-9026-9870e439b25e)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c710a56c-bd90-4007-bd52-8410704fab83)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c57ae4a6-9355-4e91-a268-cb0973f833e8)

* Difference [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1177868f-1ffa-4114-9787-af87942dd33b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d7323184-48e3-4793-9202-f72c59c7af7c)

* Example.

## Selection Sort

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/536a4606-dad6-4b51-9038-944815364ce4)

* Selection Sort.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d6049f0-6a16-440e-a938-3069ceb257ef)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e478a93-6ec2-4073-9eba-2d01f90c9df5)

* No. of comparison did we do?

> The **no. of comparisons** we are doing still is **n(n-1)/2**.

* Complexity -> Theta(n ^ 2). [In all of the cases] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44c7cd7d-a78e-4618-ac9c-56e510cc1865)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9dc0209b-430a-435e-a89c-944c02eadb44)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e7c906a-6599-4db2-95ab-be3b6c19c67d)

* n -> Total no. of elements.
* Swaps and Comparisons [**IMPORTANT**] 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d8a1964-1166-4c2f-a91c-b019af1fdba5)

* Calculating **no. of swaps**. [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30c5cde3-1177-45df-b54a-1e4909660f2c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/03d12206-7ebd-40c2-9633-1d14836ecec6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2742c3ad-8a30-4db8-914a-5d897862efab)

* **No. of swaps** -> 3. [**IMPORTANT**] 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3f484063-3a79-4f33-a6a1-c6a767423c6d)

* Selection Sort complexities.
* It is an **inplace sorting** technique because **DS** is **constant(1)**.

## Insertion Sort

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6cd8401-95b3-4715-a739-dc4978522738)

* No. of comparison -> n(n - 1)/2
* Complexity -> Theta(n ^ 2) [**Worst Case** of Insertion Sort]
* The **insertion Sort** algo depends on the way we have **taken the input**. [**IMPORTANT**]
* If input is in completely **descending order** then it gives us **theta(n ^ 2)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9aeecbbc-5f19-4fb5-adf9-eb80e7849ef7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aafbcd8b-911b-4abc-a171-5383c9329d56)

* **Input** is **ascending order**.
* We have **n = 5** elements so **no. of comparison** is **n-1 -> 4**.
* Complexity -> Theta(n) [**Best Case** of Insertion Sort] [**IMPORTANT**]
* The **complexities** varies in **Insertion Sort**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd1cf929-3c37-45c1-9fd3-764e29acda74)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/691a9ede-4fcd-4c3a-9de2-fe4cdf2fa5ed)

* Find **no. of comparison** using **insertion sort**. [Question]  [Example]
* **No. of comparison** -> 3.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/232c37f4-e026-4276-8787-a71bed57953d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b47850c0-7a6f-469f-b0f6-50d4dd7d86f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7fd74c8-8541-466e-86f9-d7055c56aea0)

* Insertion Sort complexities [**IMPORTANT**]
* It is an **inplace sorting** technique because **DS** is **constant(1)**.

## Merge Sort

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/668ff4d7-81a6-4b50-b88c-66ad2f2728a2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/961d23b6-122f-4ad3-97ad-10f8986029d0)

* Divide and Conquor

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc265f47-2cc6-4576-bcaa-cb19fac65597)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d302e844-7f79-4e0d-973f-a0134e6ae17e)

* Merge Sort

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad2f26f4-87d1-480f-8f98-41d5ff3b29a6)

* Example.
* **Merge sort** depends on the **merge algo**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83d171b0-353d-4c63-a816-a0ff319e5475)

* x -> No. of elements on the first array.
* y -> No. of elements on the second array.
* No. of comparisons -> x + y - 1 -> Theta(n).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2721535-45a2-4958-851b-8a8f057828f8)

* So the **merge sort** complexity will be dependent on **n** only which is Theta(n).
* Recurrece Relation.
* Using **Master's method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98f0271b-8002-45e4-af9a-e452e5444ff7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d6b96c8-22af-4aa1-aa5c-c8ca596f00f5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6cd752de-69aa-454e-88a6-1c6783f38948)

* This is for **all cases** in **merge sort**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a4821fa-cf49-41b1-ac75-f8c096a5e8c8)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a3eb106b-9cbd-4452-92b2-e4fb124eb92e)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b1e52da-6dfa-44f2-9380-fdfa82187786)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/730863e7-fd71-4e6a-9f11-25a24f9cd15d)

* Merge Sort Complexities.
* In merge sort the space complexity is dependent on **DS** as it is not **constant** here it is **n** here in merge sort.
* It is an **outplace sorting** technique because **DS** is **not constant(n)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1dd1480-98a5-487a-ae3e-bc5d549fd922)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac67c1af-826b-4949-aa90-6212db0ef0f0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/69524bd9-a6f0-42d4-95fd-ed01f4d65047)

* In **space complexity** if we are creating a **tree** then the **space complexity** is **equal** to the **max. height of the tree**. [**IMPORTANT**]
* It is **logarithmetic** growth of **log n**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f30ab28a-9990-4f97-ab73-2426f89c7d43)

* This is **linear growth** of **n**.

## Quick Sort

* We have to scan from **right to left**.
* After **swap** increase the position of **left pointer** with **+1**.
* When the **position** of **left and right pointer** have crossed each other then we have to stop the **algo**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/91b05492-b8ef-4385-9ca1-618acecc7d28)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16474389-621c-48c1-97f6-d48b281af9f2)

* This is the work of **Partition Algorithm**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a690245b-2450-4d63-99d7-523cc29d3dc1)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/458c63e8-b042-4d82-b92d-99e0eabe6a09)

* Complexity -> Theta(n * log n) [Best Case for **Quick Sort**]
* If **pivot** is the middle element of the array. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe5e6c26-0871-4c61-859f-5eef265deeb1)

* Complexity -> Theta(n ^ 2) [Worst Case for **Quick Sort**]
* The elements are in **ascending order**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3558ad52-4ee8-4c2c-8b1f-1a3a01e97dc2)

* Complexity -> Theta(n ^ 2) [Worst Case for **Quick Sort**]
* The elements are in **descending order**.
* In **quick sort**, either **ascending or descending order** gives us the **Worst Case** for **Quick Sort** which is **theta(n ^ 2)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/615746b5-5e5b-493f-838e-2e0f6522d52f)

* When **two equal division** is happening that is the **best case(BC)**.
* WC -> Worst Case
* AC -> Average Case

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56780e10-c79a-411a-bed8-a29cca6ce8f5)

* Quick Sort Complexities [**IMPORTANT**]
* It is an **in-place sorting** technique because **DS** is **constant(1)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f19ee6ae-b2da-4649-8f2f-b614b441bef9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/005d194d-2747-48af-b1e5-a0bcf22f1560)

* Between **Quick and Merge sort** who is **better** and where? [**VERY IMPORTANT**]
* Space -> **Quick Sort** is the **Best**.
* Time -> **Merge sort** is the **Best**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96e18457-0d30-4db3-8327-90ef759fc18a)

* Summary of **complexities** of algos [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/580c5ac3-d85e-444f-a338-97130306bd83)

* Types of questions to come.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc379b8c-2850-4c6e-bc19-f6638956dd20)

* What is result of merge sort algo after two pass?
* Question [Example] [**IMPORTANT**]
* Typos fixed.

## hashing (15)

## Radix Sort

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e017485-faee-4f77-83ce-5135548aed24)

* Counting Based sorting technique
* Base or Radix of number.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d9a75e1-eb32-402c-808a-071942d498a1)

* Whichever numbers we have to do **sorting** either in **ascending or descending** order then we have to check first in which **base or number system** they are in. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1bce1bbd-96f5-4830-806d-89657a6bdb4b)

* Example
* They are in **decimal number system**.
* We are taking **10 arrays** and each array size is **n**.
* **Radix sort** is **outplaced** sorting technique because for one array content we have to sort in ascending order but we have to take **10 arrays** to do so. **Data space(DS)** has **increased** that's why it is called as **outplaced** sorting technique.
* We are using **queue** data structure.
* We could use either **queue or array** as the data structure.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c37b254-f38c-43f6-9b71-f5ebd7fe8d94)

* The **keys** which are given to us and based on the **unit place or Least Significant bit(LSB)** of the keys, whatever that **digit** is based on that number we have to store that particular key in the **array/queue** data structure we have taken.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/568f1809-1080-4ead-9c86-551af6344764)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f814c0e9-4a76-4a3f-851d-4f12103a7404)

* The data is not in **sorted sequence**.
* If we see the **unit positions** of the data and by looking at only their **unit** positions we can see that the **numbers** are arranged in **ascending order**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/309f214c-37f2-4cce-a46f-d96e7f9b0af4)

* Earlier we did with the **unit position digit/LSB**, now we are going to do with the **tenth position digit** or the **2nd digit** from the **right hand side** of the numbers.
* **Queue size** is the **no. of elements** we initially had.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/636df34a-df3a-4616-85dc-8b7cc108a334)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ffab0d59-2c8e-4028-ba1f-53d1411a1735)

* The **data** is not in **sorted** sequence.
* If we see the **last two digits** of the data and by looking at only the **last two digits** we can see that the **numbers** are arranged in **ascending order**. [**IMPORTANT**]
* Complete **data/keys** are not in ascending order but the **last two digits** of the data are in ascending order. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5c1a455-f3fb-4433-8119-e70341d2b5da)

* We have a two digit number which is **95**, we can write it as **095**, so we will put **95** in the **0th queue**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d121c92-7bf8-4cfb-b30b-2361bb0799ef)

* Now we can say that the **data/keys** are in **ascending order**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08c8f6c6-f178-4186-9db3-6c961b02b233)

* Example. [**VERY IMPORTANT**]
* We have to insert the **n** elements.
* We have to delete the **n** elements.
* d -> digits.
* n -> No. of elements.
* We have to do the **'n' insert and 'n' delete** operations depending on the **digits**.
* It means that if the digits are **3 digit long** then we have to do **3 insert and 3 delete** operations.
* It means that if the digits are **4 digit long** then we have to do **4 insert and 4 delete** operations.
* The complexity is dependent on **n and d** and we can say that **n** is **far far greater than 'd'**. We can have **thousands of elements**.
* So we can say that the complexity is dependent on **n** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77f12617-ffbc-470d-964c-288c2e6b424e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5461298-6d5c-4bb7-8b0f-ab946ca57967)

* Complexity -> Theta(n). [Radix Sort] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9c13cc2-8120-4542-9a90-c6c424e10390)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b3e02df-224d-4b22-add1-39428351057b)

* If we have **n** elements and each element has **n** digits which is **n = d** then the **time complexity** will be:-
* Time Complexity -> Theta(n ^ 2). [**Worst** Case of Radix Sort] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8b6c5fea-dbcd-4bf9-aaaf-2ef5f4f9aef5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92fbf67c-d790-4378-a3b5-17786fa019aa)

* Max. size of one queue -> **n**.
* As the numbers are **base 10** numbers that's why we are taking **10 queues**.
* **n * 10** is the **space** but **10** is constant so the **space** is dependent on **n**.
* Space Complexity -> Theta(n). [Radix Sort] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40b328f6-9332-4d02-b397-d395a7696481)

* As for **time complexity**, it is also dependent on **n** only as **d** is **much much smaller than 'n'**.
* Time Complexity -> Theta(n). [Radix Sort] [**IMPORTANT**]

## Stable Sorting VS Unstable Sorting

* Stable -> Bubble, Selection, Insertion, Merge, Radix
* Unstable -> Quick, Heap

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/73818b5a-d437-48ff-8d22-1fdf05fe0286)

* Example.
* Get the **definitions** of **stable and unstable** sorting.

## Adaptive Sorting VS Non-Adaptive Sorting

* Adaptive Sorting -> If complexity of algorithm **depends** on **order of input** -> Insertion, Quick, Bubble.
* Non-Adaptive Sorting -> The complexity of algorithm **does not depends** on the **order of input** -> Selection, Merge.

## Searching

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ce54d76-c03e-426b-a365-4f816b91e380)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83b4947c-ce93-4d4c-96c7-5238bc5005ce)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/994754e3-7556-4b3e-b710-6171eaae7bde)

* Linear Search.
* Best Case -> When element found at 1st position -> Theta(1).
* Worst Case -> When element not found or at last position -> Theta(n).
* Average Case -> We are adding all of the **no. of comparisons** and we are **dividing by** the **total no. of cases** in the **linear search** -> Theta(n). 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8022eba0-24cf-4742-ae15-df5bfb499ce5)

* Linear Search Complexities. [**IMPORTANT**]

## Binary Search

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bafed04f-2733-4243-978b-1ea6639ae7fa)

* Data should be in **sorted sequence**.
* Best Case -> When element is found at the **mid** position -> Theta(1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6371bb0f-1592-4331-9da8-918cc8b8c603)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3270c775-c238-4674-9219-0b86426682aa)

* Recurrence Relation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44f3fda3-cfe6-4da7-8770-e351b8c6e17b)

* Question.
* It is not about **complexity** it is about the **exact value**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07905b03-de2e-4e48-b404-692ee89ba4e5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50525193-d9c8-4e40-8f66-e5754f439039)

* Answer -> 5
* **Optimial** asked that's why we did **binary search**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b911522-8633-4a77-be83-55676adbf136)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad3c98da-ce7a-4019-9630-59bc96187dbb)

* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d2fd33e-0708-494c-b6d8-c2097ee52966)

* By checking the **mid element** we got to know for which element we are **searching for**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d9bef8e-fdbd-45f4-b1b2-9bf00b21e54b)

* After checking the **mid** we find out which element we are **searching**. We are not doing **any comparison** at the **mid**, we are just finding out the **mid element**.
* Now check if **a[mid] == a[High]** if it gives **True** which means that the **mid element** has appeared **more than (n/2)** times in the **sorted array**. [**IMPORTANT**]
* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/435f92c3-56b9-43f0-b3bb-2d517621f87c)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/071e67e0-6096-4d83-a5b4-1ff561b59677)

* **Linear Search** in **Python**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e83a33ed-0854-4a28-a8c9-953de131a5a0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f65092e9-5d25-4479-bd96-7f1d7fa89a40)

* **Binary Search**. [Iterative Algo] [**IMPORTANT**]
* Time Complexity -> Theta(log n) [Worst and Average Case]
* Time Complexity -> Theta(1) [Best Case]
* Space Complexity -> Theta(1).
* **Floor division(//)** gives **integer value**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a0a2e7d2-55d2-40c4-a2c8-55229f0fef2d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1afae84b-72e9-4d8a-aaa7-e74f78cf89df)

* **Binary Search**. [Recursive Algo] [**IMPORTANT**]
* Time Complexity -> Theta(log n) [Best, Worst and Average Case]
* Space Complexity -> Theta(log n). [Stack space used]

## Hashing

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83a5b306-e22d-43ea-b403-b580c9ad7ded)

* To remove unnecessary no. of comparisons we use **hashing**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc0ff8d7-f325-4b5e-b41d-c60144ec2378)

* Hash table, Hash function and key.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a9a47db-70cf-4d34-94ec-6fa49640e460)

* This is **storage**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4634d07-9dbf-4f2d-82d6-d3341e5bb5c1)

* When we want to **search** an element then we send that element to the **hash function** and the **hash function** gives us the **location** where the **element** should be inthe **hash table**. So we can **search/find** the element with only **one comparison** which is **constant(1) time**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce352d46-763b-4232-a39d-f36bd8b2b080)

* Hash Collision.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff301bc8-ac82-4908-838b-b03c77233722)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3dc21d8-929c-489c-8396-30504c8f7664)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4f964e2-627b-496d-b496-c8561323aa36)

* Good Hash Function

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e72fd64-b4d5-4ff3-bf29-ca356c6bc20e)

* Different Hash Collision resolution techniques.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07385e4c-aa26-4b2e-99b0-19b9d2eb00b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4c00b84-6569-45f8-b530-bc219a8845f3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1213a933-8631-4bb8-b7d2-4d09848b2d23)

* HTS -> Hash Table Size.
* Linear Probing.
* Total no. of collisions -> 6.
* To search an element we first send the element to the **hash function** and the **hash function** gives us a location in the **hash table** so if the element is there then we will stop otherwise some other element is there in that location then we will assume that **collision** has happened and we will go to the **next location** using the **probing** technique we are using, we are using **linear probing** so we will go to the **next location** which is **one after the current location**. We will check till we find the **element we are searching** or we find an **empty space** in the **hash table** which means that the **element we are searching** is not present in the **hash table**.
* **More collision** which means **more searching**.
* We want **min. to no collisions**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0bc7bdf4-d5a8-4cd9-ad94-0a955cf1753d)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f18d3086-e516-4561-85c4-cecc1a68a42d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/543b63e1-885a-4377-97d8-0bc4843baf03)

* Successful probing/probe -> To search an element how many comparisons are needed till we find that particular element. This is **Successful probing/probe **
* Successful probing/probe = **No. of collisions for that particular element** + 1. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d606547-7288-4172-ad46-73e6d0ffc7bf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8a6a917-bf01-481f-a278-a88b760b024b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/61490a15-08dc-4893-8e68-46323a63b4c3)

* **Unsuccessful Search** -> The **element/key** we are trying to search in the **hash table** is **not present** in the **hash table**.
* **Successful Search** -> The **element/key** we are trying to search in the **hash table** is **present** in the **hash table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d85fd16-d49e-4122-8f4c-1e8788f9d531)

* We need to do the **5 comparisons** to see that the **element/key** we are trying to search is not present in the **table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9a16fa39-69e1-4213-a12f-a269c24683eb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/edae08ec-31a3-4123-8ba9-a10e97a0a764)

* We are calculating the **total no. of unsuccessful searches** and then dividing it with the **no. of slots** in the **table**. we will get the **average no. of probes for unsuccessful search**. 
* Solution. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/422b8466-435f-4fa9-91ba-3032dd941f0d)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/087d33c3-b872-4139-9d37-401a976715bd)

* Good Point.
* In case of **mod 10**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/02962501-c423-4042-9352-94b61f28696f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c2f61b4-4a9a-453a-a607-3fd0f828992d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/47ec78c7-4a52-4856-96af-77703e22ca1b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8099e34-f36c-4ef6-8fdd-7abbfd08c343)

* No. of keys -> 7.
* No. of collision -> 2
* Avg probe for **successful search** -> (No. of keys + No. of collision)/ No. of keys -> 7 + 2 / 7 -> 9/7 -> 1.2 [Formula]  [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/244d251d-f4d0-426d-9087-5c40acb967f7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0eb617bd-fd97-4e50-9d6e-9413aab77a4b)

* Avg probe for **unsuccessful search** = No. of unsuccessful search / No. of keys [Formula] [**IMPORTANT**]
* Solution.

## introduction-to-data-structure (16) 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38da83e2-9c6f-4efb-ad9e-4c6ea54dd7e9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32f01c4d-1ac0-4ffc-ac34-a54d448d01e6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7694cf5d-d6ca-4050-975e-9ecb8bd66985)

* Problem with **linear Probing**:- [**IMPORTANT**]

1) Primary Clustering
2) After deletion sometimes searching is failed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3e24c74-d658-4ff8-a0a7-4a8187147611)

* Un-necessarily **no. of collisions** are getting **increased** in that particular location of the elements.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed6689c9-1cfd-4009-86cb-f63cb24efd43)

* After **3** comparisons we are able to find **35**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b806a8e-eee8-4d5f-947e-e787819dbe31)

* Deleted element **25** from the **table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f18f0512-3108-4561-90db-93c1a5dc2c89)

* Now we are trying to search for element **35** but as we deleted **25** in the middle and we found the **blank space** first and we are thinking that **35** is not in the table even though **35** is in the table. This is a **problem/drawback** of **linear probing**.

## Quadratic Probing

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4b9fdd54-649d-4f2c-a67f-1f9607b81156)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b34bca20-07bb-4596-aceb-9da9a8190059)

* Example.
* We are doing **mod(%) of the hash table size**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/408120fb-bd81-45ca-aac2-2887f41e82a1)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/743030c5-f6f5-4548-bc2f-6430c899bb91)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71da1939-fb38-4b15-b879-a6f013096b33)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/319ce32a-1674-4cc1-b95a-8802481267a5)

* Solution. [Example] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e87521c1-964f-454e-8ab9-4b8322dd5a59)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f09927a-4974-42a1-bbcc-72a72f864090)

* Problems with **Quadratic Probing**.
* After deleting keys sometime searching fails often for other keys.

## Double Hashing

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88bb1d68-cfcb-4a02-8375-3d1d822202c7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29fa5bd6-92a2-46cd-acd0-b67b86b26787)

* There is **no clustering** here. There is no **cluster** creation concept. [**IMPORTANT**]
* **Keys** have **different paths**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4f522873-ff69-459f-8642-106b72fa1ed3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c78c9c1d-9f24-42fb-90dc-036507440d72)

* Question.
* For **65** we got the location of **5** from the first hash function(h1) but there is already one element there in location **5** so we got collision. Now we will send **65** to the second hash function(h1) and we got the location of **5 + 5 -> 10 -> 10%10 -> 0** where we will again get **collision** at location **0**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a605c55c-a1b1-4c8c-883f-cb9993a5f57a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7de4f408-67fe-4414-af7b-6235a3eddea5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/68d94487-63bf-4521-8d36-e4eb57eff13f)

* We are getting **infinite loop** as it is going from **5 to 0 to 5**.
* **Infinite loop** can happen in **Quadratic probing, double hashing**. [**IMPORTANT**]
* **Infinite loop** doesn't happen in **linear probing**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e1a1e92-4d8f-494a-a2ae-10b69ee40df9)

* **Infinite loop** issue.
* To resolve the **primary clustering(PC)** issue in **linear probing** we use **quadratic probing**.
* In**quadratic probing**, the problem of **secondary clustering(SC)** and **infinite loop(IL)** problem there.
* To resolve the **secondary clustering(SC) and infinite loop(IL)** problem we used **double hashing**. There is **no clustering** in **double hashing** but we still have the problem of **infinite loop(IL)** in **double hashing**.
* All of the **three probing** techniques have a **common problem** which is **deletion** which is if we **delete** one element then it will be possible we cannot find the **other elements** which are still in the **hash table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff9efa2c-222a-41fe-aed8-020a12f7a238)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c24783d8-fc95-45c2-a1c5-973809dca7a1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c494886-62fb-4ff9-b204-204014b966c3)

* The **common problem** of **open addressing** is **deletion** that's why we are going to **chaining** to resolve the **open addressing** problems.

## Chaining

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/40b5adaa-fa9b-4806-8222-b32c5ddb3beb)

* Advantages:-

  1) We can store more keys than hash table size(HTS).
  2) No infinite loop problem.
  3) No issue after deletion

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f6467a31-9a36-491d-be57-53fa91f4c88e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26fe7293-0419-45be-95e9-907e224d01fb)

* **load factor or avg. chain length**, they give the **same answer/result** only.
* **load factor or avg. chain length** = No. of keys/ No. of slots. [Formula] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0b128e6-5a88-4034-8eb7-6965dd05dc67)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/307e733a-28ac-4626-ada8-8c6e267bf5e7)

* Option **B**.
* Finding the **correct hash function**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9f1dc1b-3398-4a7e-8927-387e45f3b997)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dc8fcf0-3619-4808-90c1-79b582b8df76)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/401ab1af-2072-4cbb-b1ad-b891d3da7dd6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae464e1b-973b-4c72-af14-4c95b787731d)

* Option **C**.
* **Closed hashing and open addressing** mean the **same thing**.
* If nothing mentioned in **Closed hashing and open addressing** then by default we should use **linear probing**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01e318b2-8e66-4a7a-b2da-179b22db06d8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b068b5a4-14e0-436c-b675-3a0d42a31e34)

* Option **B**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1e3accb6-d292-4659-9db7-1ebc021bde7a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/24e1dd7b-ff13-4c10-b979-8d33d8317a7f)

* **Option A and B** doesn't have all of the keys, so they are **incorrect options**.
* Option **D** has more than one key in a single slot which is **not possible** so it is also an **incorrect options**.
* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cca0ab4e-5b36-4731-a27e-b36890e25457)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19a2d96a-f963-4994-a27f-6a2f420d0641)

* Option **C**. [1]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f2b8cc06-f87e-4d61-8c36-5b4b8e6be51f)

* If we have **n** keys and we have **zero or no collisions** then we can say that we have **n!** ways to store the keys into the table.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/266b35b2-8bc7-4118-b4c8-fb5b8a12e185)

* We have to send **52** before **33** always otherwise if **33** goes before **52** then **33** will collide and take the **position '5'** which is reserved for **52** accoding to the given order in the **hash table**.
* **42, 23, 34 and 46** elements can been arranged in **4!** ways to store in the **hash table** which is **24** ways.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5a5c83a-29e2-4b29-87da-d8bd84e0a918)

* We can bring **52** before **46** because **46** is always taking the **position '6'** even if **52** comes before **46**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b45dc3ef-60d7-4aa6-9196-08eb6988c4aa)

* 24 + 6 -> 30.
* Option **C**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/496c68cd-b597-4c04-af78-9aa2e4334d7e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e54a30a-09b0-4165-ac11-f391275edc84)

* Option **A**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59b73ef5-1e7f-404c-938e-c62902c334a9)

* Max -> 3
* Min -> 0
* Avg -> No. of keys/No. of slots -> 9/9 -> 1 [Formula] [**IMPORTANT**]
* 3,0,1

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01e676f1-c226-47ac-9c4c-a3f9ec7f180d)

* Option **A**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d23e507a-6cbf-4bbe-9485-b3fc22c47d21)

* Answer -> 2000/25 -> 80 [1]
* We are checking the **last digit** of the elements/keys. **Last digit** will be between **0 to 9**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b6a1a41-7621-4784-9586-216b70091934)

* The **hash functon** in option **A**, it has taken **some slots** in the **hash table** and left out **some slots** from the **hash table**. Whatever we take those will be going to these(above) **slots** only. It is not utilizing all of the **slots** in the **hash table**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63f559e4-2c25-412b-ad2c-d14ea04ef440)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d029b36c-e490-4794-b270-ba716f47d6ee)

* The **hash functon** in option **B**, it is utilizing all of the **slots** in the **hash table** and we have **little to no collisions** in the **hash table**. [**VERY IMPORTANT**]
* Option **B** [2] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1ac55abc-ff7b-4651-bfd2-79b93ea9585d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ad8c8e2-6de5-42b1-ae76-98f735b3bb8e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e07fca17-a919-4959-bbf4-1ddbbb6c682e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a3ef76ef-5d49-4bf5-8898-0929dd8d8c18)

* Answer -> 13 [**IMPORTANT**] [Example] [Questiom]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d12403d-4ab5-4c82-9136-317337530616)

* Example [Question]
* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb29dd20-5e70-4bbc-bffe-fd83cd5fd220)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f47d08e3-ccc6-4798-9de2-580a460be7bb)

* Example.
* Both give the **same output** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/15a96781-5422-4b59-8c4b-c9ca6c906369)

* Example.

## array (17)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a38134e-bdfd-4914-a183-b35a7ebff2a8)

* Hash Functions.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d78e0c91-160d-4cbe-830e-9a5cb85a8fef)

* **Hash Functions** is highly responsible for **collisions** between the **elements/keys**. [**IMPORTANT**]
* Hash Functions -> Keys -> Hash Table [1 -> 2 -> 3]
* **1** being **highly responsible**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d2153a3e-583c-4410-ad57-cc6eb87fadcf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c24502c4-8f2e-4b1b-afda-4478833853da)

* Properties.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/24bfc095-be33-4d79-b922-eaf0563475c6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/485af8cc-5b7c-48e8-9f5a-231e7b43a66e)

* Types.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dad84886-cf7b-4395-8ab6-ab9461a77cd1)

* Type

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a97447b-d398-4b03-af23-4600ece24a0f)

* Type

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2120cd07-ab73-49a4-8f41-0b82e38b2273)

* Type

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b69a7511-0948-49dc-a879-331e127e458b)

* Type

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b613df2-d715-4134-a848-fb761b3ad115)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f06502f8-7129-4645-bc92-79b20ed5ff6e)

* Type

## Static and Dynamic Hashing

* In **static** hashing, the size of the hash table is **fixed**.
* In **dynamic** hashing, we can **increase or decrease** the size of the hash table.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b050639b-e7f3-4b16-990b-2664b819167d)

* Till now the different hashing techniques we have learned they all are **static hashing** techniques.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c48a0ae9-bbae-4275-a863-2cc0e1648b62)

* **Static** hashing.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/623dd6c0-85c8-4d78-bbf7-3b77c2b775c2)

* Open Hashing.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/73e0591a-85d9-4688-80c3-b1a3e6a9a55d)

* Closed Hashing.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93972b7b-2b19-4bb6-96ac-9fa6edec9738)

* Open and closed Hashing.

## Dynamic Hashing

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f04c34b5-e8d7-4cb3-9133-17877579cc05)

* Dynamic Hashing
* The **size of database** repeatedly **grows or shrinks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b99e268e-a9a5-4f45-81b9-c2125b0a1d08)

* **D3** cannot be **stored** as **D3** should come in **position '1'** but **position '1'** is already full.
* We have to grow the **hash table** which is **dynamic hashing**. We can **grow**.
* Initially we took **1-bit address**.
* Now increase the **hash table** size and we will use **2-bit address**. **Hash table** size has **increased** and now we have **'4' slots**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/58f3399e-3198-45d4-a038-4e2530ba9447)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/882cf2f9-7d36-4362-96df-868c2e365fa1)

* For **D3** we have **10** and at **position '10** we already have **D1** so we got **collision**. We have to use **collision resolution technique** to resolve the **collision**. The **collision resolution technique** would be mentioned in the **question**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89742986-8523-48c0-98e2-8171a6fe6a0b)

* Question [Example] [**VERY IMPORTANT**]
* **Dark bubbles** are the **keys**.
* We can see that in option **A** we have **4** which is **0100 -> 00** but in the **hash table** we can see that there is **no element** at the **'00' position**, so option **A** is **not correct**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/609fecab-4235-4941-8182-9527e8fd9d63)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a7d8be7-78db-4933-a805-be7820576fa2)

* For option **B** we have **'3' in '01', '0' in '00', '2' in '01' and '1' in '11'**.
* Don't jump to conclusions check the rest as well. [**IMPORTANT**]
* Also check how the **tree** is made by option **B** keys.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe35b07b-afb3-44c8-bd71-b190a2360b24)

* Option **B** tree but in the **hash table** the tree is growing on the **right side** so option **B** is also **wrong**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1e52fac-030a-448c-a571-a518bb49eb65)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/952fc220-0dcf-400f-bd8d-1697ccdf1741)

* Option **C** tree is in the **correct way** as in the **hash table**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55ae41f7-e3ef-4505-8b38-78bd41e9b015)

* Option **C**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1ed461ba-a248-455b-82a1-3b22b9786f0c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a0fe4e6c-850c-4b89-bc68-0ea210cfc86a)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/296fa0bd-5556-4788-a35e-6c385ad4b5da)

* Example.

## Data Structure

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4df89d63-ac7d-490e-a7af-4c5c9f7dde79)

* Data Structure

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e51c34d5-97dc-4507-9902-586acbac8024)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/498b7811-bffc-4d1e-82c0-7dcba45fac9a)

* Types. [Examples]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed45a894-24d3-4136-b1d9-0ea17211d9aa)

* If data is available at the **same level** then it is a **linear DS**.
* If data is available at a **different level** then it is a **hirerarcial or non-linear DS**.

## Array

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5be6771a-1b21-4007-9892-265c1d4d3401)

* Contigous Memory Allocation
* Homogenous elements collection
* Random access is possible in **constant or Theta(1)** time.
* In python if we need to use array we can use it via **list** or via **importing 'array' class** in python.

## Linked List

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87386b5b-9cdb-4252-aedd-ec74fc44ca93)

* Linked List.
* Back-traversing is not possible in **singly linked list**.
* In python, we say **None** instead of **Null** as **Null** is not a keyword in **python**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f61e585c-0723-46b1-a13d-0d2979f3af82)

* Singly and Circular linked list.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c94d17cd-1edd-47f4-b53e-e399f7cdb2af)

* Back-traversing is possible in **doubly linked list**.
* Doubly and Circular doubly linked list.

## Stack

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de6b0980-4872-4f42-93fc-f2155d8fbdfa)

* Example.

## Queue

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2b1fb4b5-166a-425f-a321-8a29288a5c81)

* Example.

## Matrix

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/773fec9e-9d51-4121-9b67-762bcbe8f37c)

* 2D array. 
* Example

## Binary Tree

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f283528f-2284-4877-ad93-ecb5367fcd65)

* Ternary and Binary Tree.

## Heap

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/874c45af-e996-4eb2-ad54-6c768f0b34af)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9ad62d9-3add-4bb1-9fbd-e772547dae3b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/870afcae-5904-49c3-9e7b-72300bcedb82)

* Max Heap.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8102560d-5fa1-4f09-bd4e-f5ff13805fe5)

* Max and Min Heap.

## Hash Table

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/431eced9-a58f-4178-a404-ce7d11ac8784)

* Hash Table

## Graph

* Tree -> Acyclic connected graph is called tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93d9e392-72cd-456f-be7e-bea30e1c08cf)

* Graph but not a tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/121571ca-3c90-4f42-b550-3a77526baea8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/44dfcb08-807f-4198-9a43-dbeeabc01fa6)

* Tree VS Graph.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad4e909f-2b43-4143-8d33-cdf43b37aaf9)

* Every **tree** is a **graph** but vise-versa is **not True**.
* **Null Graph** -> A graph without any **edges**.
* Graph can have cycles or cannot have cycles. Both are possible.
* **Tree** should always be **acyclic**. There is **no cycle** in the **tree**. [**IMPORTANT**]

## Python Specific DS

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f06f193-fd63-41d0-84ee-51c70687647e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a57f945a-fd48-473a-8d1d-7c57943f34d9)

* List

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05c70e45-cf45-46d3-a534-d9127c4138b8)

* Tuple.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/083f8ad5-155a-460f-8a50-f69051c1a6df)

* Dictionary.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c51aeee4-86ec-4515-b2b4-20258ce18214)

* Data Structures.

## linked-list-part-1 (18)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a1c76222-49b4-4874-a3e4-82663c1c25f1)

* Array

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc33d7f7-452d-4e0a-ab94-9c7e354a9ade)

* Array Types.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db8e37c9-334b-428f-9d1b-e92c23d9ee32)

* Operatiosn of an **array**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a787a31-d94e-4a64-876b-d52348f7c868)

* Array example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3fbba7c3-6339-41a6-b486-b28e11b338ef)

* Example
* UB -> Upper Bound(U)
* LB -> Lower Bound(L)
* BA -> Base address.
* W -> Size of data type.
* i -> Index.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/96628d53-2e44-4b4c-b95a-3e467c786acb)

* Address of ELement -> BA + W * (i - L) [Formula] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4b31652-8d03-4eb2-b6c7-f6120de76390)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e16fee9b-7369-43b6-8494-abde6299a775)

* Question [Example] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b7b975e4-11c7-48e9-bb70-e06249ee6bc5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8f39aee-280a-4c8b-b0c8-22ad29ab0cda)

* Solution.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29359ea0-b610-48b0-bac6-8e88d25f28b2)

* Question [Example] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6405e4a9-016d-456d-8e62-47ac1f308d61)

* Solution.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c0fcc75-f0c1-4380-b54b-9e876406b005)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/033c52f3-48fd-49c1-9a8c-23b3fd71c55c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b633f2e2-bd0f-4e59-8562-79f2c5137577)

* Example. [Formula] [**VERY IMPORTANT**]
* L1 -> Lower bound for row.
* UP1 -> Upper bound for now.
* RMO -> Row Major Order
* CMO -> Column Major Order.
* m -> no. of rows
* n -> no. of columns.
* No. of elements -> m * n. [Formula] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/371b6af2-02d6-4d1e-b203-951a9dc28101)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/47611627-931e-4bd3-97bf-827e2bc55ad4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ea66bf3-d163-4b8d-b95d-c37f25473000)

* By default value of **L1 and L2** is **zero(0)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07676e6c-1af3-4ab5-88f5-c66ffff15e62)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc267dcd-9dc6-4cd5-8bcb-5a01409b4676)

* [Formula] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f645d74-77db-4f23-a83e-939166a518f1)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/66df7c54-2568-4c5d-beb7-bb896012fb15)

* Question
* L1 -> -6
* U1 -> 7
* L2 -> 4
* U2 -> 10

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac5c3110-244a-474f-9a24-94f23037f499)

* Solution.  [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17ddcc1f-0798-49aa-beae-1664900540b1)

* Array.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bfce4824-0a0f-4354-8dbb-f3947c2d27d2)

* Typecodes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d31fb73a-0ada-4c1e-a672-d637551df535)

* Traversing of an array.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e91eaa61-89b4-4ab1-8b7c-dc836dce6ad9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c163dc9-7a0e-4b40-9feb-a6706bdeb229)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7e6bcb3-5e6f-4337-bcb1-55746da01eed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4526e50d-7ea5-405f-b273-e561441815a3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a36fff8-d060-4146-a063-d59fa86002fb)

* Insert operation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29db0df2-55c9-4ccd-ae92-6f8cd515b142)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4c6d3ad9-88f0-4d4d-a2a1-8520a94f1ee2)

* Deletion operation.
* The **output** will be printed in **next line/new lines**.
* If the element we are trying to **delete/remove** and it is not present then **remove()** will give us an **error** saying that the element is not available.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1ad940bc-e580-4d77-9e22-e3d422443824)

* Search operation.
* If the element we are trying to **search** and it is not present then **index()** will give us an **error**.
* If element is available then it given us a **location**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9e1a85e-1687-43da-acf9-2dfc207fbd03)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0fb64814-c0d1-4f83-bf11-e8a670df1998)

* Question.
* There is no concept of **local or global variable** with the **done** variable name. All of them are the **same** only.
* We are checking in both the **directions**, 1st for loop in the **forward** direction and the 2nd for loop in the **backwards** direction.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ff9400e-d6f7-467f-8b99-cc83ef90bb7a)

* Doubt. [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/75a21f0d-8631-4820-8180-8b1c35cec1ca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b994d27c-60b0-4d24-b89d-995cf50d6cf0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16218139-3b96-4fe2-8b67-b4f1ed51ae2e)

* We had to do **5 shifts** only.
* Answer -> 5 [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3353b29b-6183-4551-9071-5b08f69ffd35)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95919390-2ac4-463b-ad56-e4634eedb4b1)

* Solution
* Answer -> 0. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2817d97-cc07-4785-8b1a-6a0a91c75864)

* Solution [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ad5dc2da-fef4-4691-b4cb-ce3d3c8435bf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2b646696-4ce1-4a91-b9ea-d1564d9a8a5c)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc4bd166-e9ad-4c54-a932-b172a63cd0b9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9e4364fe-a32e-4e0e-b83a-5440f517e3af)

* We need to ultimately apply two for loops.
* We can write it anyways it doesn't matter.
* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c139c388-7c65-4c07-bc91-00014c25e282)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63711ef4-6901-48de-a4b4-6dbcd2a56ab7)

* Option **B**. [**IMPORTANT**]
* By default they are in **row major order**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10827b5f-0755-4a2f-9e50-994436dd6463)

* N -> Set of natural nubers [Universal Set]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6fc33d40-90cc-436f-ac08-20510f17e6e5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2acb5f53-49e6-415f-84cc-922a850d9c1f)

* Option **D**. [**IMPORTANT**]
* OR -> Union
* AND -> Intersection.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df9ebce6-1397-4d65-8bbc-748a2135b4ff)

* We can see the **last two element sum** as it is a **sorted array**.
* Check the **sum of 1st two elements** if it is **ascending order**.
* Check the **sum of last two elements** if it is **descending order**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbef02af-d9ce-4afe-b9e3-284618b2b1ce)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fc4dc125-daad-4283-902a-bd4758dcd961)

* Option **A**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22de44e6-054c-42dd-8e53-10d26d374dc9)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/34c57870-3bfa-4989-9199-d2ea21f16b59)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55776c84-8fc4-41c3-9019-b54a5b6db543)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b0d2044-cc2b-4c98-9ae7-ad6c33b9355e)

* Option **A**. [**IMPORTANT**]

## linked-list-part-2 (19)

## Linked List

1) Non-contigous Memory Allocation.
2) Effective use of memory.
3) Data stored in the form of node.
4) Node consist minimum of 2 fields. 1st field contains the information and the 2nd field contains/points to the address of the **next node**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aefd62a1-6fe0-4bdf-bfd5-729fa5541104)

* Linked List.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6741fd4c-9617-4b6e-abb3-7e3302ec035e)

* Singly Linked List.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42a9c7bf-bfff-4031-a3e4-cc6368dd9ef0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b69a10af-7aa4-4f0d-a238-87cea2783424)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/724bed98-98f7-458e-9dfb-732e41e076d7)

* With the help of the **last** variable we can access the **last node**.
* With the help of the **start** variable we can access the **first node**.
* Types.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f784ab28-f897-44fe-b80c-8565cf9b6dda)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1dec5a0-9f06-4e16-ac88-fb67c07048d4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/052bed23-fff8-43c4-b0d4-a744d4e5d9a7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1d4976bc-df72-4250-bd64-ef9c71f3ea8a)

* Operations.
* We can perform **linear search** in **linked list** but **binary search** is **not possible** because we cannot directly go to the **mid or middle element** of the **linked list**, we have to **traverse the list** and go to the **mid or middle element**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5a875a7d-48ac-434b-9cdf-75bc52cd66e7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e0a04693-41ab-4ff2-91e6-3ebb6b08b47b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2773979f-0c0f-4d51-addb-c2d32d4ae529)

* Node creation. [Python]
* Create a **class** for a node.
* In **C** we have to create a **structure** of the node.
* In **python** we have to create a **class** of the node.

## Insert Node at First Position

* **p** is an **object** of the **node** class. [**IMPORTANT**]
* **start** is an **object** of the **node** class. [**IMPORTANT**]

1) Create Node
2) Store information in **info field**.
3) Address part of 'p' should point to the **next node** in the **list**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5413fc9-dc13-4c21-90c5-ed1312739206)

4) **start** should now point to the **new node** which is created.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bada986c-e7be-4e7f-96d0-f676ab337efe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d7477c6-a000-43d4-be17-dc1e2dca3937)

* Insert Node at First Position [Steps] [Example] [**IMPORTANT**]
* Time Complexity -> Theta(1) or constant.

## Insert Node at last Position

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/38e3941a-7bfe-46d3-80fb-382c352cdd9d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d89e075-ece9-4bc0-b9d0-6890f7b21506)

1) Create Node P
2) Store information in the **info** field
3) Store **None** in the **next/address** field of the node.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe8d51ad-78a6-4022-a22c-78bb8e90c91c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/27507d5a-32ab-4340-a34a-8c317c42dd82)

* **q** is an **object** of the **node** class. [**IMPORTANT**]
* **n** is the no. of nodes available in the linked list.

4) We need to traverse to connect 40 with 50.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e1b93c67-695a-462e-bc83-041561f7e7ea)

* Time Complexity -> Theta(n).

## Insert Node at any given position by the user

* **q** is an **object** of the **node** class.
* **Pos** is the **user position** where we want to **insert** the **new node**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/047b77fc-c85e-4d5f-a396-54be4a2bc3a3)

* We want to insert **35** node at the **3rd position** of the linked list.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0888c98-0d67-48e4-bdaa-149e5750e8bc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c4b6e4b5-87bd-4015-8bcf-701268f432a3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5cf17eb4-a076-4792-80c9-308d1fc018b8)

* Insert Node at any given position by the user [**IMPORTANT**]
* Time Complexity -> Theta(pos).
* It is **position(pos) dependent**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/232be668-703d-43ff-a570-cc340c001908)

* Time Complexity -> Theta(n). [Worst Case]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ca14330-0865-49ef-a86d-6bad8028a2be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/af25b81d-af46-4f45-a968-e2813e10c2af)

* Example
* It is going to **insert** at the **1st location/position** of the linked list. 
* IF -> insertion at first position.
* Print all of the elements -> Kind of **traversing**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a704795e-025d-4ee5-a368-5e8f6cab9d04)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7fc9ba10-a84a-48a0-93ed-7c517c6d80e2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dd8f12e3-5fc8-4fba-af14-955d22350755)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b2262518-e336-491a-afe0-69cf9b80ea82)

* Question.
* **head == None**, means that the **head** pointer is not pointing to **any node**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a41c4d82-ac81-4b92-bff0-eac0d136594e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7bae9301-9934-4462-9215-fde701d31218)

* Insert node at the **end**. [**IMPORTANT**] [Code]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7fe2d4a3-3ab4-4805-af6d-1121c0184f61)

* It means that via an **object** the function will be **called**.
* The **object** will be passed via the **self** parameter.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9970dbb0-71a9-44b5-8b94-1ed94d649bed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95708fa1-b159-4a99-bb15-44a1508d151b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b052b495-8499-484f-96ab-415c58f80f69)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/02052243-b15a-4ba4-8793-29d7e2bd4d36)

* Inserting a node at any position of the linked list. [**IMPORTANT**] [Code]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d1b549e-23e0-4ff6-ab34-71c55d416d11)

* Doubt.
* **self** keyword doubt.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5eef01a-cbbc-4c4f-af3f-9789cfc52d6c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/389d839a-af5c-471d-a58a-ee41ccb5e9ad)

* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/86875ffa-04a9-4bce-8368-7672b44b8812)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0bc4ab16-d9c1-4548-86c2-203de9b985d0)

* **Worst case** for **min. no. of exchanges** which means we have to apply the **best algo**.
* If only **worst case** was mentioned then we would have written **(n - 1)** which is option **A**.
* Actual Answer -> n/2 -> Half comparisons.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1cfbf73c-f492-42d8-b243-28b4c3145d90)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e36f06d-d425-42f1-9b36-9257a8d0063f)

* Option **B**. [**VERY IMPORTANT**]

## stack-and-queue-part-1 (20)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4842c94-c177-4307-b639-365410851dd0)

* **Insertion** in linked list.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9eb79427-746f-4699-9c90-6d762f377a38)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d71d27e-abec-46a1-971f-56737c47a29e)

* **Deletion** in linked list.

1) Deletion from 1st position.
2) Deletion from the last position.
3) Deletion from required position.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a55fe4ce-4940-4c82-9eb7-48b72c3f6946)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/185cd33b-f262-4e9f-a918-c4b5dd2e4972)

* Example.
* To remove an element from a specific position the linked list. [**IMPORTANT*]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/208a920b-e9f0-4841-ba60-55ddaafbfe7d)

* i = i + 1 [Miss print in the code]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3f8ad677-dbf9-419f-8011-676896d5edb0)

* Example.
* Node **3** is not in the path.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b7327ff-ed02-48e4-b381-e343025242c2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ea235f9-6b12-465c-965f-8f95cfe34628)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b679484-992c-45bc-8925-f85fe82da0da)

* Complexities.
* Singly linked list(SLL) with **two ends/pointers**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e2111a7e-1dd0-4859-8fc2-4f84585c596f)

* Insertion at required position.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/37a8a7b1-c4e5-4156-a37a-1c16aabc23aa)

* Deletion at required position

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56fa0fd0-59e3-4866-807f-99b97165cb73)

* Circular Linked List.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c061a240-037c-4e1d-8878-9db6751b1aea)

* Inserting node at first position using constant or theta(1) time.
* We have inserted the **new node** in the 2nd position and then swapped the **keys values** of the **1st node and the newly inserted** node so that we don't have to change the link at the **end of the linked list** making it a circular list. For changing the **last link** we have to do **traversal** and the time complexity would have been **theta(n)** instead of **theta(1)**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a6442f63-e236-4217-a5d4-b05e16ef5761)

* Deletion of the first node.
* We want:- 20 -> 30 -> 40 -> 50 [Final output]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb5a043a-4d97-4c3a-a77c-8d262412907a)

* Time Complexity -> Theta(n). [Possible solution]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f534235-a131-495d-b934-0242b3092f9c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e77cc3bd-9ee8-49d0-882c-d89177c31d74)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fcd9b05a-e3b3-45be-8482-75ff04ccd8c9)

* Time Complexity -> Theta(1) or constant. [Another Possible solution] [Better time complexity] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0b88ec33-e3d5-4551-acb2-0ff16f39da7e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d1418362-1b4c-4158-bd00-ad5bc173d39d)

* Insertion at first position.
* Time Complexity -> Theta(1) or constant.
* Output:-
* Start -> 10 -> 20 -> 30 -> 40 -> 50 -> Start.
* This is not possible in **singly linked list**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6983f999-db7a-4043-a2a3-4850a2f8e837)

* Deletion of the **last node**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06b343d7-3201-4ea7-8553-075173db0d6c)

* Time Complexity -> Theta(n)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f79e0fad-eff0-4820-897e-2dbb9d4d08ec)

* We cannot go to the **node '3'** position without doing **traversing** the previous elements. That's why the only option is **traversing** and the time complexity will be **Theta(n)** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0be407f-d3da-4134-9b99-63fc0bb6e559)

* Even if we had the **last node** address stored in the **'last' variable** then also the time complexity would be **Theta(n)** only because we need the address of the **2nd last node** from the list and we have to do **traversal** of the list . There is no way around it.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/45daefee-bebb-4e0f-8da6-8d898adf7899)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c5e2634f-e33f-400f-8a46-d96524246530)

* Doubly Linked List. [**IMPORTANT**] [Time Complexities]
* We have the address of the **previous node** that's why we don't have to do **traversing** while **deleting nodes**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/454e01bd-5589-40bf-bb41-1b747bec86b5)

* Circular Doubly Linked List.
* Insert at first
* Insert at last
* Delete at first
* Delete at last
* Insert at first -> Insert at last -> Delete at first -> Delete at last -> Theta(1) or constant.
* It is **same** whether we have **singly, doubly, circular** linked lists.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c74deead-9c62-44c2-a7e7-8387e507eb76)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c7a645d-1123-4146-b638-e6dfd2b90c8f)

* When we have to **insert in a particular/specific position** then we have to do **traversing** and the **time complexity** is dependent on the **position**.
* Time Complexity -> Theta(pos) [Pos -> position]

* SLL -> Singly linked list
* CLL -> Circular linked list
* DLL -> Doubly linked list
* CDLL -> Circular Doubly linked list
* In **CDLL**, the previous address of **start address** is pointing to the **last node** of the **linked list**. It doesn't matter if we have the **last node addreess** because we can directly go to the **last node address** from the **previous address of the start address**.
* We can only perform **linear search** in all of the **linked list** types.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/824f5281-3e7c-4e26-89ee-72f82810eb98)

* **Concatenation** -> Linking two linked list/

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/49e3ac84-4504-4b03-8be5-43f81c85b638)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b8e8151-85b2-44ac-b24b-9a7f24c60f91)

* We have to **traverse** the 1st linked list. If the 1st linked list has **n** nodes then it will take **theta(n)** time to **traverse** the 1st linked list.
* Time Complexity -> Theta(n).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2e8cc81f-214d-43a9-a91e-182c100d13ca)

* If we have the address of the **last node** of the 1st linked list then the **traversal time** is saved and we can directly link the 1st linked list with the 2nd linked list.
* Time Complexity -> Theta(1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/272dd62d-d8f4-4007-8852-9b8b41611127)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/87488d91-fa70-4371-8a0b-20200a1cd40a)

* Linked List Time complexities [Summary] [**VERY IMPORTANT**]
* Table Contents:-
* Create **n** nodes list.
* Insert First
* Insert last
* Inset pos
* Delete first
* Delete last
* Delete Pos
* Search(Linear search)
* Traversal
* Concatenation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5da74bb9-5558-4254-8448-026335f6ddd3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0971fc39-2df3-45cb-abe0-68200d69c83e)

* Doubly Linked List.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6374604-46ba-4ba1-a56e-825f8e27481b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4074dbb1-9773-4eb1-a99d-367e5d5befbe)

* insertion at first.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5e09da2-8921-4396-a3c5-b938d3f39b42)

* Doubly Linked List. [Code]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9225c5ee-4c4d-4149-8244-08d102d68ede)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc8919f3-8d60-4022-92dc-d6e67a2f4cac)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6ff75059-e878-42f8-ae3d-0fa9c25bf311)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b79d5e59-6742-4198-8aaf-8667c45dadac)

* Circular Linked List.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4a13e32c-493f-4f95-a045-15b7c98df6a4)

* Option **C**.
* Circular doubly linked list because we can go to the **last node address** directly. Whether it is single or double ended the time will be **O(1) or constant**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/72199a3e-5505-4454-a96e-c48fcbf88d91)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b4ccb46-3fcf-4843-ad3a-3962c1473cd2)

* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2f5f4c1-b57b-4b6c-b1a9-8600fc43f030)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/90252599-66ec-4e9a-a3dc-57a8e33d0a7c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abaf8c43-cfa7-4a38-bf0d-bb4f5ec41c8d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c474dff-8e9d-4406-aed8-127d2a7c7262)

* Which sorting technique we need to perform over linked list? [**IMPORTANT**]

> Insertion sort. Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/233c0484-25a1-4b01-b576-33f5a70168e3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4818ff46-955f-4795-ad84-71ff4d588aef)

* Option **B**.
* If a list is empty and it is in **non-decreasing** order then that is **True**.
* If a list has only **one element** then also it is representing **non-decreasing** order which is **True**.
* That why we should tick option **B** instead of option **A**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/17d17ae6-5f78-4fc0-a257-7aa7dbf35ebf)

* Membership -> Searching, item is a part of the linked list or not.
* Cardinality -> No. of elements, count.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef3a80e7-9e3c-4f0e-a95f-65c2417806dc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/282cd51b-330a-43a9-b593-313ab479767f)

* option **D**. [**IMPORTANT**]
* Cardinality -> m + n.
* membership -> m + n.
* Union -> m * n.
* intersection -> m * n.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8f59fa7e-14c8-460b-9290-022e10462ae0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/567e2cfb-0bdd-4008-b37e-943d2fe7c16b)

* option **B**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5c39529-75dd-42be-8656-047a0c28745b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c3db2be-de86-481d-9a40-1d4ac3993a29)

* Deletion.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3993a45-c7fc-4551-8318-382cbe7a05c6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0625e87c-4628-4e0c-b8fc-28ae5cef1ad1)

* Option **C**.
* Decrease-key operation -> Decrease/reduce the key value.
* Deletion Time -> Theta(1)
* Decrease key Time -> Theta(n)
* Since as it is a sorted linked list after decrease key operation, we may have to perform **sorting** to make the linked list sorted again.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d7760ebe-aaac-4bb1-a0fa-241cb2a74469)

* Doubt. [Question]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e759dee-b5d7-41f2-8bfc-cbec142177db)

* Option **B** [Answer] 
* Finding **median** in an array -> Theta(n) [Unsorted array] [Worst case] [**IMPORTANT**]
* We have **n** unsorted arrays -> n * n -> Theta(n ^ 2).

## stack-and-queue-part-2 (21)

## Stack

1) It is linear DS
2) LIFO(Last in first out)
3) Top(Single end)
4) Stack implementations
 * Array
 * Linked List

5) * PUSH -> To insert element at the top.
   * POP -> To delete element from the top.
   * PEEP -> To display element from the top.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/597216e9-519e-43e9-b605-1a870a3d292e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/704d05f7-3df9-4e63-88e0-ceffe0e0d53c)

* top = -1
* It means that the **stack is empty**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71a4ebd6-79a0-433e-845f-861ce2ccd1f0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b17a60e7-8ebb-40bb-8e29-fc4cfc49bd86)

* Pushing element onto the stack.
* If we are taking a **fixed size** array or a linked list for **stack implementation** then we have to check the **following condition** which is **if top == maxsize - 1**. We are checking if the stack is **full or not**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db79b1d7-87ef-4373-93bf-8d888048c5f9)

* Algo to perform **PUSH()**.
* Time complexity -> Theta(1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76548c99-d83f-4e56-8e9b-c36ab8b79d98)

* Algo to perform **POP()**.
* Time complexity -> Theta(1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1ad97b1-acd6-44c2-8548-dc0ff259e776)

* Time complexity [Summary] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26825a92-395f-4375-931c-f070dc01ee78)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f4bb092a-5cf6-4eec-a4d5-94c250b7d8f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d69be4bd-9ef6-4a35-806d-5439547e7f4c)

* Stack application

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0113f587-28bb-40f9-b599-b4063c1bacdb)

* Expressions

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92d0a812-f8cf-49b1-ba3f-a5f8866c8177)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2364117c-473c-44fe-a508-dc41fbd5837c)

* Example
* Precedence and Associativity. [Left(L) and Right(R)]
* We have to read the expressions from **left to right**.

1) If the **precedence or priority** of stack[top] **lower or less than(<)** that of input operator then push the input.
2) If the **precedence or priority** of stack[top] **higher or more than(>)** that of input operator then pop the stack[top] and insert in an array.
3) If **precedence or priority** of stack[top] is **equal to** the input operator then:-

* If it is **right to left** associative then push the input to the stack[top].
* If they are **left to right** associative then pop the stack[top] and insert in an array.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f877ba5b-0804-418b-a57b-568ae6bec4a4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/15a3d064-4b73-411c-9fb1-e3369c73d506)

* Steps and conditions. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff4dedbc-5ab7-4fb5-bbe4-073ae1a24bf8)

* Between **multi(*) and add(+)** the precedence of **multi(*)** is **greater** and **multi(*)** is the **input operator** so **condition '1'** applied here which is push the input.
* **Multi(*) and div(\)** has the **same precedence** so **condition '3'** and as they are **left to right** associative so we will pop the stack[top] and insert into the array. That's why we inserted the **multi(*)** into the array.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d1acbc4-46f6-415f-be77-23595c976d45)

* Now we are checking **div(\) and add(+)**, the precedence of **div(\)** is **greater**, so **condition '1'** and push the input which is **div(\)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ae1ead97-df0c-461d-b3e7-7c0c27279d41)

* Now we are checking **div(\) and minus(-)**, the precedence of **div(\)** is **greater**, so **condition '2'** which is pop the stack top and push in array that why **div(\)** pushed in array.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2799185e-7511-44fb-a45f-a7a28b227150)

* Now we are checking **div(\) and add(+)**, they have **same precedence** so **condition '3'** and they are **left to right** associative so pop the stack[top] and push in array that's why **add(+)** pushed in the array.
* Finally **minus(-)** is in the stack.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d13fb55-8102-4eae-93fa-a3037ffcd4cb)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06e1377c-929e-464a-8bb4-69ca02dde902)

* As **input** is finished so whatever operators are left in the **Stack** pop them and push them into the array.
* Answer -> abd*e/+f- [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d7b0aa9-4ea9-4ec9-a1de-c528b9e7c95f)

* Question
* Precedence of **power(**)** is greater than that of **multi(*)**.
* **Power(**)** is **right to left** associative.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1f68e4a-a952-4407-aa50-8cf195657564)

* Postfix -> abdef** ** *+g- [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bdd07a4a-c8e4-4bbd-84fa-6b6ba4e9d0da)

* Max growth of the stack? [Question]

> 4.

* Min. size of stack required? [Question]

> 4

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99f3b79b-c98e-4957-8c84-d9de5a748aed)

* Solution.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be6b0169-25b5-49ee-8821-1369e4f3f4dd)

* Question.
* Min. size of stack = Max growth of stack -> They are the **same** answer only. [**VERY IMPORTANT**]
* Priority of **minus(-)** is more than that of **equal(=)**.
* **No. of PUSH** operation is **equal to** the **no. of POP** operations.
* **No. of PUSH** operation = **no. of POP** operations = No. of **operators**.
* The No. of **operators** we have pushed that no. of **operators** will be popped. This is for **postfix** expressions. [**VERY IMPORTANT**] 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cda5c85e-ec33-45ec-b367-d971b837341a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fa76ee98-2559-4e0d-bc35-f2436980b31f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62c689e9-cd95-41a2-bfd0-695bb282c2f2)

* Solution. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1f157ee3-636a-4c98-916b-b467c4aa47a4)

* If we have **brackets** then the solutions will be a **bit different**. [**IMPORTANT**]
* Always push **opening bracket** onto the **stack**. [**IMPORTANT**]
* After the **opening bracket** whatever **operator** comes next that has to be **pushed into the stack always**, the **precedence doesn't matter**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f66741a2-bd0c-4ade-991f-e77de2bb9b59)

* **Minus(-)** came and **add(+) and minus(-)** have same precedence and they are **left to right** associative so **add(+)** is inserted into the array and after **add(+)** opening bracket is there so we will just **push minus(-)** into the **stack** as after opening bracket the **next operator** is always **pushed into the stack**. [**IMPORTANT**]
* Never push **closing bracket** onto the **stack**. [**IMPORTANT**]
* As **closing bracket** comes we start **popping**. We will continue **popping** till we find the **opening bracket**. Now remove/pop the **opening bracket** from the **stack** as well.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f29fe18d-27f0-4947-b510-a157a13e0393)

* Stack is now left with **assignment/equal to(=)** operator.
* **Brackets** never come in the **post or prefix** expressions.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b8ae8b3-3ae1-4161-ae8d-278e9989b79f)

* We are left with **multi(*) and assignment/equal to(=)** operator and the **inputs** are finished as well. So will be insert the remaining operators into the array.  

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ab12523-723b-4422-969c-fd3534f2e1c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b35d17c-3b4f-49ea-9b40-8c9b74590da2)

* Solution  [**VERY IMPORTANT**]
* No. of PUSH operations? [**IMPORTANT**]

> **8**. Don't **count** the **closing bracket** while counting **PUSH** operations.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1086f4b9-de0c-4027-9fec-a6b2da24dbe8)

* Prefix conversion.
* Rules are the **same** only.
* We are popping **add(+)** operator from the stack then we have to pop two operands from the **operand stack**.
* Push the result back into the **operand stack**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b50f8722-5158-4aed-9042-537f0ab18762)

* End of the **input string** so we will pop from the operator stack.
* The pop will be **one by one** pop.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8646916a-5281-4c38-ba7a-278158e31bae)

* Solution.  [**VERY IMPORTANT**]
* Priority of **div(\)** is more than that of **assignment(=)** operator.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74aa2a40-658b-48dc-b7f3-b021edf62351)

* Solution.  [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/80016e40-4300-44f5-a261-4f24f1d8390b)

* Question
* **Multi(*) and div(\)** have the same priority but they are left to right associative that's why we are doing **multi(*)** first.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe27bd99-8ee3-4d0a-927b-166623192b77)

* Another way [Solution] [**VERY IMPORTANT**] [Faster Way]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/af48854f-f835-4089-b36d-c4d3e9aa2fed)

* Solution.  [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a4072f42-c6a4-4ec7-b479-3f7e49ac1865)

* Expression length -> 7
* No. of operators -> 3
* No. of push -> Expression length + No. of operators -> 7 + 3 -> 10.
* No. of POP = No. of push = 10
* Solution.  [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c549de3-13c5-49e0-818a-16d8f109b564)

* Another way
* No. of operand -> 4
* No. of operators -> 3
* No. of push -> No. of operand  + 2 * (No. of operators) -> 4 + 2 * 3 -> 10.
* Solution.  [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1b4e629e-35c8-4fb8-bb63-aa983afcd8dd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/13e423f6-c0ec-42b2-add6-0bb676c0e44a)

* Expression length -> 15
* No. of operators -> 6 [Brackets are not included]
* No. of push -> Expression length + No. of operators -> 15 + 6 -> 21.
* No. of POP = No. of push = 21
* Solution.  [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6661545-9997-4cb0-acf1-9b6f07aeebf7)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dc96fa1f-26cf-4d7d-a4c9-73938cdc9f82)

* Solution

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d053921-d646-4da2-82ca-221f7d749db9)

* We are going from **left to right**.
* When doing **evaluation** we are using **operand stack**. [**IMPORTANT**]
* When doing **conversion** we are using **operator stack**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c033c0fb-756b-4641-b717-8a2c77bac9f0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7d6be04d-28a2-4181-9c5e-658a0c24018d)

* Solution. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26d30f48-0539-48ec-8c9c-6f8502978f78)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6c4a1f0a-b0bb-494f-90fb-5455ea0c0e2b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0200f83a-385f-4166-a4f4-98505b311a41)

* Solution.
* Answer -> -20. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/189855a4-4eee-4ecd-adc9-25bfdd9aeda5)

* In **prefix** the reading is form **right to left** and we are using **operand stack**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2109c056-212d-48b1-85bc-d09dbd167662)

* Solution. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b41b9dcb-b07e-45f1-ab59-fea2b0c706ea)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92c6b17e-ad30-4b64-9790-ddccdb1744de)

* Answer -> 0 [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11492059-92a2-4e2a-87ec-4f82259d411a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9ee03d0-b985-4505-b707-bdbf7e83c368)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d7fe3a1c-9a07-493f-9bd5-c4da158b5d45)

* Explaination

## stack-and-queue-part-3 (22)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f33998fb-9318-415c-bd8a-3bb17b01c688)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8811673-d7c4-4ce5-bdee-f33a909c191a)

* Answer -> 41 [**IMPORTANT**]  

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/567072ec-b223-4c4d-af0f-b7ab6834766a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4dfd1e48-897e-46b2-8d86-5bfa4690e603)

* Option **A**.
* option **C** is for **prefix** conversion.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8993594e-2119-43ad-9df9-e29e577fb521)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d346300-6a9b-43f6-bbc8-b6b9b4931848)

* Stake life of element **1** is **y** only.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d02598b2-ce43-4e95-a134-cf23bc9a1c05)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b66e2c4-2083-4ffd-b52e-4fdbf5c1278b)

* Solution.
* Stake life of element **3** is **y** only.
* Take a **bigger example** for solving the question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92cc1f33-a361-44c5-933f-895368e7ffde)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/113ddf8c-44dd-4a6d-8b1f-8f755f9d8b35)

* Option **A**.
* Directly solve it using the **shortcut method**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/90d2c9dc-9072-41ba-8394-85c7a06ddac0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21deb83d-dac4-43c7-8927-0a54eb5c8928)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6cd9b316-695f-420a-afa6-c7d18df9e274)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c88e430-c2c4-4125-b72c-91fac8ce5e08)

* Answer -> 15 [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c297122d-e67d-43ca-b90a-c5ff9dadfebe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a99c2f3-790f-4c39-8cf6-be72d3600f41)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e9b1947-34a9-432a-a30a-884c44988515)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/829423b4-9d4a-4f67-8abc-9007ef4b0e32)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aaaaa6f3-5f59-4430-a53b-bcebcbfe72cc)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5753b91e-d7d7-4295-aee8-0f60b40ada10)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e7ff9343-d7c0-4f67-8fe0-e920058f6c92)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57517153-c864-4641-9c5d-449d95e981b9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cc5bf7e-6c74-42d6-b828-44355e6abcc0)

* Option **D**.
* Take an **example**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/321d356b-3fa8-4fe9-a30d-1f7e48f7af6a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c0221c8c-cbd5-4255-a70e-f081482fb785)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/772db596-74df-4a06-8414-d8e8cdf9ec15)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c31d2d7e-b0ae-4a9c-a02c-ff40f379051a)

* We are doing **evaluation of postfix expression**.
* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e089e6c-6c9d-4681-859d-3e9e003561d1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5eb61c2d-354e-42c5-bb7f-a843b189e266)

* Option **A**.

## Tower Of Hanoi

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/408013d3-9c7a-418f-93ae-1a647eba5073)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e1b14ce-81da-43fc-8a72-e1fd4e51f650)

* We needed **7 moves** to displace/move the **3 disks**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8493122d-0ff1-4e1c-92b5-0067f1eca162)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/133f4be0-2155-4259-9bf7-3733eb3cb4a7)

* Final movement.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/55d69639-74f3-4b8b-a92c-ad3a73c07e16)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8ac97998-c972-4b59-920a-5466d7105882)

* 2nd Recursive call.
* The function is calling itself **two times**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c68a663f-ef84-43b6-a9ca-303a9ac2cd46)

* Time Complexity -> Theta(2 ^ n)
* Solved using **master's theorem**.
* Recurrence relation, T(n) = 2 * T(n - 1) + 1.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea78a3fb-8295-4686-b754-55ad4cf0fa0d)

* In all of the **cases** the complexity is going to remain the **same**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a93d4999-e9c2-4c40-af9b-621b9e290f8a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4d30926-6b01-4902-954e-7534f31904f3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77629bc1-6527-4a4e-8948-854fe4cc2c3e)

* Code.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/736a17de-469e-45ca-912f-55ade214934f)

* No. of movements?
* No. of function calls?
* Expection questions [**VERY IMPORTANT**] [Formula]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92b9e3db-0f93-4f4c-be59-3380f1f758c5)

1) 4
2) 14
3) 2 ^ (3+1) -1 -> (2 ^ 4) - 1 -> 15
4) (2 ^ 3) - 1 -> 7

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9262669-44c1-47ee-a579-142583f71ca7)

* Between the recursive calls, one value is getting printed.
* **1st print** happens after **4 recursive calls**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76e6c8c4-fe85-4673-8baf-5fd7a70785ad)

* Solution [**VERY IMPORTANT**] [Formula]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95911262-6f8f-4d6a-aaea-6b26c1228e2f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abb9ce74-5fa4-4277-8c1a-7e6ca7161aff)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d7576c33-068d-47da-b0aa-425ac28f509e)

* Total **no. of function call** -> 19. [Yellow]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fd0260c-5d5d-4a6c-9cd9-fa80f2fbd183)

* Output -> 10 [Green]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bdbfc074-a0e9-4e04-9b07-8722e30e0963)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/89e94e76-7826-48a6-a477-e2bd1b3cc7ab)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/db952b21-28cc-48dd-a493-7c233228f6cc)

* Addition -> 9 [White]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/30cd1901-7807-490e-8cfc-bc992b67f9b9)

* Solution [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1703ff74-afa1-474c-93fd-5e91cb80b001)

* Output -> 21 [White]
* Addition -> 33 [Yellow]
* Function Call -> 67 [Green]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cf08cfe1-73f2-4b76-838f-cc5cd29d2ac7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ce04424-2d6c-4281-a484-59a764575187)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63e6e39a-32f6-4e0e-ab6e-b5745486bd14)

* Solution. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8fe7c3f6-67e7-4177-a2f1-4193ed75db04)

* F(9) function calls.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f86adb5a-67bc-4f3c-8f1e-794bab4f1cbf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/de90995f-b802-47bd-91ef-54e015d64d3c)

* Answer -> 16.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05668928-946c-41af-b82d-573c2ca729b4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/62a11f5e-451b-4f33-85bc-ae33b91fbc9a)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/12329739-4bca-4189-8515-136163bf0779)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39614d5b-5c5e-4c02-bd0a-86c8abeb8bc6)

* Answer -> 10011

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/933be8e3-c2b6-4be3-ba5e-338dd6718eab)

* Done earlier.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5736348-7125-4167-b630-5b522abf1c0f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bff93ee9-77f4-477f-ad5b-72f961a1f555)

* option **A** possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6d0c8be1-fc1e-4884-a585-e6ce9840f642)

* Option **C**. [Answer] [**IMPORTANT**]

## Queue

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d691dcb4-5950-4e37-9301-94a44c5c7764)

* Next class.

## tree-part-1 (23)

## Queue

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06040032-5ee6-45aa-b3a7-c97615a19482)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/235fb82d-4150-4c37-8eee-de282d0ec2ce)

* Algo.
* We are setting **read = front = -1** because the array indexing is starting from **index '0'**. **Index '0'** means we have inserted some element in the array.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d208e44f-0025-45d4-96f8-51282c4b607b)

* Static Implementation.
* Enqueue and Dequeue.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c9853a94-9378-4fef-9d5c-04e9af7e0b19)

* SLL -> Singly linked list
* **Enqueue** -> Insert at last in SLL.
* Time Complexity -> Theta(1).
* As we know the address of the **last node** of the linked list.
* **Dequeue** -> Delete at first from SLL.
* Time Complexity -> Theta(1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ae6afcd-cbaa-49aa-83de-c878d67fec19)

* Queue using Array.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc855c6e-2b22-4b7b-9c8a-886c09695985)

* **Enqueue**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5bd1a57-a4b0-432c-a026-a3466af201a6)

* **Dequeue**.
* Queue -> **FIFO** concept

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6b4ce698-df1b-42f2-b42d-ee0096015eb5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e47f4d9e-898b-4254-93a6-4ed3dbdcf12b)

* Queue using linked list.
* Enqueue.
* Time Complexity -> Theta(1).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e544dd9b-f739-455f-9f16-36a910899b82)

* **Dequeue**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/494e7242-65f6-43b5-9fa9-72206d6bb895)

* Limitation of **linear queue** -> Once **rear(R)** has reached to the last position of the linked list we cannot insert any new item.
* To overcome the above limitation we use **circular queue**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/43da26c9-2be1-41a9-9e95-08b96e4d72a9)

* Circular Queue

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e5817c4b-fcb7-4e3c-8c52-7fc1b64c0618)

* Queue is full.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4501964-37e5-4aee-b842-868bd5d19979)

* Deleting elements from the queue.
* MS -> Max size.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3ed65684-6184-460d-a2cc-6b9200dae97f)

* Condition for **Circular Queue** to be **full**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3730d184-5fa2-471d-9196-f8dbad391d17)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ade26522-e6ae-4b70-81d0-22bb2d91528b)

* Circular Queue using **Array**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/883ae952-a045-405c-a0ef-29cdbf8dc5e5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/72c12592-263b-4338-bf9f-c71d2f00a156)

* Enqueue.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bce0f7ac-c5bd-4e9f-b751-34eeefcff91f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f74ac8a1-edd9-4983-879b-8112fbf9bd88)

* Dequeue.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bac0965d-eb17-4086-a8dd-7ed30a49ea3c)

* Enqueue(EQ)
* Dequeue(DQ)
* Time Complexities [Stack] [Linear Queue] [Circular Queue] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef392185-86a1-42e8-b185-68e108720912)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a57f8869-1a48-4e5b-bd4d-e34c83e9df60)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01533ed1-a8a9-4c4e-8f35-e2eaccb00d77)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7e92908-f20d-479a-80d4-66ceeae39385)

* Time Complexities.
* If we only have **rear address** in **linear queue** then we cannot perform **Dequeue(DQ)** operation as we have lost the address of the **first node** in the **queue**.
* In **circular queue** if we have only the **rear address** then also we can perform both **enqueue and dequeue** operations because **rear.next** is **front** only. We always have the **front** address as well via the **rear address**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/11ca20bb-aba2-4f56-86b0-d9e92faf8fc7)

* Double Ended Queue.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e9dfaaf-66d0-4e9b-8537-fbf691f6725f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eb948a49-72a9-44fd-83f1-1cc82580b051)

* Operations

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ea0ae89-5502-40b9-9974-546ef46d71b5)

* All of the **operations** have **theta(1)** as the **time complexity**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d0c63d99-9b2c-45a5-b2cf-965504de82c4)

* Priority Queue.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/06e49c84-3bea-4abf-bc76-9a1a51c90c35)

* We want to make either **FIFO or LIFO** from **priority queue** and it is dependent on us.
* We are doing **ascending order priority** and **number '6'** has the **highest priority** which means that it has become **LIFO**.
* We are doing **ascending order priority** and **number '1'** has the **highest priority** which means that it has become **FIFO**.
* If we have done **random order priority** then we have to search the **whole queue** to delete an element.
* With the **priority queue** we can do **stack, queue** or any other **operations** and accordingly we have to set the **priorities** to the operation as the **highest**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19a5c73c-b392-4b3f-be04-70166d446cf7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/056bcf81-0254-416a-a5ae-72961d61cbe0)

* Option **D**.
* The last element that is inserted into the queue should get the **highest priority**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3e740d2-8ae7-4242-bf46-711f0521fc96)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/017bc33d-a52d-4023-b374-5ceb77cc0d6e)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3bc0432f-3307-41dd-b265-206b22254d76)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/500c11a2-21fc-4a1d-babb-13ac698d2e79)

* Ascending order

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/60898d9c-6dd1-4ecc-8858-2964d786fed6)

* Descending order.
* We had taken **3 elements**. The **no. of iterations** was **3 ^ 2 -> 9**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76586166-3747-4bd5-a8c9-b7d0f92a3fd0)

* Answer => 256 [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e376716a-1998-43a4-834c-6d53f2c19218)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fa670293-c7f0-419a-a3f5-0e6fa5c08a73)

* Option **A**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ef3cacc5-dc22-4430-bf9a-faa2a8ac74ed)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ebaa15d2-3475-492a-9bb7-85a88a077844)

* Option **B**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/47444ef3-4781-4b50-a6c6-905ccca162d0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f2b2c020-3a3a-43a0-b07c-d65f774e1ec4)

* Option **B**.
* Insertion will happen when the current function call is **terminated**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7cf9756-ed72-4e8d-b54e-eec319b6e6a8)

* Option **A**.
* As we are starting from **0** that why it is from **0 to (n-1)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/64f6ac3d-df44-46cb-a101-1ced2ec6834f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5f6e5a4a-40ff-407d-8a0f-9bf480b94415)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/debfa247-19ae-4344-82de-2caf40782307)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/963cd2a1-17ae-4ecc-b3ac-d9bc37657d0c)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/77c58ac7-f125-4f20-af09-b061f8402712)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/07ef9757-929e-4520-957d-6170efed8575)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/39567620-5d03-4db0-9fda-89ac2b75865a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d7ecea89-9f29-48bf-8600-f03c75e17154)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abf63774-e7cf-48dd-ac4f-9d7fc7252461)

* Option **B**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ec939c2-79e9-4cb2-a9e5-2d3470b07d8d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2aa4d5fb-abd1-4db5-b9d7-c8aedc32b46d)

* Answer -> 86. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9f0373f9-cc01-435c-af34-bbce8617b825)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/57cbec31-caf5-4e65-9c87-a47ea8bb47b4)

* Answer -> 8. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b80bed8a-5ceb-4c93-99aa-e8090897c5f4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/71da2cde-e8b1-49b7-b19a-331198e69155)

* **Linear Data Structure** -> Array, Stack, Queue, Linked List.
* **Non-Linear Data Structure(DS)** -> Tree, Graph

## tree-part-2 (24)

## Tree

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a9e9960-2deb-499e-9a88-a854bcbb5372)

* In tree data structure the data is stored in **levels**. That's why it is called as **hierarical data structure**.
* Sibling -> The nodes having common parent. **B and C** are siblng. **D and E** are sibling. **F and G** are sibling.
* Height of a Tree -> There are two different definitions. Based on the definition given, height of a tree can start from either **0** or **1**. If **height of tree** starts from **0** then the height of tree is **3** and if the **height of tree** starts from **1** then the height of tree is **4**.
* Degree of Node -> There are two different definitions. Based on the definition given, degree of a node can be either **no. of it's children** then the **degree of node(B) is '2'** or **no. of it's neighbors** then the **degree of node(B) is '3'**. By default we use the **no. of it's children** to calculate the **Degree of a node**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/831f65f2-f161-4fa6-87c6-1d45c28f2687)

* Degree of tree -> The highest degree of any node is called as the **degree of the tree**. The highest degree in the tree is called as the **degree of the tree**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/836dd86f-d953-4e0a-a2a4-89977e062e55)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b702952b-09cc-4efb-8794-7e4433f0644d)

* Types of tree.
* If the **degree of tree** is **2** then that tree is **binary tree**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21d034bb-3b18-4d2b-a883-05ee8b8ccce6)

* Full Binary Tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/560b853f-fb84-4165-b905-480c8c160369)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/877a6bcc-71f7-4a73-88b8-bdf834ff65e0)

* The **no. of children** the nodes have that is their degree.
* The highest degree is **3**.
* So degree of tree is **3**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8fd6c4c9-fde1-4d4b-adff-53f70e059091)

* Examples.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fad41a5d-c3f1-45d1-ab9c-fdd72d333114)

* One node has **degree '1'** so it is not a **full binary tree**.
* One node is missing at the last level so it is not a **perfect binary tree**.
* The data is filled from **left to right** but there is a right node but there is no **left node**, so it is not a **complete binary tree**.
* Every node degree should be **1** which is not there, so it is not a **degenerate tree**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d46243f2-089b-45f3-bc10-aa47de684a74)

* Option **E**. [Binary Tree]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/381bfd07-74f9-4fa8-81d5-1e119ca649e5)

* Root node is at height **zero(0)**. [Formula] [**VERY IMPORTANT**]
* Max. no. of nodes means that it is a **perfect binary tree**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a73e4f8a-dbf6-45ab-9036-cb263b1b1cc8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7222f939-fcb4-4f4c-811c-aaef7ee3fefb)

* Root node is at height **one(1)**. [Formula] [**VERY IMPORTANT**]
* No. of leaf nodes = (No. of internal nodes) + 1.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/792df572-3cd0-4b70-9278-5e1a405282a7)

* Total nodes = (2 * (leaf nodes)) - 1 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cec96e75-89f0-4ae3-b612-140f93dc3752)

* [Formula] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8390c8ac-fbd8-479d-8be5-4e53216f8fda)

* When the root node is at **height '0'** and we are storing the root node at **index '0'**. [Formula] [**VERY IMPORTANT**]
* We have to take the **floor value** when finding the **parent location** from the **child location**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5cf3b6a8-15a2-4829-803f-8392bd854a6d)

* When the root node is at **height '1'** and we are storing the root node at **index '1'**. [Formula] [**VERY IMPORTANT**]
* We have to take the **floor value** when finding the **parent location** from the **child location**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9d7c6efc-9433-4b72-9848-2b90740fd3f5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d0c69eb-6d58-41c6-9b68-ad3cd8a869bb)

* We have to take **floor value** for both of them.
* Representation of binary tree. [Formula] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/162c00ac-d5aa-4c65-b8b6-94825f1d5ec1)

* Linked List representation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b3f0af4e-36dc-4714-b3b1-dadc2771d417)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84527602-9074-4f1f-a177-32ae2128cf85)

* Insertion algo.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb72970f-68a2-49fb-a2cb-394907b0c978)

* Tree Traversal Technique.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9f4cc49-adff-4f3b-b9d6-b06d1a2a82f5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7f49921b-fe7b-4328-a961-be9087b568a9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/397ca32a-3324-45f7-af07-8d3ae71248f5)

* Converse Inorder -> reverse of Inorder [Formula] [**IMPORTANT**] [Example]
* Converse preorder -> reverse of postorder
* Converse Postorder -> reverse of preorder. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1953bab7-2cd7-4c30-87b4-e5bdb2699a90)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e69fb16a-c17f-4f0a-a97b-4ae737e82fd1)

* Inorder traversal(LnR). [n -> root] [Example]
* Recursive approach. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/54955e20-11a7-48c1-9e7d-b58ec9b1a3b4)

* Postorder traversal(LRn).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/982f35b5-b108-4a31-8eac-e0f7c390ccc2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56110e37-ee7e-43df-8b7e-25767c58f868)

* Tree traversal. [Example]
* Converse(C).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/876e724f-4448-41b3-8caa-66063893c8e7)

* Preorder traversal(nLR).

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2b3cad81-1485-48a8-b0a3-3f2f24e5a928)

* Question. [Example] 
* In -> DBFEHGIAC
* Pre -> ABDEFGHIC
* Post -> DFHIGEBCA
* Converse IN -> CAIGHEFBD
* Converse Pre -> CIHGFEDBA
* Converse Post -> ACBEGIHFD

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c2d00efc-d9df-41bf-9a2d-a8d145418471)

* Solution.  [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f403ef60-2850-4c58-a1f6-27d6cf5a22f7)

* Question. [Example]
* In -> DGFHBACYIKE
* Pre -> ABDFGHCEIYK
* Post -> GHFDBYKIECA

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d9a52a8-0769-4433-8c21-a325932f851a)

* Solution.  [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/151a47c9-4d6e-417f-a1b9-9fec28957951)

* Question. [Example]
* In -> BDCEAIHKJLG
* Pre -> ABCDEGHIJKL
* Post -> DECBIKLJHGA

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/23a54304-6edb-4388-b55e-4d80b9c9985e)

* Solution.  [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/948a28aa-ffc9-462e-a2e4-ad28aeb0bb46)

* Question. [Example]
* In -> DCBAEFG
* Pre -> ABCDEFG
* Post -> DCBGFEA

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7e0dc9c8-be27-4ab1-9b57-5c744a3415f4)

* Solution.  [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b80197c-af67-4fc4-afff-060535c3fb20)

* Question. [Example]
* **Brackets** have the **highest priority**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8563039a-f93b-42e6-89ee-6f0bdeb52464)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aed1b4a8-c989-4373-9491-1821e8716501)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e3d8bed2-2433-4927-ab19-231f21cd870e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a11444de-a380-42ec-93c9-bc8af8be2f2d)

* 1
* **Root** always has the **lowest priority**.
* Expression in question is inorder without brackets but it not always represents the **infix** expression. [**IMPORTANT**]
* Preorder -> Prefix.
* Postorder -> Postfix.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b7689cb-bd08-487f-b6f9-b99423eee76d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b79a4d4e-614f-47b9-baf0-e52f3aa79d45)

* 2
* For **infix**, remove the **brackets** from the **expression** and write it as it is. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/16f6a52b-35df-4081-b415-bbe09819141b)

* 3

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d9c6870-c6d6-4736-8a34-c19598dad157)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c1931a2-0208-4092-a970-6c2118237ae4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea0966a4-8f49-4dde-9daa-cefb6f1ef38a)

* 4
* **Infix** is exactly **same** as the question.

## tree-part-4 (25)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a3845186-79d3-43d3-be2f-fd07612548f7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/95da4c54-7db7-4903-b0bb-9cfe7c332a5d)

* Example [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/757fac80-6979-4bc5-a133-081c344cc7e1)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe8873f4-b86f-46b3-964c-188b7f707ca0)

* Solution. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed83830c-e400-4024-8bbd-4beb226b1852)

* Solution. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f05b1fc5-222a-4265-94c4-7bff18917cfe)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c85bfdd-1485-44e8-8737-78dc1202a4bc)

* Solution. [**IMPORTANT**]
* Check the **tree** once with the orders given in the question. For **verification** purposes.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f974fe22-81b9-4bb1-82ee-cc57ca7ecd8f)

* With **Pre and post** order we cannot make a **unique tree**. [**IMPORTANT**]
* We need **inorder** either with **pre or post** order to make a **unique tree**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ceb75bd-a406-4e7f-81b6-64a9c93de11c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/860683ce-aa31-447c-b1fb-d32b9c48fd3b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1dda6a38-dedd-45a2-ada0-8d9685dfa455)

* **Degree = 0** means further expansion of the node is not there. [**VERY IMPORTANT**] [Example]
* **Degree = 2** means that it has both the **left and right** nodes. [Degree -> No. of children]
* Postorder = Left Right Root(LRn).
* After tree drawing they may ask for **pre or in** order traversals. [Expected Question]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1eb57d1-8579-4d12-a060-3cce8757be6c)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5fab38d-5bad-4b26-9390-552c78fc7469)

* Solution. [**VERY IMPORTANT**] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9752d27-f757-48b8-be2e-431f67540aab)

* Not correct.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76185a5e-2e8a-4048-90ce-bfc4451a7e14)

* Preorder -> Root then left to right. [**VERY IMPORTANT**] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/056d5585-5812-4a75-83f6-f49c2e620ad6)

* Postorder -> left to right then root. [**VERY IMPORTANT**] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d9223eb-756a-46ac-af4b-4b99f60d2dfd)

* Inorder -> Left Root then remaining to right. [**VERY IMPORTANT**] [Example]
* First children of any node is considered as the **left child** of that node in **N-ary** tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/86af7d30-268f-4a73-8669-cd421d34e4ac)

* Question  [**VERY IMPORTANT**] [Example]
* Pre -> ABCDEFGHIJKLMNOPQRSTUVWXYZ
* POST -> CDEBHIJKGLMFONQRSUVXYZWTPA
* IN -> CBDEAHGIJKFLMONQPRSUTVXWYZ

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/88a1ffe0-fcac-4760-bba5-6acb23faa0ee)

* solution. [**VERY IMPORTANT**] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bf5251c4-886c-4977-88bb-6fae2907cb46)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8e6d255b-d717-4515-b79e-4a69e4a9a8b5)

* Pre, Post and Inorder -> They are all **traversal** techniques and we have to visit each and every node. We have to go to each and every node.
* Time Complexity -> Theta(n) [For all three tree traversals] [**VERY IMPORTANT**]
* n -> No. of nodes

## Binary Search Tree

* First key becomes the **root**.
* Number less than **root** -> Left subtree of root.
* Number greater than **root** -> Right subtree of root.
* If **number** is equal to the **root** then that will be mentioned in the question what to do with it. It can go in either the **left or the right** subtree.  [**IMPORTANT**]
* **Inorder** traversal of a **BST** is a **sorted sequence**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/92551be9-8a4e-45a9-bd03-77418beb38c3)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4d72716d-2149-423e-8688-e78d32b8c3db)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e2cdd4bd-ab32-41fb-9503-500cd626f4d7)

* Solution. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2b7ed0ef-3a9b-4d70-b300-df82bece6d03)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a103a422-98bf-4691-9173-439a7b76f8c0)

* Example.
* No. of BST -> 2nCn/(n + 1) [Formula] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da84a028-9280-4f7f-b872-f3e5a7721f3e)

* Solution. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/293bb495-ea50-4e8a-aa97-6176886b07c3)

* No. of BT -> 2nCn/(n + 1) [Formula] [**VERY IMPORTANT**] [Example]
* The no. of **binary search tree(BST)** possible those many **binary trees(BT)** are possible but in the case of **unlabelled nodes**. [**VERY IMPORTANT**]
* The no. of **binary search tree(BST)** possible for **label nodes** those many **binary trees(BT)** are possible for **unlabelled nodes**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b09d7b50-ab85-42c8-b68d-efc0c7e2a9ab)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c9c4e45-8017-4e96-b87b-3f92681bc869)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d8a095ce-cb7a-4208-9a47-96318079725f)

* Solution [**VERY IMPORTANT**]
* Answer -> 30 ways.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/04c95573-4ad5-4aa6-9dcb-67d1760873b9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/da328ef5-22bd-445c-9926-11c2cb8347cd)

* How many **Binary Tree** possible?
* Solution. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbbc0ff9-eac4-4839-9e29-b02ba38297b2)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/00402df8-f5ae-416d-85fc-1a106d8814ff)

* Answer -> 1 way. [**VERY IMPORTANT**] [Solution] [Example]

## graph-part-1 (26)

## BST

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f083ad3e-29cc-4072-83ed-457184dcc0d7)

* Height -> Max no. of edges from root to leaf is **height**. [**IMPORTANT**]
* Height of the tree?

> ** Height -> 4**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e0cc1de-3873-42ad-9614-03d3fb11437e)

* Solution. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c31d5052-b0a6-4445-80a6-83f221e1e357)

* **Leaf node** we can **delete directly** after **searching** of the node is done.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4c72183a-64fa-4fc7-bb2e-6f68fef48759)

* When deleting **17**, in-place of **17** we are putting the **child of 17** node in that place.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cded79fd-0524-4775-9e3d-57c6fd012bf8)

* Deleted **17**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/031490c1-40a0-413c-93fe-e4b66d604a14)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a44552c-0bb8-4a68-af0a-7eb9b22d27ac)

* In place of **10**, we are going to send either **inorder successor of '10'** which is **3** or **inorder predecessor of '10'** which is **11** here.
* Either **inorder successor of '10'** which is **11** or **inorder predecessor of '10'** which is **3** will take the **position of '10'**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a84a7c68-5b0f-4a0b-8813-4d949eef5b27)

* Either the **order of inorder successor** or the **order of inorder predecessor** will be there in the **options** as the **answer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e4db998c-b5ae-439a-b2b4-3785f9f4f4ad)

* Question.
* What is the **max height** of the tree after **deletion**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/63877ce4-48dd-447f-9c65-d8bb23e2853a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/158d458f-bdad-4721-a1eb-27b4e990d6a1)

* Solution. [**VERY IMPORTANT**]
* If we take the **inorder predecessor** which is **5** then the **height** of the tree is **4**.
* If we take the **inorder successor** which is **11** then the **height** of the tree is **3**.
* So we have to find for **both** and check who has the **max height** of the tree. [**IMPORTANT**]
* Delete the **elements** one by one only and draw tree after **each and every deletion**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/59b725df-bcc9-476e-a1dd-4e34b51b8c1a)

* Worst Case
* **n** nodes tree then we have to do **n** comparisons.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6e24f4ab-1c03-48ab-87c5-b60f903dea73)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/740b96f6-829e-4ef5-b8be-50fad1741634)

* BST complexities. [**VERY IMPORTANT**]
* Insert/Delete/Search -> Operations
* Time Complexity -> Theta(1) [Best Case] [Operation performed on the root]
* Time Complexity -> Theta(log n) [Avg Case]
* Time Complexity -> Theta(n) [Worst Case] [Operation performed on the leaf nodes]
* To reduce the **worst case** time complexity in **BST** we use **AVL** tree.

## AVL tree

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b311cfc9-a1a7-4f40-806c-ba68052e1671)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/81a0ef37-1019-4374-8333-ddad2e2b6641)

* Rotations.
* Balancing Factor -> -1,0,-1
* Unbalanced Factor -> -2,2.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/10355b14-c601-49a2-aa31-e707b80a5f8c)

* **LL** rotation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/35465c6c-0e39-4538-a6ab-3673a10054f3)

* **RR** rotation.
* **LL and RR** rotation are mirror image of each other.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6c7a32a-ee82-4155-bc07-ae07431215ee)

**LR** rotation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22347b89-5e76-479e-bdad-055e4a2e2474)

**RL** rotation.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/618030c7-4e84-4acb-973a-ec721b20cdd2)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ec8ca04e-41f9-4c48-8f8b-b60cba01ac36)

* We have to do **balancing** of the **lower node** because if we do the **balancing** of the **lower node** then the **higher node** will automatically be **balanced**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0460f0d9-6446-4c60-98e8-a7062bad310a)

* Solution [**VERY IMPORTANT**]
* Proper height tree
* The **input** is the **worst case** for **BST** we would get **theta(n)** as the **time complexity**.
* With **AVL** the **worst case** for **BST** is changed to **avg case** and we would get **theta(log n)** as the **time complexity** for the **height** of the tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3e0c926d-ebff-4874-9b3b-9d3718a9646b)

* Total no. of rotations in the **AVL** tree?

>  **4** LL rotations.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7bfa459b-f078-4bc5-9c07-29fd949a1bcf)

* Solution [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/acfea5ff-309d-4af3-8e93-1cdcc3b626bd)

* Example [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2dd9beac-6532-4000-bba6-50e9d972a897)

* Example [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8d4bb5ab-3164-402d-aea0-04c787c57951)

* Example [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/720a7ca0-274a-43ca-bbf2-f02fa9ff6dee)

* RL at 4 -> LL at 7 then RR at 4

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/85e01da6-ca8b-49d7-ade4-5abd6c6bbcfc)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/209f275b-104f-4ae2-a577-d3cc4a0e7456)

* Deleting **14**.
* **RR** rotation.
* After **any operation(insertion, deletion)** the tree should be **balanced**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8320669e-4a0a-4744-b0c1-15383a43d96d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b9d1f982-51ff-4631-9c47-c5d45630f429)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ecc5ea9b-dbb5-4da3-bc48-abe30197de40)

* **AVL** tree complexities. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac4536d1-2cff-4eba-be78-04b5ba0eb1cd)

* [Formula] [**VERY IMPORTANT**] [Question] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3107445e-4052-4df3-a419-e45ffd9c77e6)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bd16cf1f-a3b1-4075-a75b-6ae6e4198aa7)

* [**VERY IMPORTANT**] [Question] [Example]
* After getting to the required height check if the **nodes** are balanced or not. If they are **not** then try to **add min. nodes** to make the **unbalanced nodes** into **balanced nodes** to get an **AVL** tree. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3b394134-dcc1-4603-8b29-270bbb3f42c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/61e7961c-9db0-4bac-bc6d-50f9928cecc5)

* [Formula] [**VERY IMPORTANT**] [Question] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22c4783b-d3ba-4eba-a04b-3a3fa77ccfc2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1b994d34-0bff-47a6-b760-1e945b643681)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/84d90a26-0c23-4cc3-a97a-29476ac9b81f)

* Example. [**VERY IMPORTANT**] [Question] [Example]
* Or use the **below formula** and find the **answer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f2c36eea-347a-497c-bfcc-663ffba89d1f)

* **Max height** can be found out this the **above data**.
* **Max height** -> **Min nodes**. [**VERY IMPORTANT**] [Formula]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a63502ba-adfa-41f1-a114-fc6858fbcdba)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4745a392-1b13-4abf-a874-2f25e826a0be)

* This is used to find the **min height**. [**VERY IMPORTANT**] [Formula]
* **Min height** -> **Max nodes**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/05bb8e59-508d-4e7b-b2ce-b757cee5bcbd)

* Height finding.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7b3e2a97-33aa-4c4d-8f68-65ae2086647d)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cfd19652-438f-47c0-9a00-f94c05af079a)

* Height -> 5 [Solution] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/83e79468-cc4b-4844-932f-ad2a2ee72e37)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/694f155b-6d55-49f6-bd4e-05a999c68676)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3efa3958-3cc6-4de7-aee7-9480d2185803)

* Min Height -> 5 [Solution] [**VERY IMPORTANT**]
* Max Height -> 7 [Solution] [**VERY IMPORTANT**]

## Heap

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df3185b2-e3f7-4abf-a4bc-94fed4e218e9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/27fba12d-ff01-491c-a6bd-2804c56e0a48)

* Max and Min Heap.
* CBT -> Complete Binary Tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b1382baf-0ec6-467e-8310-59dd70a06fe6)

* Complete Binary Tree. [Example]
* We have to insert the nodes from **left to right** into the tree.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a298ed66-9ec8-4af0-9a3a-76b66d001905)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b45b55e9-0890-4a12-84f7-093f9f0915be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0293672a-3ce0-4c30-a5af-812c9d3a1928)

a) Doesn't follow the rules of **CBT**. So not a **max heap**.
d) Because of **10**. Not a **min heap**.

* Solution [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fdee8b03-f6e4-4ce1-9830-da5ff4ffa87c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9590cb7-ccf0-4ba3-bc9d-64f6544a9a88)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/41e23db1-ae63-4565-b8ca-13f1f732b374)

* If the **left side** is empty and the **right side** is filled then it is not a **CBT** and hence it is not a **heap**. [**IMPORTANT**] [Example]
* If it is an **n** level tree then **(n-1)** levels of the tree should be **filled/full**. [**IMPORTANT**]

## graph-part-2 (27)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3363002-c096-41cd-89a9-e2341bda04ca)

* Max Heap.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dee38301-e182-450e-8d6a-82a30de221d9)

* Structure is **fixed**.
* If not following the property of **max heap** then we have to just **swap** the elements.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/29173848-2122-45f1-a55c-51c3699313b7)

* Total swaps = 5 [**IMPORTANT**] [Solution] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4082dac9-1745-45cf-8388-29a969ff7148)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/28fd5ab4-d0ee-4ca6-bae6-3b5fc20672d7)

* Total Swaps -> 6 [Solution] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b29432f7-e5ff-4a3b-8976-d947c5673bf7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/972ec74f-23d6-4bda-b142-ad784763837b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8fb4aa75-af9c-4456-a562-33fee0668ee8)

* Max VS Min Heap. [**IMPORTANT**]
* The **smallest** element in **max heap** can be anywhere in the **leaf nodes**.
* The **largest** element in **min heap** can be anywhere in the **leaf nodes**.
* We have to do **(n/2)** comparisons atleast to find the **smallest** element in **max heap** or the **largest** element in **min heap**. [**VERY IMPORTANT**]
* In **worst case** we have to do **swaps** similar to the **height of the tree**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1b00784c-d25d-4ab1-b239-b659f9b58122)

* Time Complexities. [Heaps] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cd7937a0-da45-462f-85d5-8a1ff297084b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9cd1472d-b0de-492f-b56a-0ce1d8b628fe)

* Example.
* The **last value/element** of the **above** tree is **2**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0a5810bf-ec42-4128-83e1-d32eb64c0731)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65cbee57-fa2f-4946-9ed5-a91bee61419b)

* We have **deleted** the element **200** from the **max heap**.
* We are deleting from the **root** and root is **100** so **100** is **deleted**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5093823f-9b90-42ca-99e9-f265e135f536)

* In place of **100**, the **last element of the heap** will go to that place as **2** is the **last element of the heap** so **2** goes to the **root**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bbdf0947-9270-41fa-b7cd-472931fd6341)

* We are deleting **50** as **50** is the root now.
* After deletion of a node we have to do **heapification** so that the **heap** is in **max or min heap**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82dd6816-12a6-4a98-b096-a8e469212a30)

* Heapifying [Example] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/044421f1-bb05-4472-83f2-814baa64574b)

* Elements are in **sorted order**. [Heap Sort]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2fd3ef1d-129c-4ded-b2b1-ec66482febe9)

* Time Complexities.
* Time Complexities of **Heap Sort** -> **Theta(n * log n)**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2d9dc32a-00ae-4985-a774-43b24e2751c7)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7b53e55-93c1-4abb-970d-0ce2f2168932)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36ea061f-e2e9-4451-8598-5b27ca947e3c)

* No. of swaps -> 4 [Solution] [**IMPORTANT**] [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be76bf4c-0717-4713-b069-da2fa7ead88a)

* Question. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/24d03198-79a9-45de-aa83-059114b0bb40)

* Total Swaps -> 3 + 6 -> 9 [Solution] [**IMPORTANT**] [Example]
* Build Swaps -> 3
* Delete Swaps -> 6

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb97d782-1122-4bf4-bcaa-1dcb26215a60)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5c292907-bed0-4675-b1a4-789ab33371b6)

* We have to send the **last element** of the **heap** to the root of the heap when deleting the **root of the heap**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0e35095b-9ceb-4ff0-8672-e419a08ee751)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2b15289b-4b3b-4a8f-9467-4999c2b60db5)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8f2bfc5-ff95-4e50-aca5-b61797d147cd)

* Solution [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a83aa37-b239-4663-8fee-29cd63a57023)

* **n** unlabelled nodes.
* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b5aa4b1c-eb94-4388-9390-2ee654a783bb)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9a036cf2-a7dc-44cf-b0f6-1d13bf5524bf)

* Inorder -> 41673258

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21b01d5a-2482-4168-8a67-372972c053e1)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bce45fac-90f8-4525-b694-db8a09600693)

* **Trick** -> Instead of drawing the tree we can just count the **no. of elements** on the left side and the **no. of elements** on the right side of the **root** node. [**VERY IMPORTANT**]
* We know in **BST** the first node is the **root** node so **50** is the root node here. So the **elements less than '50'** are on the **left side** and the **elements greater than '50'** are on the **right side**. Just count the **less than 50** elements and count the **greater than 50** elements. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb841251-d8ee-4c88-b768-25c58e832ff8)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/784efda3-abf9-4f60-ae6b-51b5a82623c5)

* Option **B** [1]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/41cc3d5e-5d9f-40e9-adec-fdbc71c4f9c2)

* Post -> gcdbfea
* Option **C** [2]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a6afb517-1916-4fdf-90e4-916283dd21c4)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b9cc6ded-23f4-4ea9-a6d4-26f2d764d7c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/51957343-80ee-424c-9f4a-37c3f896ba18)

* Option **D** [**VERY IMPORTANT**] [Practice Again]
* The **inorder** of **BST** is always in **ascending order**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a3082958-53e5-47d3-98fd-bb35deca9371)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a8934ba3-2260-4b13-bddb-6a69bd8eb1bf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c3c5157e-74ce-4c9a-b419-bf08bc8f1281)

* Option **D**.
* It is not necessary that the **last element** of **pre and in** order will be **same** as they have **Right(R)** at the **end**. If the **right child** is missing then the **pre** will end with the **left child** and the **in** will end with the **root**.
* If the **right child** is there **guranteed** then we can say that the **pre and in** order **last element** will be the **same**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c265a675-d014-48f6-8a67-eb44a0946b0c)

* Question.
* As **7th smallest** is the fixed value so we have to do **comparison** of all the elements that are present in the **heap**. So we have to do **constant** no. of comparison.


![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/93cf63ac-324c-4bc6-af06-fceec15e3802)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5077dea-ddca-45f0-8ba2-b954f0261833)

* Option **D**. [Doubt] [See the below video]
* Link -> https://unacademy.com/goal/gate-cs-it/NVLIA/doubts-and-solutions/doubt/88E84AF95E
* **7th smallest** is a **constant number**.
* It is going to take us **constant or Theta(1)** time.
* In case we were given some variable like find the **nth smallest number** or **n/2th smallest number** then in that case the **time complexity** will differ.
* Link -> https://gateoverflow.in/1110/gate-cse-2003-question-23

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f7af2017-c685-48cc-aece-9d79983547dd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b32a9ede-d93e-45b7-9716-feb8eda06355)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f367c7fe-03eb-495f-b109-396d4243ac46)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0f632b4e-58aa-428f-a81f-abe82166bdf4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7dde72f0-20ef-47da-81b0-7e2725afbe42)

* Option **D**. [Theta(1)] [**VERY IMPORTANT**]
* The **max.** the **7th smallest element** can go is the **7th level** and it cannot go **below the 7th level**.
* If **nth smallest element or n/2 element** then the **time** wouldn't have been **theta(1)**, it would have been **different**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/69a61aee-44c7-46fc-bcfc-83079294c228)

* **nth smallest element**? [**IMPORTANT**]

> Time Complexity -> Theta(n). Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/45031164-2f41-4f5e-b601-a5e5f19b17e5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e20a0147-6487-42c2-8fca-c96d563e5934)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2668de1d-2dec-4adb-8dbe-d6fe47c376ad)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/36de6657-a181-4cc6-a3e8-33f9bcbc7ea3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2eb3c45-03fa-4d0f-bf31-b1bfb1f2629e)

* Option **A** [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df592b81-e495-4f1f-b45b-6bc90c3862c2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ea3a424f-d58f-4764-b123-579a375e7c34)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d359befa-5b66-4088-8ed8-80db7da3d739)

* Option **D** [**IMPORTANT**] [Graph]
* DFS 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a30f71af-e5be-450b-813a-1e066fda8769)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/120a3cbf-9903-416f-ab85-f53e31aa3628)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6f899aa9-8422-4a3a-9da6-cd61e8bcf0f2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/680862ef-76ee-412d-9219-628d24dc0299)

* Option **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f4f04abb-c08e-4252-8141-ba826a5825f8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e753cc13-f7bc-46f0-b883-bbf46c35d71a)

* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3095fc0c-ae83-45f2-bf6d-6805b6e47ca7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a9e47bd9-3a1b-438c-9a40-f66bad0e0b7c)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c47cc38-a0f2-4ee5-bb8f-34186be25900)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9c3b9dd-1730-48c2-aa7d-440324b81a36)

* All parent values are larger than their children.
* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/caab8eba-2666-4234-94f9-7492a975057d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5d54d56f-045b-4f2b-992d-cb4cbd895675)

* [2]
* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f1a5a8c7-3ea0-48f0-bb8d-d41d1023b5d3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5fbc050e-d918-4631-8898-8f81b642f531)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f5b1f9ae-1e91-4c93-9d68-edb932183c5a)

* Option **D**.
* Max nodes -> (2 ^ n) - 1 [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b8f83f7e-4a03-4983-8914-f9845faa0e1d)

* Question
* Link -> https://gateoverflow.in/974/gate-cse-2006-question-13

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b4a12509-267c-45c7-978a-057e88ddd8e8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/aa46b1a3-406a-4f81-9be2-ee2b5fee1988)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/82208793-7f93-4842-81cb-953f3e07381f)

* Solution.

## Questions

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ac9d8a18-615c-499a-9685-4fb8f50932a9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f28a30fd-be8e-4647-b024-85e2715f95bf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f74a4876-5996-44c4-a9ce-806f6ea035d3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5b71d4c8-e995-4278-88bd-2d677b05d56c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb30afb4-1f06-47d0-8d83-80f0bde70fad)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d9f49cb-8a6a-4ee2-be99-bb2a14aab866)

## practice-sessions (28)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7ad3e7de-35ea-45e1-865d-73a1cfcc90dd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8182b401-f1bf-42b1-9c88-35986016427b)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1708be6f-b4a0-448b-b09a-d3f93c4f3a44)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2c98fdc8-637a-4ad4-a348-5429c4b608a1)

* Option **C** [**VERY IMPORTANT**] [Formula]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d5328803-7af0-40de-9999-0a13cb5c693a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ff3cfb38-8047-4556-b481-a1690b780096)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb89b91f-2cb7-46b1-b9d7-0b639315c604)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/174471ea-e6a4-4bff-a982-efd4c1a26c28)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f72c0a75-609b-4236-89e6-3442adde1516)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6f7d345-4a93-46af-bed6-491722e315b8)

* Option **B**. [1]
* Option **C**. [2] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fb64ef68-0c1d-453b-ad5a-cd7d399c521e)

* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a95bb47-558b-4213-b089-b66fc331137b)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3a84214b-22b0-41ae-a3cf-443d796938aa)

* Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b6026051-b89f-4223-9bf6-2308016c2801)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/326e9536-279e-44ee-a847-20d75c20380a)

* Option **D** [1] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98528f8c-b586-495d-855f-dbbd020e6c8f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8c02a2f8-f50d-40c2-879e-c712bb4376ca)

* Option **B**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ffb431f8-3175-4a37-83f3-67f3f3ad559f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/69135500-4bdd-47ca-bcd9-3e25f8a3f33c)

* Option **A**. [1] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/399d532a-9091-45b7-bfdf-3723e6b2d3c6)

* Option **B**. [2] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/19ad5803-4eae-47c1-951e-7c469c9d9c4d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/249d8926-ac6b-4629-86cd-d92de207d0c9)

* In the question we are given **n distinct elements and an unlabeled binary tree**. 

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a9dd49b-b762-471e-bb44-a9b9d807ac44)

* If structure is **not given** then we will use the formula of **2nCn/(n+1)**. [**VERY IMPORTANT**]
* If structure is **given** then we need to insert the **keys/elements** into that **structure only**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bb3131ce-671c-4c2d-9af5-a73f4daaaa01)

* Unlabelled structure.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1938f51d-e8bd-42e0-a118-1fa584caa748)

* Explaination.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01353a57-b2e7-4800-83ca-9c13a28fbcd9)

* Question [1]
* Link -> https://gateoverflow.in/2183/gate-cse-2010-question-10

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fd9503a7-2ce2-438a-9d8c-f65891860e47)

* Solution. [**VERY IMPORTANT**]
* Zero Child -> 1 descendant -> Odd descendant
* 2 Child -> 3 descendant -> Odd descendant

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/219c5684-84b2-459c-aaa7-c20a85ae9eaf)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b531a08-72e1-434f-8832-0b7b7e625897)

* Option **B**.
* Heap Property -> CBT.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c6bd0a1e-17fb-4af8-903b-6da284acf4e8)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a521f39b-0968-4117-8ddb-e1e3a1a24f87)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/dbdd6ebd-0362-46c5-84bb-50c5fc95a869)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/97f2a0ed-7d05-42bf-aa85-69be93cd4a4e)

* Option **D**. [**IMPORTANT**]
* If we know the **preorder** traversal of a **BST** then do **normal insertion** into a **tree** there will be **no problem**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8dc6e047-a018-4c81-8dbb-c1d4198dd99e)

* We know that **inorder** traversal is **ascending order**,

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b18a0df7-88bd-4bdc-a371-128f8eac84b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4cee29bf-d98d-4945-9418-14f62299ff7b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/335946c0-7b25-4118-aef3-8c16f8722ff6)

* Option **C**.
* Tightest Upper Bound -> Worst Case.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a742c4c1-9618-4d66-bc62-9580e780bbb5)

* **log n** time required to find **L and H**.
* Between **L and H** we have **m** keys.
* To find the sum of **m** keys we need **m** time.
* So the total complexity is **theta(log n + m)**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4519607c-ffc0-4dfc-b3b8-3f7693147027)

* Answer -> 110 [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f10116aa-2f99-4b78-977a-081f730a8fd3)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/56a4ef44-bdf4-4b9d-9ac0-d304e5802fd4)

* Inorder -> SQPTRWUV [**IMPORTANT**]
* Option **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c82fcfe3-ff13-4b92-b01c-b118c151e5a4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/64e20078-c528-400f-a50a-f7b62da6579b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/32404b63-2054-4e8d-ae06-ccc32c3a63c9)

* Answer -> 6 [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d50fab2-e098-411c-af71-6c20cb2ceaf4)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bc158350-0d72-4f33-9124-cac4341a40bc)

* Option **A**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/924550a3-a357-4f67-91b7-8bb39fb88956)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3d057686-e7d6-472d-8826-33d020437398)

* Answer -> 199 [1]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1270a96f-fe25-4a2c-bed8-979dc889955b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e2ff302f-740c-4d02-9523-f91e4acb54fd)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0cdfb032-961a-421a-8c07-383d56423d5a)

* Option **A** [1]
* In **Full Binary Tree**:-
* No. of internal nodes(I) = Leaf nodes(L) - 1 [Formula] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc36cfce-1b1a-40ee-b699-ad58334fa662)

* Take an **example** if not remembering **formula**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/401adcb4-2ed9-4c1f-a5c4-622326b3bf06)

* Option **B** [2]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9b6940b-9a1c-4a99-b3c0-4e7cb6ecd846)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/edbea984-be97-456b-9341-ec4e5d2d3950)

* Option **D**.  [**IMPORTANT**]

## graph (29)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/798424e4-78cd-4daf-aa30-4db3058977d6)

* No **PDF file** download available.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1eb7f8e3-c1cd-4f72-af33-5be3f2b86b32)

* Edges are **optional**.
* Vertices are **not optional**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/292420a2-4b74-46c5-a98d-1648b0e0022d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f8a10a4c-0718-4433-8b06-fe3b6d6a9096)

* Graph representation.

### Degree of Graph

* Degree -> how many neighbors of that particular **vertex**. [**VERY IMPORTANT**]

1) Undirected Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fba751cc-3c8d-45a5-9ee8-f71903cfd20d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ea351d0-fa63-4fc3-b431-0688ccfaebf0)

* Example
* Sum of degree = 2 * (No. of Edges). [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0063165a-73bc-4825-b4e7-cb5d1d43c843)

* Points [**VERY IMPORTANT**]
* Sum of degree of all vertex is always **even**.
* Number of all odd degree vertex in a graph is always **even**.

2) Directed Graph

* Indegree -> No. of incoming edges to that vertex. [**VERY IMPORTANT**]
* Outdegree -> No. of outgoing edges from that vertex. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e3279806-b5dd-445d-89f6-7bbdebd42d78)

* Example
* Sum of **Indegree** = Sum of **outdegre** = No. of Edges(E). [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9441cd69-3e28-46d4-9f05-891cbc8ea24a)

* Types
* Connected Graph
* Disconnected Graph

## Connected Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c797f5be-3bf7-4e05-8f8c-0af7c33c9241)

* What is the **min. no. of edges** in connected graph of **n** vertex? [Formula] [**IMPORTANT**]

> **(n - 1)**.

* What is the **max. no. of edges** in **simple connected graph**? [Formula] [**IMPORTANT**]

> **(n * (n - 1))/2**.

## Disconnected Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/882728e9-3def-4f2e-b45c-4f64e2603a3f)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/08e6b73d-fb7d-47f5-a5ed-69b1d2a4cf53)

* Min edges -> Zero(0). [**IMPORTANT**]
* **n** is the **no. of vertex**.
* **k** is the **no. of components**.
* Max. no. of edges(E) in disconnected graph :-
* E = ((n - k) * (n - k + 1))/2 [Formula] [**IMPORTANT**]

## Simple Graph/Multigraph/ Pseudo Graph

* Simple Graph -> Without parallel edges and self loop
* Multigraph -> With parallel edges but no self loop
* Pseudo Graph -> Both(parallel edges and self loop) are allowed.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a47b70e-51da-4af7-980b-d6322254f0bd)

* Example [**IMPORTANT**]

## Complete Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b05fefb2-9688-4a6e-9aa2-6967e657abb9)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/796ef19e-1625-4eba-98e1-d0afb10c57f0)

* Complete Graph -> It is a simple graph in which all vertex is directly connected to each other.
* kn -> E = (n * (n-1))/2
* n -> No. of vertex.

## Regular Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b21cee12-1488-4f0d-b85b-3d8ca8c88503)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/abf625a4-241b-4f3a-9f83-12eda3f5f7a2)

* Regular Graph -> A simple graph is said to be regular if degree of each vertex is **same**. If degree of each vertex is **K** then it is called as **K** regular graph.
* Every **kn** is **(n - 1)** regular graph. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/50fe05c1-9e9a-4aea-baa8-f7f831e11b90)

* What is the **no. of edges** in a **regular graph**? [**IMPORTANT**]

> E = (k * n)/2

* k -> Degree
* n -> No. of edges.

## Cycle Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cfd19a59-a7f1-4711-871e-df0093b78384)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c92a1a5a-eb5b-4f07-a610-07c886c78320)

* Every **Cn** is **'2' regular graph**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/247b6f65-7233-4092-b78a-0dd964b443e5)

* No. of edges(E) = No. of vertices(n) [**IMPORTANT**]

## Wheel Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9ab11d24-67f1-472b-bd18-a83ccfdf156c)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21b84667-1728-442e-9ab3-bbc08bef7da8)

* n -> No. of vertex
* E -> No. of edges -> 2 * (n - 1).

## Null Graph/Void Graph/ Empty Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4df982f9-bf1a-4248-89a0-2c0437ec6d83)

* A graph without a graph
* No. of edges in the graph is always **zero(0)**.
* E = 0.

## Star Graph

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f32879bf-c294-454d-a85f-716e429a3c0d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f78afe01-180b-4e96-b9b8-86fec4861842)

* No. of edges(E) are simply **(n - 1)**.
* E = n - 1.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/832be658-53e2-4e0f-b756-4ed791e59199)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fe13280a-78a5-4c10-a93a-cca1b7ef496c)

* If we identify the **cardinality** of the **set(1,4)** which is **2**.
* **Cardinality** of **vertex** is the **degree** of that particular vertex. [**IMPORTANT**]

## Adjacency Matrix

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/852302b7-e683-4fd6-9b45-b55604f164ca)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/483e3804-62c5-4410-b1e4-dfb75ae2fe63)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d6cf8560-f680-4d46-a9bd-bf88cf53dc08)

* If we do **sum of row or sum of column** then we will get the **degree** of that specific vertex.
* This is for **undirected graph**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f60ba951-d7c9-4930-98c0-dce88b5e5ffb)

* Example.
* **Sum of row** represents **outdegree** of that vertex.
* **Sum of column** represents **indegree** of that vertex.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1687ce46-cc2b-4e82-9d75-81e155253f76)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6a6742c1-e059-4d74-b751-71a88af7299b)

* In the **rows**, the **positive values** are **outdegree**.
* In the **rows**, the **negative values** are **indegree**.
* In the **column**, the **positive values** are **indegree**.
* In the **column**, the **negative values** are **outdegree**.

## Incidence Matrix

* Vertex(V)
* Edges(E)

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2b5aa30-4e25-4469-b8b4-e534fd040980)

* As we can see that **e1** edge is between **0 and 1** that's why in the **column of 'e1'** we are putting **1** in the **0 and 1** rows. [**IMPORTANT**]
* As we can see that **e2** edge is between **1 and 2** that's why in the **column of 'e2'** we are putting **1** in the **1 and 2** rows.
* This is for **undirected graph**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2628a49a-1088-45e7-91fc-0e39b917d60e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9d634d98-4b26-47a6-b447-c8dc348b0716)

* **Sum of row** represent the **degree** of the **vertex**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/379930fb-c71f-4c97-980b-6f6f58b2117e)

* This is for **directed graph**.
* We can see that the **e1** edge is between **A and B** and the direction is from **A -> B** so in the **'e1' column** we are putting **1** in **B** as it is directed towards **B** and we are putting **-1** in **A**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/375001fb-53fb-447a-bb9a-f4b2eef0d2b2)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a820e051-ef03-44e3-8164-d4892d817aae)

* We are get the information in the **rows** only.
* The **positive values** in the **rows** is **indegree**.
* The **negative values** in the **rows** is **outdegree**.

## Linked List Representation

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/42ede66f-edf1-420c-820e-30d550367574)

## Hybrid Representation

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/74114c29-2a07-43e3-b46d-859fa082a91a)

* Each array hold the address of that vertex and it will say how many **edges** it is **connected** to.

## Graph Traversal Technique

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3c594adb-d7d3-4491-bc9b-be45601b919a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/03ba74d2-e3c6-4abd-9c52-874fae6f7d64)

* BFS and DFS

## BFS

* It is using **Queue** data structure.
* SV -> Source Vertex.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/99e2f344-b787-4ffb-8132-f14d608a5d8b)

* The **vertex** which are connected to **A** those vertex will be **inserted** can be in **any order**.
* The **vertex** which has already gone to the **queue**, no need to repeat that **vertex** because it is either **already visited** or **it is about to be visited**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/be0a786a-389f-47b1-a3b5-f23edbfa38eb)

* We are visiting **B**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ae7df18-88b1-46d1-b553-44681579a372)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/46187347-550b-4007-b27c-891e927034fe)

* Example [**IMPORTANT**]
* **BFS** traversal.
* More than 1 BFS traversal possible?

> Yes, more than 1 BFS traversal possible.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8631485e-2dcf-40ee-ba3f-debe71ce73fe)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5e35fd44-ef27-4a60-b5d1-37334811c55e)

* BFS Tree [Example] [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/874272cf-113e-48a5-aeb3-64b2d542be5e)

* SV -> A
* Find **BFS traversal**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/76be9d39-45e9-4a05-b2e4-ad37a9e095aa)

* Option **B and C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65ed5f34-ae81-4bd4-896e-df284517c347)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/878db94d-56aa-47a8-9b40-c23f3ecf6a89)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1246c98e-cf5d-40ed-adf2-9139f88c86c0)

* Question
* Option **B and C**

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2420eddf-998e-4fb5-b2fd-bfb62888a75c)

* Question
* Inserting.
* Starting vertex **A** -> ABCDEFGHI
* Starting vertex **G** -> GEFHIBCDA

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/169a0b4c-b51e-438d-8d37-fae6b0433d02)

* Solution.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ede19a21-e9c1-436f-bb85-c4e8d5e384b3)

* Question
* Reverse lexographical order.
* Starting vertex **G** -> GIHFEDCBA

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a381164c-1540-4ea7-8ab1-a660f5d1c553)

* Soltuion. [**IMPORTANT**]

## DFS using stack

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4e9fc96a-2843-4c50-882a-921d68cd631e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1c9df665-954e-4bc0-a215-224c38ee0086)

* We have to do **Backtracking**. [Example]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8169bcf1-34f7-47c2-b39e-dfceffbcfe75)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18e081a0-bdc7-425f-bd36-1c8990c5b866)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7009cc8e-45c2-4560-ad71-d84b35488c24)

* At the end the **stack** is empty. [**IMPORTANT**]
* When we do not get any path or unvisited vertex then we will do **backtracking** and go back to the **previous path** and start searching for a **path** from there.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/21255220-9c64-4539-85c6-6d45980d5aa5)

* Another **DFS** traversal.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/20ceda9a-cdad-473d-8069-a11398c25d3e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a574341-c7c1-44b3-84ec-876a2773402e)

* Question
* 12687453
* Option **A** -> Wrong

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/58774e5c-24a0-4b32-9f08-0c36cd3c497f)

* Option **B** -> Correct. [Red Color]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/46941757-ee72-468f-8eb3-0b8d13b58745)

* Option **C** -> Correct [Yellow]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/3cdfef68-53ab-410d-b415-c9c79f99e5ce)

* Option **D** -> Correct. [Blue]
* Answer -> Option **B, C and D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/15faa372-8b16-4305-aecf-8cf3b7f634be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2613dd8-6213-4d04-8184-c8f9fb58a74a)

* Time Complexities [BFS and DFS] [**VERY IMPORTANT**]
* Vertex(V)
* Edge(E)

## Single Source Shortest Path(SSSP) algo

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/49f97259-2ef6-4703-ad12-b1547c186872)

* Example.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/159ba059-8764-4120-a2c5-db4044ad6647)

* For **unweighted graphs** only we can use the **BFS algo** to find the **shortest path** instead of **Dijkrsta's algo**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ac05809-82cc-4fa6-a235-cd1801080be4)

* **I** is the destination.
* **BFS** is used if the graph is an **unweighted graphs** to reduce the **complexity**. We can apply **Dijkrstra's or bellmanford's algo** but their **complexities** would be **higher** compared to **BFS**. [**IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26c8a0f3-bd72-4746-bab6-cef856db9271)

* Next Class.

## tree-part-3 (30)

## Dijkrsta's Algo

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f9faeb08-d6f6-464d-b752-62686b5a32c5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0416246b-799c-4839-a2b7-03631277f294)

* Example

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/67fb41a8-98af-4827-87d9-f7ad1ca69efd)

* A
* Next we are visiting **C** because **C** has the **smallest value/number** among the others.
* As we got to **C** via **A** so we are taking the **edge** of **A -> C**.
* E -> 1 + 4 -> 5

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2ae00269-14a9-4953-a551-098f03c712b9)

* C
* Next we are visiting **B** because **B** has the **smallest value/number** among the others.
* As we got to **B** via **A** so we are taking the **edge** of **A -> B**.
* D -> 2 + 3 -> 5
* E -> 2 + 2 -> 4
* We got a **smaller value** for **E** that's why we updated the value of **E**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f0b8e04e-f7a9-4801-9d51-92f30a4d549c)

* B
* Next we are visiting **E** because **E** has the **smallest value/number** among the others.
* As we got to **E** via **B** so we are taking the **edge** of **B -> E**.
* F -> 4 + 4 -> 8

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/18ff9cbc-2a88-416f-84a4-ab1847c5e0cf)

* E
* Next we are visiting **D** because **D** has the **smallest value/number** among the others.
* As we got to **D** via **B** so we are taking the **edge** of **B -> D**.
* F -> 5 + 2 -> 7

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce8feb31-923e-482d-beba-4141247666ef)

* D
* Next we are visiting **F** because **F** has the **smallest value/number** among the others.
* As we got to **F** via **D** so we are taking the **edge** of **D -> F**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/201a7aef-c018-4141-8e6b-ce7d07ccf9ea)

* F

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/26d9767f-4429-4242-9812-66334befb572)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98e3298e-407c-44df-b929-9be84babe35a)

* Final Tree
* The **tree** shows us the **shortest path** from the **source vertex(SV)**.
* Solution [Working] [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/844918c3-8a17-438c-a38e-2767219c4dcb)

* Question

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/15306ad3-4aec-49d1-80b7-33ef80571d2e)

* There might be possible that there are **multiple shortest paths** for the **two vertices(A -> D)** but we will give the one which is given by the **algo**.
* The path given by the **algo** is the **answer**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98961725-56d6-4c4c-9543-f997b0eee7e9)

* Solution [**VERY IMPORTANT**]
* We will only update the **cost/value** of the node when it is **strictly decreasing**. If the **cost/value** are **same** then we will **not update**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1eb02783-678c-4950-a6f8-c517663096fa)

* Question.
* Find the **shortest path** from **A to I**?

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0d2e8b15-8aad-4301-a770-1ec5be361622)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8a6169c-6d5c-463b-b99a-8f96fa2b77e6)

* Solution [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/33e6d88e-14d5-47ba-8d94-356ce8d47355)

* Dijkrsta's Algo may fail in case of **negative edge**. [Problem]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a327e13-52d1-4b38-8eff-729063368abb)

* In the **B** vertex the **cost** has **reduced**.
* If the **visited vertex cost** is **decreased** then the **algo** is not capable of calculating the **shortest path**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ce61b01c-c521-41d7-a7ab-b0d88b43c6ba)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a7db92fc-1b66-486e-a24a-8985e1968996)

* Dijkrsta's algo -> Greedy Approach.
* Time Complexity -> Theta((V + E) * log V) [Vertices(V) and Edges(E)]

## Bellman Ford Algo

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/4ed27d29-7fa2-4564-8719-23a13a107e0c)

* Bellman Ford Algo -> Dynamic Programming approach
* It works correctly for **negative** edges in the graph but does not give shortest path in case of **negative cycle** in the graph.
* No algo can give **shortest path** in case of **negative cycle**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9b4621cd-24ac-4d70-867d-f504092a64da)

* Negative Edge
* **Bellman ford** can find the **shortest path** for **Negative edge**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8bed9a1-3cec-45b4-8ebb-e49b82d9d7af)

* Negative Cycle
* The no. of times the **cycle** rotates/loops the **cost of the edge** will **decrease** everytime.
* No algo can give the **shortest path** for **Negative Cycle**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2495fd44-cfa5-45b5-8131-5afcd20205ec)

* Bellman Ford
* We need to relax all the edges of graph **(V - 1)** times.
* After **(V - 1)** times we got our shortest path but we need to relax all the edges **1 more times** if path is reduced i.e there is **negative cycle**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/65b2f092-e4bc-4df7-a874-883a61e7773a)

* We have to run the **relax algo** '2' times as the **no. of vertex** is **3(A,B and C)**.
* We can go to **B** via **2 paths**, one is from **A** which is **0 + 3 -> 3** and the other path is from **C** whch is **infinity - 4**. As **3** is the **shortest cost** so we will take that as the **cost for 'B'**.
* For **C** we have **only one path** which is **infinity + 2** from **B**, so the **cost** of **C** is **infinity**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/783dc07e-326a-47ea-b854-ccfb36bc5027)

* For **B** we still get **3** as the **shortest cost** so we will take that as the **cost for 'B'**.
* For **C** we have one path which is **3 + 2 -> 5** so the **shortest cost** of **C** is **5** so the **cost of 'C'** is **5**.
* This maybe the **final result** if we do **relax algo** again and we get the **same costs** for the **vertices**. [**VERY IMPORTANT**]
* If the run the **relax algo** again and the **path** gets **smaller** then we definitely have a **negative cycle** in the graph. If the **path** remains the **same** then there is **no negative path** in the graph. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8eeb6595-d207-47bc-a6b6-9d35ea135d29)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/b0f8a7f1-b604-42b9-815a-a9e003a1d742)

* Relax **III**.
* Value is **updated** so we have a **negative cycle** in the graph. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/842c9fb9-95c3-4750-ada1-c11cf23eb2be)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ee6664c-50a9-44dc-b5d3-e4399100dd9e)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/880adb92-8514-40a7-bb45-35eae7c53a22)

* Time Complexity -> Theta(V * E) [Generalized Case] [Vertices(V) and Edges(E)]
* Time Complexity -> Theta(n ^ 3) [Worst Case] [Complete Graph(kn)] [Bellman Ford Algo]
* n -> no. of vertices.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5476d0c3-42c7-43c9-b7df-beaab8953e53)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/02c9d459-bb28-4182-98b0-2d248e0907eb)

* **Cycle Graph(Cn)** of **n** vertices, then the **no. of vertices and no. of edges** are **equal** which is **V = E = n**.
* Time Complexity -> Theta(V * E) -> Theta(n * n) -> Theta(n ^ 2) [V = E = n] [Cycle Graph(Cn)]
* All of the **graph based** algos for all of the **different-different graphs**, the relation between the **vertices and edges** and from there we can calculate the **Time Complexity**.
* **(V * E)** means the **multiplication of vertices(V) and edges(E)**.
* If a graph which doesn't have **any edges** which is **Null graph** then the **Time Complexity** is **constant or theta(1)**.
* If the graph is a **cycle graph** then the **Time Complexity** is **Theta(n * n)**.
* If the graph is a **complete graph** then the **Time Complexity** is **Theta(n ^ 3)**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/02ed258b-7016-421a-b62b-3519dafbe84a)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/a2a769ae-636d-41f1-a45b-6f20ac348158)

* **Bellman ford** algo is used because it can find **shortest path** for **negative edges** as well. [**VERY IMPORTANT**]
* Bellman ford can correctly find shortest path for **negative cycle** -> **FALSE**.
* Bellman ford is correctly work in case of **negative edge** -> **TRUE**.
* Time Complexity -> Theta(V * E) [Generalized Case]
* Time Complexity -> Theta(n ^ 3) [worst Case]

## Sample Paper Questions

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5cfdf41d-1b49-4ebb-b562-5e58c63249ba)

* 21

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e817356f-3d25-4e72-ae4e-f65316604fbd)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0bee172c-41ff-4b4b-a5d4-dadc00848a87)

* 22

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/00b5dba5-0bfb-4ade-a546-2576ed75f93f)

* Option **D**. [**VERY IMPORTANT**]
* We have to find using **recurrance relation** and using **master's theorem**. [Practice Again]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/f3fb6510-bb1d-47a9-b096-6bba31633c38)

* 23

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d9fb9249-5911-400e-aa26-2e30383f002b)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/20768b3a-7efe-436d-8331-f7b762dbf814)

* Option **D**.
* We are diving the array into **two parts** but we are not using both the **parts at the same time**, we are either going to the **left part** completely or we are going to the **right part** completely. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/320c6819-3c81-446d-8d54-03259d8cc39d)

* 24

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e993e7f7-3d54-4820-bc43-5c2bd9d7e110)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/22645fe7-9ad9-4efc-bec1-8c05bac25230)

* Answer -> 1022
* Trick there, need to understand the **logic**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/cc3d694b-e114-47fe-8947-158f75ce86e0)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/fbbe514a-9a61-4fba-a10f-18dd6e230b5a)

* 49
* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/01ee3622-db82-46e4-aa55-56a1d0331ee9)

* 50
* Option **A**.
* We are implementing **stack** using **two queues**.
* **D** should be **dequeue** only as it is in the **POP** part.
* Initially **Q1 and Q2** are both **empty**.
* **A** should be **enqueue** otherwise there is no significance of **A** being a **dequeue**.
* Let's say that **C** is **dequeue** then we are deleting the element from **Q1** and we are assuming **B** to be **enqueue** so we are pushing the deleted element to **Q2**.
* We are ultimately getting **stack** output as expected.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/e8a0b1c2-a7db-45e6-88c1-cd2b1402f4b5)

* [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/c923731d-d797-44e8-95c1-60adb11de0a5)

* 51

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5174a829-d531-4b12-a4f6-1daa1ccebbf5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/ed7752a5-d502-45ff-b224-520b394797b8)

* In option **Q and R** we can see that in the **b** array we can reduce them by taking **common** like in option **Q**, we can take **common of '2'** from the **b** array which is **2 * [1,2,3,4]**. In the option **R** we can also take a **common of '10'** from the **b** array which is **10 * [1,2,3,4]**.
* The combination are possible in **Q and R** options.
* If we do **square root** of the same numbers then we will get back the original numbers only which are **same**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/d3a844bb-7c22-4f10-a3a8-4fb0e7874334)

* Option **C**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/7a77fa62-384d-405d-bdca-2f8a1bf54f10)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/69346dc0-e079-420c-99f1-3689df714d13)

* 52
* As initial vertex is not given so we can choose any vertex as the **starting vertex**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/98365fb6-12b8-4e28-b286-efce0a9bb39a)

* Option **C**. [**VERY IMPORTANT**]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/6eca6c3c-3d2d-44ca-8938-5d2baa76a525)

* 26 [DBMS Question]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/1a591f44-2173-43fa-86e0-d54c691d47f5)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/df4ecb76-9f74-43e1-b262-898faa36ba7a)

* All are **false**. [Wrong Question] [marks will be given to all students]

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/401f5f06-0307-411b-b06c-1826e960319b)

* DBMS Question.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/9c7db7ee-9245-4a97-840f-47061e534d83)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/0f38e0a9-9ee1-483e-b8c9-9f1538b4c6e5)

* The query gave the name of those employees who have **good reviews** from customers.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bece8664-6331-42eb-a872-14b699df5f1c)

* Option **D**.

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/2f5d2dab-fe15-43c0-af67-80fed93dfcc7)

* TOPIC.

## Exam Tips

![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/8cbcf0f5-24db-45e9-86d9-5dd704c4ed27)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/bd3ba2c1-b489-4824-a0e1-06a2768a9ef7)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/03cfde56-c221-498b-b6c8-9bf145411fb1)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/5ead6a9b-7f9a-4e31-97b3-e2364318603d)
![image](https://github.com/arghanath007/Data-Structure-and-Algorithms/assets/54589605/eaacec52-443e-4548-ab39-b0ea22a3ae17)

* MSQ.